import { _ as __decorate, a as __param } from './contextkey.js';
import { E as Emitter } from './polyfill.js';
import { d as ILanguageDetectionService, u as unsupported } from './missing-services.js';
import { MutableDisposable, Disposable, ImmortalReference, dispose, toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { w as withUndefinedAsNull } from './types.js';
import { ThrottledDelayer } from 'monaco-editor/esm/vs/base/common/async.js';
import { PLAINTEXT_LANGUAGE_ID } from 'monaco-editor/esm/vs/editor/common/languages/modesRegistry.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { IAccessibilityService } from 'monaco-editor/esm/vs/platform/accessibility/common/accessibility.js';
import { I as IEditorService, e as SIDE_GROUP, A as ACTIVE_GROUP, i as IFileService, f as IUriIdentityService, s as isPreferredGroup, h as ITextFileService } from './services2.js';
import { MultiModelEditStackElement } from 'monaco-editor/esm/vs/editor/common/model/editStack.js';
import { ITextModelService } from 'monaco-editor/esm/vs/editor/common/services/resolverService.js';
import { IUndoRedoService } from 'monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js';
import { once } from 'monaco-editor/esm/vs/base/common/functional.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { AbstractCodeEditorService } from 'monaco-editor/esm/vs/editor/browser/services/abstractCodeEditorService.js';
import { isCodeEditor, isDiffEditor, getCodeEditor } from 'monaco-editor/esm/vs/editor/browser/editorBrowser.js';
import { isEqual } from 'monaco-editor/esm/vs/base/common/resources.js';
import { IThemeService } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { Dimension } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { SyncDescriptor } from 'monaco-editor/esm/vs/platform/instantiation/common/descriptors.js';
import { ICodeEditorService } from 'monaco-editor/esm/vs/editor/browser/services/codeEditorService.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { StandaloneServices } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js';
class ReferenceCollection {
    constructor() {
        this.references = ( (new Map()));
    }
    acquire(key, ...args) {
        let reference = this.references.get(key);
        if (!reference) {
            reference = { counter: 0, object: this.createReferencedObject(key, ...args) };
            this.references.set(key, reference);
        }
        const { object } = reference;
        const dispose = once(() => {
            if (--reference.counter === 0) {
                this.destroyReferencedObject(key, reference.object);
                this.references.delete(key);
            }
        });
        reference.counter++;
        return { object, dispose };
    }
}
class AsyncReferenceCollection {
    constructor(referenceCollection) {
        this.referenceCollection = referenceCollection;
    }
    async acquire(key, ...args) {
        const ref = this.referenceCollection.acquire(key, ...args);
        try {
            const object = await ref.object;
            return {
                object,
                dispose: () => ref.dispose()
            };
        }
        catch (error) {
            ref.dispose();
            throw error;
        }
    }
}
function isResolvedTextEditorModel(model) {
    const candidate = model;
    return !!candidate.textEditorModel;
}
function isResourceEditorInput(editor) {
    if (isEditorInput(editor)) {
        return false;
    }
    const candidate = editor;
    return URI.isUri(candidate?.resource);
}
class AbstractEditorInput extends Disposable {
}
function isEditorInput(editor) {
    return editor instanceof AbstractEditorInput;
}
function isTextEditorViewState(candidate) {
    const viewState = candidate;
    if (!viewState) {
        return false;
    }
    const diffEditorViewState = viewState;
    if (diffEditorViewState.modified) {
        return isTextEditorViewState(diffEditorViewState.modified);
    }
    const codeEditorViewState = viewState;
    return !!(codeEditorViewState.contributionsState && codeEditorViewState.viewState && Array.isArray(codeEditorViewState.cursorState));
}
function isCompositeEditor(thing) {
    return !!thing
        && typeof thing === 'object'
        && typeof thing.onDidChangeActiveEditor === 'function';
}
class EditorModel extends Disposable {
    constructor() {
        super(...arguments);
        this._onWillDispose = this._register(( (new Emitter())));
        this.onWillDispose = this._onWillDispose.event;
        this.disposed = false;
        this.resolved = false;
    }
    async resolve() {
        this.resolved = true;
    }
    isResolved() {
        return this.resolved;
    }
    isDisposed() {
        return this.disposed;
    }
    dispose() {
        this.disposed = true;
        this._onWillDispose.fire();
        super.dispose();
    }
}
let BaseTextEditorModel = class BaseTextEditorModel extends EditorModel {
    constructor(modelService, languageService, languageDetectionService, accessibilityService, textEditorModelHandle) {
        super();
        this.modelService = modelService;
        this.languageService = languageService;
        this.languageDetectionService = languageDetectionService;
        this.accessibilityService = accessibilityService;
        this.textEditorModelHandle = undefined;
        this.modelDisposeListener = this._register(( (new MutableDisposable())));
        this.autoDetectLanguageThrottler = this._register(( (new ThrottledDelayer(BaseTextEditorModel.AUTO_DETECT_LANGUAGE_THROTTLE_DELAY))));
        this._hasLanguageSetExplicitly = false;
        if (textEditorModelHandle) {
            this.handleExistingModel(textEditorModelHandle);
        }
    }
    handleExistingModel(textEditorModelHandle) {
        const model = this.modelService.getModel(textEditorModelHandle);
        if (!model) {
            throw new Error(`Document with resource ${textEditorModelHandle.toString(true)} does not exist`);
        }
        this.textEditorModelHandle = textEditorModelHandle;
        this.registerModelDisposeListener(model);
    }
    registerModelDisposeListener(model) {
        this.modelDisposeListener.value = model.onWillDispose(() => {
            this.textEditorModelHandle = undefined;
            this.dispose();
        });
    }
    get textEditorModel() {
        return this.textEditorModelHandle ? this.modelService.getModel(this.textEditorModelHandle) : null;
    }
    isReadonly() {
        return true;
    }
    get hasLanguageSetExplicitly() { return this._hasLanguageSetExplicitly; }
    setLanguageId(languageId) {
        this._hasLanguageSetExplicitly = true;
        this.setLanguageIdInternal(languageId);
    }
    setLanguageIdInternal(languageId) {
        if (!this.isResolved()) {
            return;
        }
        if (!languageId || languageId === this.textEditorModel.getLanguageId()) {
            return;
        }
        this.modelService.setMode(this.textEditorModel, this.languageService.createById(languageId));
    }
    getLanguageId() {
        return this.textEditorModel?.getLanguageId();
    }
    autoDetectLanguage() {
        return this.autoDetectLanguageThrottler.trigger(() => this.doAutoDetectLanguage());
    }
    async doAutoDetectLanguage() {
        if (this.hasLanguageSetExplicitly ||
            !this.textEditorModelHandle ||
            !this.languageDetectionService.isEnabledForLanguage(this.getLanguageId() ?? PLAINTEXT_LANGUAGE_ID)
        ) {
            return;
        }
        const lang = await this.languageDetectionService.detectLanguage(this.textEditorModelHandle);
        if (lang && !this.isDisposed()) {
            this.setLanguageIdInternal(lang);
            const languageName = this.languageService.getLanguageName(lang);
            if (languageName) {
                this.accessibilityService.alert(( (localize(
                    'languageAutoDetected',
                    "Language {0} was automatically detected and set as the language mode.",
                    languageName
                ))));
            }
        }
    }
    createTextEditorModel(value, resource, preferredLanguageId) {
        const firstLineText = this.getFirstLineText(value);
        const languageSelection = this.getOrCreateLanguage(resource, this.languageService, preferredLanguageId, firstLineText);
        return this.doCreateTextEditorModel(value, languageSelection, resource);
    }
    doCreateTextEditorModel(value, languageSelection, resource) {
        let model = resource && this.modelService.getModel(resource);
        if (!model) {
            model = this.modelService.createModel(value, languageSelection, resource);
            this.createdEditorModel = true;
            this.registerModelDisposeListener(model);
        }
        else {
            this.updateTextEditorModel(value, languageSelection.languageId);
        }
        this.textEditorModelHandle = model.uri;
        return model;
    }
    getFirstLineText(value) {
        const textBufferFactory = value;
        if (typeof textBufferFactory.getFirstLineText === 'function') {
            return textBufferFactory.getFirstLineText(1000 );
        }
        const textSnapshot = value;
        return textSnapshot.getLineContent(1).substr(0, 1000 );
    }
    getOrCreateLanguage(resource, languageService, preferredLanguage, firstLineText) {
        if (!preferredLanguage || preferredLanguage === PLAINTEXT_LANGUAGE_ID) {
            return languageService.createByFilepathOrFirstLine(withUndefinedAsNull(resource), firstLineText);
        }
        return languageService.createById(preferredLanguage);
    }
    updateTextEditorModel(newValue, preferredLanguageId) {
        if (!this.isResolved()) {
            return;
        }
        if (newValue) {
            this.modelService.updateModel(this.textEditorModel, newValue);
        }
        if (preferredLanguageId && preferredLanguageId !== PLAINTEXT_LANGUAGE_ID && this.textEditorModel.getLanguageId() !== preferredLanguageId) {
            this.modelService.setMode(this.textEditorModel, this.languageService.createById(preferredLanguageId));
        }
    }
    createSnapshot() {
        if (!this.textEditorModel) {
            return null;
        }
        return this.textEditorModel.createSnapshot(true );
    }
    isResolved() {
        return !!this.textEditorModelHandle;
    }
    dispose() {
        this.modelDisposeListener.dispose();
        if (this.textEditorModelHandle && this.createdEditorModel) {
            this.modelService.destroyModel(this.textEditorModelHandle);
        }
        this.textEditorModelHandle = undefined;
        this.createdEditorModel = false;
        super.dispose();
    }
};
BaseTextEditorModel.AUTO_DETECT_LANGUAGE_THROTTLE_DELAY = 600;
BaseTextEditorModel = ( (__decorate([
    ( (__param(0, IModelService))),
    ( (__param(1, ILanguageService))),
    ( (__param(2, ILanguageDetectionService))),
    ( (__param(3, IAccessibilityService)))
], BaseTextEditorModel)));
let TextResourceEditorModel = class TextResourceEditorModel extends BaseTextEditorModel {
    constructor(resource, languageService, modelService, languageDetectionService, accessibilityService) {
        super(modelService, languageService, languageDetectionService, accessibilityService, resource);
    }
    dispose() {
        if (this.textEditorModelHandle) {
            this.modelService.destroyModel(this.textEditorModelHandle);
        }
        super.dispose();
    }
};
TextResourceEditorModel = ( (__decorate([
    ( (__param(1, ILanguageService))),
    ( (__param(2, IModelService))),
    ( (__param(3, ILanguageDetectionService))),
    ( (__param(4, IAccessibilityService)))
], TextResourceEditorModel)));
class TextFileEditorModel {}
let ModelUndoRedoParticipant = class ModelUndoRedoParticipant extends Disposable {
    constructor(_modelService, _textModelService, _undoRedoService) {
        super();
        this._modelService = _modelService;
        this._textModelService = _textModelService;
        this._undoRedoService = _undoRedoService;
        this._register(this._modelService.onModelRemoved((model) => {
            const elements = this._undoRedoService.getElements(model.uri);
            if (elements.past.length === 0 && elements.future.length === 0) {
                return;
            }
            for (const element of elements.past) {
                if (element instanceof MultiModelEditStackElement) {
                    element.setDelegate(this);
                }
            }
            for (const element of elements.future) {
                if (element instanceof MultiModelEditStackElement) {
                    element.setDelegate(this);
                }
            }
        }));
    }
    prepareUndoRedo(element) {
        const missingModels = element.getMissingModels();
        if (missingModels.length === 0) {
            return Disposable.None;
        }
        const disposablesPromises = missingModels.map(async (uri) => {
            try {
                const reference = await this._textModelService.createModelReference(uri);
                return reference;
            }
            catch (err) {
                return Disposable.None;
            }
        });
        return Promise.all(disposablesPromises).then(disposables => {
            return {
                dispose: () => dispose(disposables)
            };
        });
    }
};
ModelUndoRedoParticipant = ( (__decorate([
    ( (__param(0, IModelService))),
    ( (__param(1, ITextModelService))),
    ( (__param(2, IUndoRedoService)))
], ModelUndoRedoParticipant)));
let ResourceModelCollection = class ResourceModelCollection extends ReferenceCollection {
    constructor(instantiationService, textFileService, fileService, modelService) {
        super();
        this.instantiationService = instantiationService;
        this.textFileService = textFileService;
        this.fileService = fileService;
        this.modelService = modelService;
        this.providers = ( (new Map()));
        this.modelsToDispose = ( (new Set()));
    }
    createReferencedObject(key) {
        return this.doCreateReferencedObject(key);
    }
    async doCreateReferencedObject(key, skipActivateProvider) {
        this.modelsToDispose.delete(key);
        const resource = ( (URI.parse(key)));
        if (resource.scheme === Schemas.inMemory) {
            const cachedModel = this.modelService.getModel(resource);
            if (!cachedModel) {
                throw new Error(`Unable to resolve inMemory resource ${key}`);
            }
            const model = this.instantiationService.createInstance(TextResourceEditorModel, resource);
            if (this.ensureResolvedModel(model, key)) {
                return model;
            }
        }
        if (resource.scheme === Schemas.untitled) {
            const model = await this.textFileService.untitled.resolve({ untitledResource: resource });
            if (this.ensureResolvedModel(model, key)) {
                return model;
            }
        }
        if (this.fileService.hasProvider(resource)) {
            const model = await this.textFileService.files.resolve(resource, { reason: 2  });
            if (this.ensureResolvedModel(model, key)) {
                return model;
            }
        }
        if (this.providers.has(resource.scheme)) {
            await this.resolveTextModelContent(key);
            const model = this.instantiationService.createInstance(TextResourceEditorModel, resource);
            if (this.ensureResolvedModel(model, key)) {
                return model;
            }
        }
        if (!skipActivateProvider) {
            await this.fileService.activateProvider(resource.scheme);
            return this.doCreateReferencedObject(key, true);
        }
        throw new Error(`Unable to resolve resource ${key}`);
    }
    ensureResolvedModel(model, key) {
        if (isResolvedTextEditorModel(model)) {
            return true;
        }
        throw new Error(`Unable to resolve resource ${key}`);
    }
    destroyReferencedObject(key, modelPromise) {
        const resource = ( (URI.parse(key)));
        if (resource.scheme === Schemas.untitled || resource.scheme === Schemas.inMemory) {
            return;
        }
        this.modelsToDispose.add(key);
        (async () => {
            try {
                const model = await modelPromise;
                if (!this.modelsToDispose.has(key)) {
                    return;
                }
                if (model instanceof TextFileEditorModel) {
                    await this.textFileService.files.canDispose(model);
                }
                if (!this.modelsToDispose.has(key)) {
                    return;
                }
                model.dispose();
            }
            catch (error) {
            }
            finally {
                this.modelsToDispose.delete(key);
            }
        })();
    }
    registerTextModelContentProvider(scheme, provider) {
        let providers = this.providers.get(scheme);
        if (!providers) {
            providers = [];
            this.providers.set(scheme, providers);
        }
        providers.unshift(provider);
        return toDisposable(() => {
            const providersForScheme = this.providers.get(scheme);
            if (!providersForScheme) {
                return;
            }
            const index = providersForScheme.indexOf(provider);
            if (index === -1) {
                return;
            }
            providersForScheme.splice(index, 1);
            if (providersForScheme.length === 0) {
                this.providers.delete(scheme);
            }
        });
    }
    hasTextModelContentProvider(scheme) {
        return this.providers.get(scheme) !== undefined;
    }
    async resolveTextModelContent(key) {
        const resource = ( (URI.parse(key)));
        const providersForScheme = this.providers.get(resource.scheme) || [];
        for (const provider of providersForScheme) {
            const value = await provider.provideTextContent(resource);
            if (value) {
                return value;
            }
        }
        throw new Error(`Unable to resolve text model content for resource ${key}`);
    }
};
ResourceModelCollection = ( (__decorate([
    ( (__param(0, IInstantiationService))),
    ( (__param(1, ITextFileService))),
    ( (__param(2, IFileService))),
    ( (__param(3, IModelService)))
], ResourceModelCollection)));
let TextModelResolverService = class TextModelResolverService extends Disposable {
    constructor(instantiationService, fileService, undoRedoService, modelService, uriIdentityService) {
        super();
        this.instantiationService = instantiationService;
        this.fileService = fileService;
        this.undoRedoService = undoRedoService;
        this.modelService = modelService;
        this.uriIdentityService = uriIdentityService;
        this.resourceModelCollection = this.instantiationService.createInstance(ResourceModelCollection);
        this.asyncModelCollection = ( (new AsyncReferenceCollection(this.resourceModelCollection)));
        this._register(( (new ModelUndoRedoParticipant(this.modelService, this, this.undoRedoService))));
    }
    async createModelReference(resource) {
        resource = this.uriIdentityService.asCanonicalUri(resource);
        return await this.asyncModelCollection.acquire(( (resource.toString())));
    }
    registerTextModelContentProvider(scheme, provider) {
        return this.resourceModelCollection.registerTextModelContentProvider(scheme, provider);
    }
    canHandleResource(resource) {
        if (this.fileService.hasProvider(resource) || resource.scheme === Schemas.untitled || resource.scheme === Schemas.inMemory) {
            return true;
        }
        return this.resourceModelCollection.hasTextModelContentProvider(resource.scheme);
    }
};
TextModelResolverService = ( (__decorate([
    ( (__param(0, IInstantiationService))),
    ( (__param(1, IFileService))),
    ( (__param(2, IUndoRedoService))),
    ( (__param(3, IModelService))),
    ( (__param(4, IUriIdentityService)))
], TextModelResolverService)));
function applyTextEditorOptions(options, editor, scrollType) {
    let applied = false;
    const viewState = massageEditorViewState(options);
    if (isTextEditorViewState(viewState)) {
        editor.restoreViewState(viewState);
        applied = true;
    }
    if (options.selection) {
        const range = {
            startLineNumber: options.selection.startLineNumber,
            startColumn: options.selection.startColumn,
            endLineNumber: options.selection.endLineNumber ?? options.selection.startLineNumber,
            endColumn: options.selection.endColumn ?? options.selection.startColumn
        };
        editor.setSelection(range, options.selectionSource ?? "code.navigation" );
        if (options.selectionRevealType === 2 ) {
            editor.revealRangeNearTop(range, scrollType);
        }
        else if (options.selectionRevealType === 3 ) {
            editor.revealRangeNearTopIfOutsideViewport(range, scrollType);
        }
        else if (options.selectionRevealType === 1 ) {
            editor.revealRangeInCenterIfOutsideViewport(range, scrollType);
        }
        else {
            editor.revealRangeInCenter(range, scrollType);
        }
        applied = true;
    }
    return applied;
}
function massageEditorViewState(options) {
    if (!options.selection || !options.viewState) {
        return options.viewState;
    }
    const candidateDiffViewState = options.viewState;
    if (candidateDiffViewState.modified) {
        candidateDiffViewState.modified.cursorState = [];
        return candidateDiffViewState;
    }
    const candidateEditorViewState = options.viewState;
    if (candidateEditorViewState.cursorState) {
        candidateEditorViewState.cursorState = [];
    }
    return candidateEditorViewState;
}
let CodeEditorService = class CodeEditorService extends AbstractCodeEditorService {
    constructor(editorService, themeService, configurationService) {
        super(themeService);
        this.editorService = editorService;
        this.configurationService = configurationService;
        this.registerCodeEditorOpenHandler(this.doOpenCodeEditor.bind(this));
        this.registerCodeEditorOpenHandler(this.doOpenCodeEditorFromDiff.bind(this));
    }
    getActiveCodeEditor() {
        const activeTextEditorControl = this.editorService.activeTextEditorControl;
        if (isCodeEditor(activeTextEditorControl)) {
            return activeTextEditorControl;
        }
        if (isDiffEditor(activeTextEditorControl)) {
            return activeTextEditorControl.getModifiedEditor();
        }
        const activeControl = this.editorService.activeEditorPane?.getControl();
        if (isCompositeEditor(activeControl) && isCodeEditor(activeControl.activeCodeEditor)) {
            return activeControl.activeCodeEditor;
        }
        return null;
    }
    async doOpenCodeEditorFromDiff(input, source, sideBySide) {
        const activeTextEditorControl = this.editorService.activeTextEditorControl;
        if (!sideBySide &&
            isDiffEditor(activeTextEditorControl) &&
            input.options &&
            input.resource &&
            source === activeTextEditorControl.getModifiedEditor() &&
            activeTextEditorControl.getModel() &&
            isEqual(input.resource, activeTextEditorControl.getModel()?.modified.uri)
        ) {
            const targetEditor = activeTextEditorControl.getModifiedEditor();
            applyTextEditorOptions(input.options, targetEditor, 0 );
            return targetEditor;
        }
        return null;
    }
    async doOpenCodeEditor(input, source, sideBySide) {
        const enablePreviewFromCodeNavigation = this.configurationService.getValue().workbench?.editor?.enablePreviewFromCodeNavigation;
        if (!enablePreviewFromCodeNavigation &&
            source &&
            !input.options?.pinned &&
            !sideBySide &&
            !isEqual(source.getModel()?.uri, input.resource)
        ) {
            for (const visiblePane of this.editorService.visibleEditorPanes) {
                if (getCodeEditor(visiblePane.getControl()) === source) {
                    visiblePane.group.pinEditor();
                    break;
                }
            }
        }
        const control = await this.editorService.openEditor(input, sideBySide ? SIDE_GROUP : ACTIVE_GROUP);
        if (control) {
            const widget = control.getControl();
            if (isCodeEditor(widget)) {
                return widget;
            }
            if (isCompositeEditor(widget) && isCodeEditor(widget.activeCodeEditor)) {
                return widget.activeCodeEditor;
            }
        }
        return null;
    }
};
CodeEditorService = ( (__decorate([
    ( (__param(0, IEditorService))),
    ( (__param(1, IThemeService))),
    ( (__param(2, IConfigurationService)))
], CodeEditorService)));
const DEFAULT_EDITOR_MIN_DIMENSIONS = ( (new Dimension(220, 70)));
const DEFAULT_EDITOR_MAX_DIMENSIONS = ( (new Dimension(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY)));
class SimpleEditorPane {
    constructor(editor) {
        this.editor = editor;
        this.onDidChangeControl = Event.None;
        this.onDidChangeSizeConstraints = Event.None;
        this.onDidFocus = Event.None;
        this.onDidBlur = Event.None;
        this.input = undefined;
        this.options = undefined;
        this.group = undefined;
        this.scopedContextKeyService = undefined;
        this.getViewState = unsupported;
        this.isVisible = unsupported;
        this.hasFocus = unsupported;
        this.getId = unsupported;
        this.getTitle = unsupported;
        this.focus = unsupported;
    }
    get minimumWidth() { return DEFAULT_EDITOR_MIN_DIMENSIONS.width; }
    get maximumWidth() { return DEFAULT_EDITOR_MAX_DIMENSIONS.width; }
    get minimumHeight() { return DEFAULT_EDITOR_MIN_DIMENSIONS.height; }
    get maximumHeight() { return DEFAULT_EDITOR_MAX_DIMENSIONS.height; }
    getControl() {
        return this.editor;
    }
}
let EditorService = class EditorService {
    constructor(_openEditor, textModelService) {
        this._openEditor = _openEditor;
        this.textModelService = textModelService;
        this.onDidActiveEditorChange = Event.None;
        this.onDidVisibleEditorsChange = Event.None;
        this.onDidEditorsChange = Event.None;
        this.onDidCloseEditor = Event.None;
        this.activeTextEditorLanguageId = undefined;
        this.visibleEditorPanes = [];
        this.visibleEditors = [];
        this.visibleTextEditorControls = [];
        this.editors = [];
        this.count = 0;
        this.getEditors = () => [];
        this.openEditors = unsupported;
        this.replaceEditors = unsupported;
        this.isOpened = () => false;
        this.isVisible = () => false;
        this.findEditors = () => [];
        this.save = unsupported;
        this.saveAll = unsupported;
        this.revert = unsupported;
        this.revertAll = unsupported;
        this.closeEditor = unsupported;
        this.closeEditors = unsupported;
    }
    get activeTextEditorControl() { return StandaloneServices.get(ICodeEditorService).getFocusedCodeEditor() ?? undefined; }
    async openEditor(editor, optionsOrPreferredGroup, preferredGroup) {
        const options = isEditorInput(editor) ? optionsOrPreferredGroup : editor.options;
        if (isPreferredGroup(optionsOrPreferredGroup)) {
            preferredGroup = optionsOrPreferredGroup;
        }
        const resource = isResourceEditorInput(editor) || isEditorInput(editor) ? editor.resource : undefined;
        if (resource == null) {
            throw new Error('Diff editors not supported');
        }
        let modelEditor;
        const modelService = StandaloneServices.get(IModelService);
        let model = modelService.getModel(resource);
        let newModelRef;
        if (model == null) {
            const modelRef = await this.textModelService.createModelReference(resource);
            newModelRef = modelRef;
            model = modelRef.object.textEditorModel;
        }
        else {
            const codeEditors = StandaloneServices.get(ICodeEditorService).listCodeEditors();
            modelEditor = codeEditors.find(editor => editor.getModel() === model);
        }
        if (modelEditor == null) {
            modelEditor = await this._openEditor(model, options, preferredGroup === SIDE_GROUP);
        }
        if (modelEditor == null) {
            newModelRef?.dispose();
            return undefined;
        }
        if (options != null) {
            applyTextEditorOptions(options, modelEditor, 1 );
        }
        modelEditor.focus();
        return new SimpleEditorPane(modelEditor);
    }
};
EditorService = ( __decorate([
    ( __param(1, ITextModelService))
], EditorService));
let CustomTextModelResolverService = class CustomTextModelResolverService extends TextModelResolverService {
    constructor(_instantiationService, fileService, undoRedoService, _modelService, uriIdentityService) {
        super(_instantiationService, fileService, undoRedoService, _modelService, uriIdentityService);
        this._instantiationService = _instantiationService;
        this._modelService = _modelService;
    }
    async createModelReference(resource) {
        const existingModel = this._modelService.getModel(resource);
        if (existingModel != null) {
            return new ImmortalReference(this._instantiationService.createInstance(TextResourceEditorModel, resource));
        }
        const ref = await super.createModelReference(resource);
        ref.object.textEditorModel.onWillDispose(() => {
            ref.dispose();
        });
        return ref;
    }
};
CustomTextModelResolverService = ( __decorate([
    ( __param(0, IInstantiationService)),
    ( __param(1, IFileService)),
    ( __param(2, IUndoRedoService)),
    ( __param(3, IModelService)),
    ( __param(4, IUriIdentityService))
], CustomTextModelResolverService));
function getServiceOverride(openEditor) {
    return {
        [( ITextModelService.toString())]: new SyncDescriptor(CustomTextModelResolverService),
        [( ICodeEditorService.toString())]: new SyncDescriptor(CodeEditorService),
        [( IEditorService.toString())]: new SyncDescriptor(EditorService, [openEditor])
    };
}
export { getServiceOverride as default };

import { _ as __decorate, a as __param } from './contextkey.js';
import { E as Emitter } from './polyfill.js';
import { j as ExtensionMessageCollector, n as ITextMateService, E as ExtensionsRegistry } from './missing-services.js';
export { n as ITextMateService } from './missing-services.js';
import { l as languagesExtPoint } from './languageService.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { I as IWorkbenchThemeService } from './workbenchThemeService.js';
import { Disposable, dispose } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { joinPath, isEqualOrParent, isEqual } from 'monaco-editor/esm/vs/base/common/resources.js';
import { r as registerExtensionFile, g as getServiceOverride$1, I as IExtensionResourceLoaderService } from './files.js';
import { TokenizationRegistry, EncodedTokenizationResult } from 'monaco-editor/esm/vs/editor/common/languages.js';
import { TokenMetadata } from 'monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js';
import { createStyleSheet } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { onUnexpectedError } from 'monaco-editor/esm/vs/base/common/errors.js';
import { Color } from 'monaco-editor/esm/vs/base/common/color.js';
import { equals } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { generateTokensCSSForColorMap } from 'monaco-editor/esm/vs/editor/common/languages/supports/tokenization.js';
import { isObject } from 'monaco-editor/esm/vs/base/common/types.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IProgressService } from 'monaco-editor/esm/vs/platform/progress/common/progress.js';
import { nullTokenizeEncoded } from 'monaco-editor/esm/vs/editor/common/languages/nullTokenize.js';
import { g as getExtensionPoint, c as consoleExtensionMessageHandler, o as onServicesInitialized } from './tools.js';
import { S as Services } from './services2.js';
import { bd as DEFAULT_EXTENSION } from './extHost.js';
import { c as createInjectedClass } from './injection.js';
import { SyncDescriptor } from 'monaco-editor/esm/vs/platform/instantiation/common/descriptors.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
const grammarsExtPoint = ( (ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'grammars',
    deps: [languagesExtPoint],
    jsonSchema: {
        description: ( (localize(
            'vscode.extension.contributes.grammars',
            'Contributes textmate tokenizers.'
        ))),
        type: 'array',
        defaultSnippets: [{ body: [{ language: '${1:id}', scopeName: 'source.${2:id}', path: './syntaxes/${3:id}.tmLanguage.' }] }],
        items: {
            type: 'object',
            defaultSnippets: [{ body: { language: '${1:id}', scopeName: 'source.${2:id}', path: './syntaxes/${3:id}.tmLanguage.' } }],
            properties: {
                language: {
                    description: ( (localize(
                        'vscode.extension.contributes.grammars.language',
                        'Language identifier for which this syntax is contributed to.'
                    ))),
                    type: 'string'
                },
                scopeName: {
                    description: ( (localize(
                        'vscode.extension.contributes.grammars.scopeName',
                        'Textmate scope name used by the tmLanguage file.'
                    ))),
                    type: 'string'
                },
                path: {
                    description: ( (localize(
                        'vscode.extension.contributes.grammars.path',
                        'Path of the tmLanguage file. The path is relative to the extension folder and typically starts with \'./syntaxes/\'.'
                    ))),
                    type: 'string'
                },
                embeddedLanguages: {
                    description: ( (localize(
                        'vscode.extension.contributes.grammars.embeddedLanguages',
                        'A map of scope name to language id if this grammar contains embedded languages.'
                    ))),
                    type: 'object'
                },
                tokenTypes: {
                    description: ( (localize(
                        'vscode.extension.contributes.grammars.tokenTypes',
                        'A map of scope name to token types.'
                    ))),
                    type: 'object',
                    additionalProperties: {
                        enum: ['string', 'comment', 'other']
                    }
                },
                injectTo: {
                    description: ( (localize(
                        'vscode.extension.contributes.grammars.injectTo',
                        'List of language scope names to which this grammar is injected to.'
                    ))),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                balancedBracketScopes: {
                    description: ( (localize(
                        'vscode.extension.contributes.grammars.balancedBracketScopes',
                        'Defines which scope names contain balanced brackets.'
                    ))),
                    type: 'array',
                    items: {
                        type: 'string'
                    },
                    default: ['*'],
                },
                unbalancedBracketScopes: {
                    description: ( (localize(
                        'vscode.extension.contributes.grammars.unbalancedBracketScopes',
                        'Defines which scope names do not contain balanced brackets.'
                    ))),
                    type: 'array',
                    items: {
                        type: 'string'
                    },
                    default: [],
                },
            },
            required: ['scopeName', 'path']
        }
    }
})));
class TMScopeRegistry extends Disposable {
    constructor() {
        super();
        this._scopeNameToLanguageRegistration = Object.create(null);
    }
    reset() {
        this._scopeNameToLanguageRegistration = Object.create(null);
    }
    register(def) {
        if (this._scopeNameToLanguageRegistration[def.scopeName]) {
            const existingRegistration = this._scopeNameToLanguageRegistration[def.scopeName];
            if (!isEqual(existingRegistration.location, def.location)) {
                console.warn(`Overwriting grammar scope name to file mapping for scope ${def.scopeName}.\n` +
                    `Old grammar file: ${( ( existingRegistration.location.toString()))}.\n` +
                    `New grammar file: ${( ( def.location.toString()))}`);
            }
        }
        this._scopeNameToLanguageRegistration[def.scopeName] = def;
    }
    getGrammarDefinition(scopeName) {
        return this._scopeNameToLanguageRegistration[scopeName] || null;
    }
}
const missingTMGrammarErrorMessage = 'No TM Grammar registered for this language.';
class TMGrammarFactory extends Disposable {
    constructor(host, grammarDefinitions, vscodeTextmate, onigLib) {
        super();
        this._host = host;
        this._initialState = vscodeTextmate.INITIAL;
        this._scopeRegistry = this._register(( (new TMScopeRegistry())));
        this._injections = {};
        this._injectedEmbeddedLanguages = {};
        this._languageToScope = ( (new Map()));
        this._grammarRegistry = this._register(new vscodeTextmate.Registry({
            onigLib: onigLib,
            loadGrammar: async (scopeName) => {
                const grammarDefinition = this._scopeRegistry.getGrammarDefinition(scopeName);
                if (!grammarDefinition) {
                    this._host.logTrace(`No grammar found for scope ${scopeName}`);
                    return null;
                }
                const location = grammarDefinition.location;
                try {
                    const content = await this._host.readFile(location);
                    return vscodeTextmate.parseRawGrammar(content, location.path);
                }
                catch (e) {
                    this._host.logError(`Unable to load and parse grammar for scope ${scopeName} from ${location}`, e);
                    return null;
                }
            },
            getInjections: (scopeName) => {
                const scopeParts = scopeName.split('.');
                let injections = [];
                for (let i = 1; i <= scopeParts.length; i++) {
                    const subScopeName = scopeParts.slice(0, i).join('.');
                    injections = [...injections, ...(this._injections[subScopeName] || [])];
                }
                return injections;
            }
        }));
        for (const validGrammar of grammarDefinitions) {
            this._scopeRegistry.register(validGrammar);
            if (validGrammar.injectTo) {
                for (const injectScope of validGrammar.injectTo) {
                    let injections = this._injections[injectScope];
                    if (!injections) {
                        this._injections[injectScope] = injections = [];
                    }
                    injections.push(validGrammar.scopeName);
                }
                if (validGrammar.embeddedLanguages) {
                    for (const injectScope of validGrammar.injectTo) {
                        let injectedEmbeddedLanguages = this._injectedEmbeddedLanguages[injectScope];
                        if (!injectedEmbeddedLanguages) {
                            this._injectedEmbeddedLanguages[injectScope] = injectedEmbeddedLanguages = [];
                        }
                        injectedEmbeddedLanguages.push(validGrammar.embeddedLanguages);
                    }
                }
            }
            if (validGrammar.language) {
                this._languageToScope.set(validGrammar.language, validGrammar.scopeName);
            }
        }
    }
    has(languageId) {
        return this._languageToScope.has(languageId);
    }
    setTheme(theme, colorMap) {
        this._grammarRegistry.setTheme(theme, colorMap);
    }
    getColorMap() {
        return this._grammarRegistry.getColorMap();
    }
    async createGrammar(languageId, encodedLanguageId) {
        const scopeName = this._languageToScope.get(languageId);
        if (typeof scopeName !== 'string') {
            throw new Error(missingTMGrammarErrorMessage);
        }
        const grammarDefinition = this._scopeRegistry.getGrammarDefinition(scopeName);
        if (!grammarDefinition) {
            throw new Error(missingTMGrammarErrorMessage);
        }
        const embeddedLanguages = grammarDefinition.embeddedLanguages;
        if (this._injectedEmbeddedLanguages[scopeName]) {
            const injectedEmbeddedLanguages = this._injectedEmbeddedLanguages[scopeName];
            for (const injected of injectedEmbeddedLanguages) {
                for (const scope of ( (Object.keys(injected)))) {
                    embeddedLanguages[scope] = injected[scope];
                }
            }
        }
        const containsEmbeddedLanguages = (( (Object.keys(embeddedLanguages))).length > 0);
        let grammar;
        try {
            grammar = await this._grammarRegistry.loadGrammarWithConfiguration(scopeName, encodedLanguageId, {
                embeddedLanguages,
                tokenTypes: grammarDefinition.tokenTypes,
                balancedBracketSelectors: grammarDefinition.balancedBracketSelectors,
                unbalancedBracketSelectors: grammarDefinition.unbalancedBracketSelectors,
            });
        }
        catch (err) {
            if (err.message && err.message.startsWith('No grammar provided for')) {
                throw new Error(missingTMGrammarErrorMessage);
            }
            throw err;
        }
        return {
            languageId: languageId,
            grammar: grammar,
            initialState: this._initialState,
            containsEmbeddedLanguages: containsEmbeddedLanguages
        };
    }
}
class TMTokenization extends Disposable {
    constructor(grammar, initialState, containsEmbeddedLanguages) {
        super();
        this._onDidEncounterLanguage = this._register(( (new Emitter())));
        this.onDidEncounterLanguage = this._onDidEncounterLanguage.event;
        this._grammar = grammar;
        this._initialState = initialState;
        this._containsEmbeddedLanguages = containsEmbeddedLanguages;
        this._seenLanguages = [];
    }
    getInitialState() {
        return this._initialState;
    }
    tokenize(line, hasEOL, state) {
        throw new Error('Not supported!');
    }
    tokenizeEncoded(line, hasEOL, state) {
        const textMateResult = this._grammar.tokenizeLine2(line, state, 500);
        if (textMateResult.stoppedEarly) {
            console.warn(`Time limit reached when tokenizing line: ${line.substring(0, 100)}`);
            return (
                 (new EncodedTokenizationResult(textMateResult.tokens, state))
            );
        }
        if (this._containsEmbeddedLanguages) {
            const seenLanguages = this._seenLanguages;
            const tokens = textMateResult.tokens;
            for (let i = 0, len = (tokens.length >>> 1); i < len; i++) {
                const metadata = tokens[(i << 1) + 1];
                const languageId = TokenMetadata.getLanguageId(metadata);
                if (!seenLanguages[languageId]) {
                    seenLanguages[languageId] = true;
                    this._onDidEncounterLanguage.fire(languageId);
                }
            }
        }
        let endState;
        if (state.equals(textMateResult.ruleStack)) {
            endState = state;
        }
        else {
            endState = textMateResult.ruleStack;
        }
        return (
             (new EncodedTokenizationResult(textMateResult.tokens, endState))
        );
    }
}
let AbstractTextMateService = class AbstractTextMateService extends Disposable {
    constructor(_languageService, _themeService, _extensionResourceLoaderService, _notificationService, _logService, _configurationService, _progressService) {
        super();
        this._languageService = _languageService;
        this._themeService = _themeService;
        this._extensionResourceLoaderService = _extensionResourceLoaderService;
        this._notificationService = _notificationService;
        this._logService = _logService;
        this._configurationService = _configurationService;
        this._progressService = _progressService;
        this._onDidEncounterLanguage = this._register(( (new Emitter())));
        this.onDidEncounterLanguage = this._onDidEncounterLanguage.event;
        this._vscodeOniguruma = null;
        this._styleElement = createStyleSheet();
        this._styleElement.className = 'vscode-tokens-styles';
        this._createdModes = [];
        this._encounteredLanguages = [];
        this._debugMode = false;
        this._debugModePrintFunc = () => { };
        this._grammarDefinitions = null;
        this._grammarFactory = null;
        this._tokenizersRegistrations = [];
        this._currentTheme = null;
        this._currentTokenColorMap = null;
        grammarsExtPoint.setHandler((extensions) => {
            this._grammarDefinitions = null;
            if (this._grammarFactory) {
                this._grammarFactory.dispose();
                this._grammarFactory = null;
                this._onDidDisposeGrammarFactory();
            }
            this._tokenizersRegistrations = dispose(this._tokenizersRegistrations);
            this._grammarDefinitions = [];
            for (const extension of extensions) {
                const grammars = extension.value;
                for (const grammar of grammars) {
                    if (!this._validateGrammarExtensionPoint(extension.description.extensionLocation, grammar, extension.collector)) {
                        continue;
                    }
                    const grammarLocation = joinPath(extension.description.extensionLocation, grammar.path);
                    const embeddedLanguages = Object.create(null);
                    if (grammar.embeddedLanguages) {
                        const scopes = ( (Object.keys(grammar.embeddedLanguages)));
                        for (let i = 0, len = scopes.length; i < len; i++) {
                            const scope = scopes[i];
                            const language = grammar.embeddedLanguages[scope];
                            if (typeof language !== 'string') {
                                continue;
                            }
                            if (this._languageService.isRegisteredLanguageId(language)) {
                                embeddedLanguages[scope] = this._languageService.languageIdCodec.encodeLanguageId(language);
                            }
                        }
                    }
                    const tokenTypes = Object.create(null);
                    if (grammar.tokenTypes) {
                        const scopes = ( (Object.keys(grammar.tokenTypes)));
                        for (const scope of scopes) {
                            const tokenType = grammar.tokenTypes[scope];
                            switch (tokenType) {
                                case 'string':
                                    tokenTypes[scope] = 2 ;
                                    break;
                                case 'other':
                                    tokenTypes[scope] = 0 ;
                                    break;
                                case 'comment':
                                    tokenTypes[scope] = 1 ;
                                    break;
                            }
                        }
                    }
                    let validLanguageId = null;
                    if (grammar.language && this._languageService.isRegisteredLanguageId(grammar.language)) {
                        validLanguageId = grammar.language;
                    }
                    function asStringArray(array, defaultValue) {
                        if (!Array.isArray(array)) {
                            return defaultValue;
                        }
                        if (!array.every(e => typeof e === 'string')) {
                            return defaultValue;
                        }
                        return array;
                    }
                    this._grammarDefinitions.push({
                        location: grammarLocation,
                        language: validLanguageId ? validLanguageId : undefined,
                        scopeName: grammar.scopeName,
                        embeddedLanguages: embeddedLanguages,
                        tokenTypes: tokenTypes,
                        injectTo: grammar.injectTo,
                        balancedBracketSelectors: asStringArray(grammar.balancedBracketScopes, ['*']),
                        unbalancedBracketSelectors: asStringArray(grammar.unbalancedBracketScopes, []),
                    });
                    if (validLanguageId) {
                        this._tokenizersRegistrations.push(TokenizationRegistry.registerFactory(validLanguageId, this._createFactory(validLanguageId)));
                    }
                }
            }
            for (const createMode of this._createdModes) {
                TokenizationRegistry.getOrCreate(createMode);
            }
        });
        this._updateTheme(this._grammarFactory, this._themeService.getColorTheme(), true);
        this._register(this._themeService.onDidColorThemeChange(() => {
            this._updateTheme(this._grammarFactory, this._themeService.getColorTheme(), false);
        }));
        this._languageService.onDidEncounterLanguage((languageId) => {
            this._createdModes.push(languageId);
        });
    }
    startDebugMode(printFn, onStop) {
        if (this._debugMode) {
            this._notificationService.error(( (localize('alreadyDebugging', "Already Logging."))));
            return;
        }
        this._debugModePrintFunc = printFn;
        this._debugMode = true;
        if (this._debugMode) {
            this._progressService.withProgress({
                location: 15 ,
                buttons: [( (localize('stop', "Stop")))]
            }, (progress) => {
                progress.report({
                    message: ( (localize(
                        'progress1',
                        "Preparing to log TM Grammar parsing. Press Stop when finished."
                    )))
                });
                return this._getVSCodeOniguruma().then((vscodeOniguruma) => {
                    vscodeOniguruma.setDefaultDebugCall(true);
                    progress.report({
                        message: ( (localize('progress2', "Now logging TM Grammar parsing. Press Stop when finished.")))
                    });
                    return (
                         (new Promise((resolve, reject) => { }))
                    );
                });
            }, (choice) => {
                this._getVSCodeOniguruma().then((vscodeOniguruma) => {
                    this._debugModePrintFunc = () => { };
                    this._debugMode = false;
                    vscodeOniguruma.setDefaultDebugCall(false);
                    onStop();
                });
            });
        }
    }
    _canCreateGrammarFactory() {
        return (this._grammarDefinitions ? true : false);
    }
    async _getOrCreateGrammarFactory() {
        if (this._grammarFactory) {
            return this._grammarFactory;
        }
        const [vscodeTextmate, vscodeOniguruma] = await Promise.all([import('vscode-textmate').then(module => module.default ?? module), this._getVSCodeOniguruma()]);
        const onigLib = Promise.resolve({
            createOnigScanner: (sources) => vscodeOniguruma.createOnigScanner(sources),
            createOnigString: (str) => vscodeOniguruma.createOnigString(str)
        });
        if (this._grammarFactory) {
            return this._grammarFactory;
        }
        this._grammarFactory = ( (new TMGrammarFactory({
            logTrace: (msg) => this._logService.trace(msg),
            logError: (msg, err) => this._logService.error(msg, err),
            readFile: (resource) => this._extensionResourceLoaderService.readExtensionResource(resource)
        }, this._grammarDefinitions || [], vscodeTextmate, onigLib)));
        this._onDidCreateGrammarFactory(this._grammarDefinitions || []);
        this._updateTheme(this._grammarFactory, this._themeService.getColorTheme(), true);
        return this._grammarFactory;
    }
    _createFactory(languageId) {
        return {
            createTokenizationSupport: async () => {
                if (!this._languageService.isRegisteredLanguageId(languageId)) {
                    return null;
                }
                if (!this._canCreateGrammarFactory()) {
                    return null;
                }
                const encodedLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);
                try {
                    const grammarFactory = await this._getOrCreateGrammarFactory();
                    if (!grammarFactory.has(languageId)) {
                        return null;
                    }
                    const r = await grammarFactory.createGrammar(languageId, encodedLanguageId);
                    if (!r.grammar) {
                        return null;
                    }
                    const tokenization = ( (new TMTokenization(r.grammar, r.initialState, r.containsEmbeddedLanguages)));
                    tokenization.onDidEncounterLanguage((encodedLanguageId) => {
                        if (!this._encounteredLanguages[encodedLanguageId]) {
                            const languageId = this._languageService.languageIdCodec.decodeLanguageId(encodedLanguageId);
                            this._encounteredLanguages[encodedLanguageId] = true;
                            this._onDidEncounterLanguage.fire(languageId);
                        }
                    });
                    return (
                         (new TMTokenizationSupportWithLineLimit(languageId, encodedLanguageId, tokenization, this._configurationService))
                    );
                }
                catch (err) {
                    if (err.message && err.message === missingTMGrammarErrorMessage) {
                        return null;
                    }
                    onUnexpectedError(err);
                    return null;
                }
            }
        };
    }
    static _toColorMap(colorMap) {
        const result = [null];
        for (let i = 1, len = colorMap.length; i < len; i++) {
            result[i] = ( (Color.fromHex(colorMap[i])));
        }
        return result;
    }
    _updateTheme(grammarFactory, colorTheme, forceUpdate) {
        if (!forceUpdate && this._currentTheme && this._currentTokenColorMap && AbstractTextMateService.equalsTokenRules(this._currentTheme.settings, colorTheme.tokenColors) && equals(this._currentTokenColorMap, colorTheme.tokenColorMap)) {
            return;
        }
        this._currentTheme = { name: colorTheme.label, settings: colorTheme.tokenColors };
        this._currentTokenColorMap = colorTheme.tokenColorMap;
        this._doUpdateTheme(grammarFactory, this._currentTheme, this._currentTokenColorMap);
    }
    _doUpdateTheme(grammarFactory, theme, tokenColorMap) {
        grammarFactory?.setTheme(theme, tokenColorMap);
        const colorMap = AbstractTextMateService._toColorMap(tokenColorMap);
        const cssRules = generateTokensCSSForColorMap(colorMap);
        this._styleElement.textContent = cssRules;
        TokenizationRegistry.setColorMap(colorMap);
    }
    static equalsTokenRules(a, b) {
        if (!b || !a || b.length !== a.length) {
            return false;
        }
        for (let i = b.length - 1; i >= 0; i--) {
            const r1 = b[i];
            const r2 = a[i];
            if (r1.scope !== r2.scope) {
                return false;
            }
            const s1 = r1.settings;
            const s2 = r2.settings;
            if (s1 && s2) {
                if (s1.fontStyle !== s2.fontStyle || s1.foreground !== s2.foreground || s1.background !== s2.background) {
                    return false;
                }
            }
            else if (!s1 || !s2) {
                return false;
            }
        }
        return true;
    }
    _validateGrammarExtensionPoint(extensionLocation, syntax, collector) {
        if (syntax.language && ((typeof syntax.language !== 'string') || !this._languageService.isRegisteredLanguageId(syntax.language))) {
            collector.error(( (localize(
                'invalid.language',
                "Unknown language in `contributes.{0}.language`. Provided value: {1}",
                grammarsExtPoint.name,
                String(syntax.language)
            ))));
            return false;
        }
        if (!syntax.scopeName || (typeof syntax.scopeName !== 'string')) {
            collector.error(( (localize(
                'invalid.scopeName',
                "Expected string in `contributes.{0}.scopeName`. Provided value: {1}",
                grammarsExtPoint.name,
                String(syntax.scopeName)
            ))));
            return false;
        }
        if (!syntax.path || (typeof syntax.path !== 'string')) {
            collector.error(( (localize(
                'invalid.path.0',
                "Expected string in `contributes.{0}.path`. Provided value: {1}",
                grammarsExtPoint.name,
                String(syntax.path)
            ))));
            return false;
        }
        if (syntax.injectTo && (!Array.isArray(syntax.injectTo) || syntax.injectTo.some(scope => typeof scope !== 'string'))) {
            collector.error(( (localize(
                'invalid.injectTo',
                "Invalid value in `contributes.{0}.injectTo`. Must be an array of language scope names. Provided value: {1}",
                grammarsExtPoint.name,
                JSON.stringify(syntax.injectTo)
            ))));
            return false;
        }
        if (syntax.embeddedLanguages && !isObject(syntax.embeddedLanguages)) {
            collector.error(( (localize(
                'invalid.embeddedLanguages',
                "Invalid value in `contributes.{0}.embeddedLanguages`. Must be an object map from scope name to language. Provided value: {1}",
                grammarsExtPoint.name,
                JSON.stringify(syntax.embeddedLanguages)
            ))));
            return false;
        }
        if (syntax.tokenTypes && !isObject(syntax.tokenTypes)) {
            collector.error(( (localize(
                'invalid.tokenTypes',
                "Invalid value in `contributes.{0}.tokenTypes`. Must be an object map from scope name to token type. Provided value: {1}",
                grammarsExtPoint.name,
                JSON.stringify(syntax.tokenTypes)
            ))));
            return false;
        }
        const grammarLocation = joinPath(extensionLocation, syntax.path);
        if (!isEqualOrParent(grammarLocation, extensionLocation)) {
            collector.warn(( (localize(
                'invalid.path.1',
                "Expected `contributes.{0}.path` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.",
                grammarsExtPoint.name,
                grammarLocation.path,
                extensionLocation.path
            ))));
        }
        return true;
    }
    async createGrammar(languageId) {
        if (!this._languageService.isRegisteredLanguageId(languageId)) {
            return null;
        }
        const grammarFactory = await this._getOrCreateGrammarFactory();
        if (!grammarFactory.has(languageId)) {
            return null;
        }
        const encodedLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);
        const { grammar } = await grammarFactory.createGrammar(languageId, encodedLanguageId);
        return grammar;
    }
    _onDidCreateGrammarFactory(grammarDefinitions) {
    }
    _onDidDisposeGrammarFactory() {
    }
    _getVSCodeOniguruma() {
        if (!this._vscodeOniguruma) {
            this._vscodeOniguruma = this._doGetVSCodeOniguruma();
        }
        return this._vscodeOniguruma;
    }
    async _doGetVSCodeOniguruma() {
        const [vscodeOniguruma, wasm] = await Promise.all([import('vscode-oniguruma').then(module => module.default ?? module), this._loadVSCodeOnigurumWASM()]);
        const options = {
            data: wasm,
            print: (str) => {
                this._debugModePrintFunc(str);
            }
        };
        await vscodeOniguruma.loadWASM(options);
        return vscodeOniguruma;
    }
};
AbstractTextMateService = ( (__decorate([
    ( (__param(0, ILanguageService))),
    ( (__param(1, IWorkbenchThemeService))),
    ( (__param(2, IExtensionResourceLoaderService))),
    ( (__param(3, INotificationService))),
    ( (__param(4, ILogService))),
    ( (__param(5, IConfigurationService))),
    ( (__param(6, IProgressService)))
], AbstractTextMateService)));
let TMTokenizationSupportWithLineLimit = class TMTokenizationSupportWithLineLimit {
    constructor(languageId, encodedLanguageId, actual, _configurationService) {
        this._configurationService = _configurationService;
        this._languageId = languageId;
        this._encodedLanguageId = encodedLanguageId;
        this._actual = actual;
        this._maxTokenizationLineLength = this._configurationService.getValue('editor.maxTokenizationLineLength', {
            overrideIdentifier: this._languageId
        });
        this._configurationService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('editor.maxTokenizationLineLength')) {
                this._maxTokenizationLineLength = this._configurationService.getValue('editor.maxTokenizationLineLength', {
                    overrideIdentifier: this._languageId
                });
            }
        });
    }
    getInitialState() {
        return this._actual.getInitialState();
    }
    tokenize(line, hasEOL, state) {
        throw new Error('Not supported!');
    }
    tokenizeEncoded(line, hasEOL, state) {
        if (line.length >= this._maxTokenizationLineLength) {
            return nullTokenizeEncoded(this._encodedLanguageId, state);
        }
        return this._actual.tokenizeEncoded(line, hasEOL, state);
    }
};
TMTokenizationSupportWithLineLimit = ( (__decorate([
    ( (__param(3, IConfigurationService)))
], TMTokenizationSupportWithLineLimit)));
let TextMateService = class TextMateService extends createInjectedClass(AbstractTextMateService) {
    constructor(loadVSCodeOnigurumWASM, instantiationService) {
        super(instantiationService);
        this.loadVSCodeOnigurumWASM = loadVSCodeOnigurumWASM;
    }
    _loadVSCodeOnigurumWASM() {
        return this.loadVSCodeOnigurumWASM();
    }
};
TextMateService = ( __decorate([
    ( __param(1, IInstantiationService))
], TextMateService));
const extensionPoint = getExtensionPoint('grammars');
function setGrammars(grammars, getContent, extension = Services.get().extension ?? DEFAULT_EXTENSION) {
    extensionPoint.acceptUsers([{
            description: extension,
            value: grammars,
            collector: new ExtensionMessageCollector(consoleExtensionMessageHandler, extension, extensionPoint.name)
        }]);
    for (const grammar of grammars) {
        registerExtensionFile(joinPath(extension.extensionLocation, grammar.path), () => getContent(grammar));
    }
}
function initialize(instantiationService) {
    instantiationService.invokeFunction((accessor) => accessor.get(ITextMateService));
}
function getServiceOverride(getOnigLib) {
    onServicesInitialized(initialize);
    return {
        ...getServiceOverride$1(),
        [( ITextMateService.toString())]: new SyncDescriptor(TextMateService, [getOnigLib])
    };
}
export { getServiceOverride as default, setGrammars };

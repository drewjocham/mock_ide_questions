import { E as Emitter } from './polyfill.js';
import { a as IntervalCounter, b as ILifecycleService } from './missing-services.js';
import { _ as __decorate, f as NotificationsFilter, a as __param, g as NeverShowAgainScope } from './contextkey.js';
import { n, B as ButtonBar, a as attachButtonStyler, g as getServiceOverride$1, b as attachProgressBarStyler, D as DialogHandlerContribution } from './layout.js';
import { focusBorder, registerColor, textLinkForeground, editorErrorForeground, editorWarningForeground, editorInfoForeground, widgetShadow, contrastBorder, editorWidgetBackground, lighten, darken, editorWidgetForeground } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { Disposable, toDisposable, DisposableStore, dispose } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { NoOpNotification, Severity, INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { isCancellationError } from 'monaco-editor/esm/vs/base/common/errors.js';
import { toErrorMessage } from 'monaco-editor/esm/vs/base/common/errorMessage.js';
import { equals, isNonEmptyArray } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { Action, ActionRunner } from 'monaco-editor/esm/vs/base/common/actions.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { hash } from 'monaco-editor/esm/vs/base/common/hash.js';
import { i as IFileService, b as IEditorGroupsService, o as IHostService } from './services2.js';
import { RawContextKey, IContextKeyService, ContextKeyExpr } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { isEqual, basename, dirname, extname } from 'monaco-editor/esm/vs/base/common/resources.js';
import { ICommandService } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { KeybindingsRegistry } from 'monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js';
import { WorkbenchList, IListService } from 'monaco-editor/esm/vs/platform/list/browser/listService.js';
import { MenuRegistry, MenuId } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { registerIcon } from 'monaco-editor/esm/vs/platform/theme/common/iconRegistry.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { registerThemingParticipant, ThemeIcon, Themable, IThemeService } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { IClipboardService } from 'monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js';
import { Dimension, addDisposableListener, EventType, EventHelper, clearNode, scheduleAtNextAnimationFrame, isAncestor, $, trackFocus, getClientArea } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { DomEmitter } from 'monaco-editor/esm/vs/base/browser/event.js';
import { Gesture, EventType as EventType$1 } from 'monaco-editor/esm/vs/base/browser/touch.js';
import { ActionBar } from 'monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.js';
import { ProgressBar } from 'monaco-editor/esm/vs/base/browser/ui/progressbar/progressbar.js';
import { IContextMenuService } from 'monaco-editor/esm/vs/platform/contextview/browser/contextView.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { IOpenerService } from 'monaco-editor/esm/vs/platform/opener/common/opener.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { DropdownMenuActionViewItem } from 'monaco-editor/esm/vs/base/browser/ui/dropdown/dropdownActionViewItem.js';
import { a as assertAllDefined } from './types.js';
import { assertIsDefined } from 'monaco-editor/esm/vs/base/common/types.js';
import { I as IWorkbenchLayoutService } from './layoutService.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { alert } from 'monaco-editor/esm/vs/base/browser/ui/aria/aria.js';
import { o as onServicesInitialized } from './tools.js';
import { SyncDescriptor } from 'monaco-editor/esm/vs/platform/instantiation/common/descriptors.js';
import { ILayoutService } from 'monaco-editor/esm/vs/platform/layout/browser/layoutService.js';
function isErrorWithActions(obj) {
    const candidate = obj;
    return candidate instanceof Error && Array.isArray(candidate.actions);
}
var css$3 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-workbench > .notifications-toasts {\n\tposition: absolute;\n\tz-index: 1000;\n\tright: 3px;\n\tbottom: 26px;\n\tdisplay: none;\n\toverflow: hidden;\n}\n\n.monaco-workbench.nostatusbar > .notifications-toasts {\n\tbottom: 3px;\n}\n\n.monaco-workbench > .notifications-toasts.visible {\n\tdisplay: flex;\n\tflex-direction: column;\n}\n\n.monaco-workbench > .notifications-toasts .notification-toast-container {\n\toverflow: hidden; /* this ensures that the notification toast does not shine through */\n}\n\n.monaco-workbench > .notifications-toasts .notification-toast-container > .notification-toast {\n\tmargin: 8px; /* enables separation and drop shadows around toasts */\n\ttransform: translate3d(0px, 100%, 0px); /* move the notification 50px to the bottom (to prevent bleed through) */\n\topacity: 0; /*  fade the toast in */\n\ttransition:\ttransform 300ms ease-out, opacity 300ms ease-out;\n}\n\n.monaco-workbench.reduce-motion > .notifications-toasts .notification-toast-container > .notification-toast {\n\ttransition:\ttransform 0ms ease-out, opacity 0ms ease-out;\n}\n\n.monaco-workbench > .notifications-toasts .notification-toast-container > .notification-toast.notification-fade-in {\n\topacity: 1;\n\ttransform: none;\n}\n\n.monaco-workbench > .notifications-toasts .notification-toast-container > .notification-toast.notification-fade-in-done {\n\topacity: 1;\n\ttransform: none;\n\ttransition:\tnone;\n}\n";
n(css$3,{});
var css$2 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/** Notification: Container */\n\n.monaco-workbench .notifications-list-container .notification-list-item {\n\tdisplay: flex;\n\tflex-direction: column;\n\tflex-direction: column-reverse; /* the details row appears first in order for better keyboard access to notification buttons */\n\tpadding: 10px 5px;\n\theight: 100%;\n\tbox-sizing: border-box;\n}\n\n.monaco-workbench .notifications-list-container .notification-offset-helper {\n\topacity: 0;\n\tposition: absolute;\n\tline-height: 22px;\n\tword-wrap: break-word; /* never overflow long words, but break to next line */\n}\n\n/** Notification: Main Row */\n\n.monaco-workbench .notifications-list-container .notification-list-item > .notification-list-item-main-row {\n\tdisplay: flex;\n\tflex-grow: 1;\n}\n\n/** Notification: Icon */\n\n.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-icon {\n\tdisplay: flex;\n\talign-items: center;\n\tflex: 0 0 16px;\n\theight: 22px;\n\tmargin-right: 4px;\n\tmargin-left: 4px;\n\tfont-size: 18px;\n\tbackground-position: center;\n\tbackground-repeat: no-repeat;\n}\n\n/** Notification: Message */\n\n.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-message {\n\tline-height: 22px;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\tflex: 1; /* let the message always grow */\n\tuser-select: text;\n\t-webkit-user-select: text;\n}\n\n.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-message a:focus {\n\toutline-width: 1px;\n\toutline-style: solid;\n}\n\n.monaco-workbench .notifications-list-container .notification-list-item.expanded .notification-list-item-message {\n\twhite-space: normal;\n\tword-wrap: break-word; /* never overflow long words, but break to next line */\n}\n\n/** Notification: Toolbar Container */\n\n.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-toolbar-container {\n\tdisplay: none;\n\theight: 22px;\n}\n\n.monaco-workbench .notifications-list-container .notification-list-item:hover .notification-list-item-toolbar-container,\n.monaco-workbench .notifications-list-container .monaco-list-row.focused .notification-list-item .notification-list-item-toolbar-container,\n.monaco-workbench .notifications-list-container .notification-list-item.expanded .notification-list-item-toolbar-container {\n\tdisplay: block;\n}\n\n/** Notification: Details Row */\n\n.monaco-workbench .notifications-list-container .notification-list-item > .notification-list-item-details-row {\n\tdisplay: none;\n\talign-items: center;\n\tpadding-left: 5px;\n\toverflow: hidden; /* details row should never overflow */\n}\n\n.monaco-workbench .notifications-list-container .notification-list-item.expanded > .notification-list-item-details-row {\n\tdisplay: flex;\n}\n\n/** Notification: Source */\n\n.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-source {\n\tflex: 1;\n\tfont-size: 12px;\n\toverflow: hidden; /* always give away space to buttons container */\n\ttext-overflow: ellipsis;\n}\n\n/** Notification: Buttons */\n\n.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-buttons-container {\n\tdisplay: flex;\n\toverflow: hidden;\n}\n\n.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-buttons-container > .monaco-button-dropdown,\n.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-buttons-container > .monaco-button {\n\tmargin: 4px 5px; /* allows button focus outline to be visible */\n}\n\n.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-buttons-container .monaco-button {\n\toutline-offset: 2px !important;\n}\n\n.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-buttons-container .monaco-text-button {\n\twidth: fit-content;\n\twidth: -moz-fit-content;\n\tpadding: 5px 10px;\n\tdisplay: inline-block;\t/* to enable ellipsis in text overflow */\n\tfont-size: 12px;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n}\n\n.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-buttons-container .monaco-dropdown-button {\n\tpadding: 5px\n}\n\n/** Notification: Progress */\n\n.monaco-workbench .notifications-list-container .progress-bit {\n\theight: 2px;\n\tbottom: 0;\n}\n";
n(css$2,{});
const NOTIFICATIONS_CENTER_BORDER = ( (registerColor('notificationCenter.border', {
    dark: null,
    light: null,
    hcDark: contrastBorder,
    hcLight: contrastBorder
},  (localize(
    'notificationCenterBorder',
    "Notifications center border color. Notifications slide in from the bottom right of the window."
)))));
const NOTIFICATIONS_TOAST_BORDER = ( (registerColor('notificationToast.border', {
    dark: null,
    light: null,
    hcDark: contrastBorder,
    hcLight: contrastBorder
},  (localize(
    'notificationToastBorder',
    "Notification toast border color. Notifications slide in from the bottom right of the window."
)))));
const NOTIFICATIONS_FOREGROUND = ( (registerColor('notifications.foreground', {
    dark: editorWidgetForeground,
    light: editorWidgetForeground,
    hcDark: editorWidgetForeground,
    hcLight: editorWidgetForeground
},  (localize(
    'notificationsForeground',
    "Notifications foreground color. Notifications slide in from the bottom right of the window."
)))));
const NOTIFICATIONS_BACKGROUND = ( (registerColor('notifications.background', {
    dark: editorWidgetBackground,
    light: editorWidgetBackground,
    hcDark: editorWidgetBackground,
    hcLight: editorWidgetBackground
},  (localize(
    'notificationsBackground',
    "Notifications background color. Notifications slide in from the bottom right of the window."
)))));
const NOTIFICATIONS_LINKS = ( (registerColor('notificationLink.foreground', {
    dark: textLinkForeground,
    light: textLinkForeground,
    hcDark: textLinkForeground,
    hcLight: textLinkForeground
},  (localize(
    'notificationsLink',
    "Notification links foreground color. Notifications slide in from the bottom right of the window."
)))));
const NOTIFICATIONS_CENTER_HEADER_FOREGROUND = ( (registerColor('notificationCenterHeader.foreground', {
    dark: null,
    light: null,
    hcDark: null,
    hcLight: null
},  (localize(
    'notificationCenterHeaderForeground',
    "Notifications center header foreground color. Notifications slide in from the bottom right of the window."
)))));
const NOTIFICATIONS_CENTER_HEADER_BACKGROUND = ( (registerColor('notificationCenterHeader.background', {
    dark: ( (lighten(NOTIFICATIONS_BACKGROUND, 0.3))),
    light: ( (darken(NOTIFICATIONS_BACKGROUND, 0.05))),
    hcDark: NOTIFICATIONS_BACKGROUND,
    hcLight: NOTIFICATIONS_BACKGROUND
},  (localize(
    'notificationCenterHeaderBackground',
    "Notifications center header background color. Notifications slide in from the bottom right of the window."
)))));
const NOTIFICATIONS_BORDER = ( (registerColor('notifications.border', {
    dark: NOTIFICATIONS_CENTER_HEADER_BACKGROUND,
    light: NOTIFICATIONS_CENTER_HEADER_BACKGROUND,
    hcDark: NOTIFICATIONS_CENTER_HEADER_BACKGROUND,
    hcLight: NOTIFICATIONS_CENTER_HEADER_BACKGROUND
},  (localize(
    'notificationsBorder',
    "Notifications border color separating from other notifications in the notifications center. Notifications slide in from the bottom right of the window."
)))));
const NOTIFICATIONS_ERROR_ICON_FOREGROUND = ( (registerColor('notificationsErrorIcon.foreground', {
    dark: editorErrorForeground,
    light: editorErrorForeground,
    hcDark: editorErrorForeground,
    hcLight: editorErrorForeground
},  (localize(
    'notificationsErrorIconForeground',
    "The color used for the icon of error notifications. Notifications slide in from the bottom right of the window."
)))));
const NOTIFICATIONS_WARNING_ICON_FOREGROUND = ( (registerColor('notificationsWarningIcon.foreground', {
    dark: editorWarningForeground,
    light: editorWarningForeground,
    hcDark: editorWarningForeground,
    hcLight: editorWarningForeground
},  (localize(
    'notificationsWarningIconForeground',
    "The color used for the icon of warning notifications. Notifications slide in from the bottom right of the window."
)))));
const NOTIFICATIONS_INFO_ICON_FOREGROUND = ( (registerColor('notificationsInfoIcon.foreground', {
    dark: editorInfoForeground,
    light: editorInfoForeground,
    hcDark: editorInfoForeground,
    hcLight: editorInfoForeground
},  (localize(
    'notificationsInfoIconForeground',
    "The color used for the icon of info notifications. Notifications slide in from the bottom right of the window."
)))));
class LinkedText {
    constructor(nodes) {
        this.nodes = nodes;
    }
    toString() {
        return this.nodes.map(node => typeof node === 'string' ? node : node.label).join('');
    }
}
const LINK_REGEX = /\[([^\]]+)\]\(((?:https?:\/\/|command:|file:)[^\)\s]+)(?: ("|')([^\3]+)(\3))?\)/gi;
function parseLinkedText(text) {
    const result = [];
    let index = 0;
    let match;
    while (match = LINK_REGEX.exec(text)) {
        if (match.index - index > 0) {
            result.push(text.substring(index, match.index));
        }
        const [, label, href, , title] = match;
        if (title) {
            result.push({ label, href, title });
        }
        else {
            result.push({ label, href });
        }
        index = match.index + match[0].length;
    }
    if (index < text.length) {
        result.push(text.substring(index));
    }
    return (
         (new LinkedText(result))
    );
}
class NotificationHandle extends Disposable {
    constructor(item, onClose) {
        super();
        this.item = item;
        this.onClose = onClose;
        this._onDidClose = this._register(( (new Emitter())));
        this.onDidClose = this._onDidClose.event;
        this._onDidChangeVisibility = this._register(( (new Emitter())));
        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.item.onDidChangeVisibility(visible => this._onDidChangeVisibility.fire(visible)));
        Event.once(this.item.onDidClose)(() => {
            this._onDidClose.fire();
            this.dispose();
        });
    }
    get progress() {
        return this.item.progress;
    }
    updateSeverity(severity) {
        this.item.updateSeverity(severity);
    }
    updateMessage(message) {
        this.item.updateMessage(message);
    }
    updateActions(actions) {
        this.item.updateActions(actions);
    }
    close() {
        this.onClose(this.item);
        this.dispose();
    }
}
class NotificationsModel extends Disposable {
    constructor() {
        super(...arguments);
        this._onDidChangeNotification = this._register(( (new Emitter())));
        this.onDidChangeNotification = this._onDidChangeNotification.event;
        this._onDidChangeStatusMessage = this._register(( (new Emitter())));
        this.onDidChangeStatusMessage = this._onDidChangeStatusMessage.event;
        this._onDidChangeFilter = this._register(( (new Emitter())));
        this.onDidChangeFilter = this._onDidChangeFilter.event;
        this._notifications = [];
        this.filter = NotificationsFilter.OFF;
    }
    get notifications() { return this._notifications; }
    get statusMessage() { return this._statusMessage; }
    setFilter(filter) {
        this.filter = filter;
        this._onDidChangeFilter.fire(filter);
    }
    addNotification(notification) {
        const item = this.createViewItem(notification);
        if (!item) {
            return NotificationsModel.NO_OP_NOTIFICATION;
        }
        const duplicate = this.findNotification(item);
        if (duplicate) {
            duplicate.close();
        }
        this._notifications.splice(0, 0, item);
        this._onDidChangeNotification.fire({ item, index: 0, kind: 0  });
        return (
             (new NotificationHandle(item, item => this.onClose(item)))
        );
    }
    onClose(item) {
        const liveItem = this.findNotification(item);
        if (liveItem && liveItem !== item) {
            liveItem.close();
        }
        else {
            item.close();
        }
    }
    findNotification(item) {
        return this._notifications.find(notification => notification.equals(item));
    }
    createViewItem(notification) {
        const item = NotificationViewItem.create(notification, this.filter);
        if (!item) {
            return undefined;
        }
        const fireNotificationChangeEvent = (kind, detail) => {
            const index = this._notifications.indexOf(item);
            if (index >= 0) {
                this._onDidChangeNotification.fire({ item, index, kind, detail });
            }
        };
        const itemExpansionChangeListener = item.onDidChangeExpansion(() => fireNotificationChangeEvent(2 ));
        const itemContentChangeListener = item.onDidChangeContent(e => fireNotificationChangeEvent(1 , e.kind));
        Event.once(item.onDidClose)(() => {
            itemExpansionChangeListener.dispose();
            itemContentChangeListener.dispose();
            const index = this._notifications.indexOf(item);
            if (index >= 0) {
                this._notifications.splice(index, 1);
                this._onDidChangeNotification.fire({ item, index, kind: 3  });
            }
        });
        return item;
    }
    showStatusMessage(message, options) {
        const item = StatusMessageViewItem.create(message, options);
        if (!item) {
            return Disposable.None;
        }
        this._statusMessage = item;
        this._onDidChangeStatusMessage.fire({ kind: 0 , item });
        return toDisposable(() => {
            if (this._statusMessage === item) {
                this._statusMessage = undefined;
                this._onDidChangeStatusMessage.fire({ kind: 1 , item });
            }
        });
    }
}
NotificationsModel.NO_OP_NOTIFICATION = ( (new NoOpNotification()));
function isNotificationViewItem(obj) {
    return obj instanceof NotificationViewItem;
}
class NotificationViewItemProgress extends Disposable {
    constructor() {
        super();
        this._onDidChange = this._register(( (new Emitter())));
        this.onDidChange = this._onDidChange.event;
        this._state = Object.create(null);
    }
    get state() {
        return this._state;
    }
    infinite() {
        if (this._state.infinite) {
            return;
        }
        this._state.infinite = true;
        this._state.total = undefined;
        this._state.worked = undefined;
        this._state.done = undefined;
        this._onDidChange.fire();
    }
    done() {
        if (this._state.done) {
            return;
        }
        this._state.done = true;
        this._state.infinite = undefined;
        this._state.total = undefined;
        this._state.worked = undefined;
        this._onDidChange.fire();
    }
    total(value) {
        if (this._state.total === value) {
            return;
        }
        this._state.total = value;
        this._state.infinite = undefined;
        this._state.done = undefined;
        this._onDidChange.fire();
    }
    worked(value) {
        if (typeof this._state.worked === 'number') {
            this._state.worked += value;
        }
        else {
            this._state.worked = value;
        }
        this._state.infinite = undefined;
        this._state.done = undefined;
        this._onDidChange.fire();
    }
}
class NotificationViewItem extends Disposable {
    constructor(id, _severity, _sticky, _silent, _message, _source, progress, actions) {
        super();
        this.id = id;
        this._severity = _severity;
        this._sticky = _sticky;
        this._silent = _silent;
        this._message = _message;
        this._source = _source;
        this._visible = false;
        this._onDidChangeExpansion = this._register(( (new Emitter())));
        this.onDidChangeExpansion = this._onDidChangeExpansion.event;
        this._onDidClose = this._register(( (new Emitter())));
        this.onDidClose = this._onDidClose.event;
        this._onDidChangeContent = this._register(( (new Emitter())));
        this.onDidChangeContent = this._onDidChangeContent.event;
        this._onDidChangeVisibility = this._register(( (new Emitter())));
        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
        if (progress) {
            this.setProgress(progress);
        }
        this.setActions(actions);
    }
    static create(notification, filter = NotificationsFilter.OFF) {
        if (!notification || !notification.message || isCancellationError(notification.message)) {
            return undefined;
        }
        let severity;
        if (typeof notification.severity === 'number') {
            severity = notification.severity;
        }
        else {
            severity = Severity.Info;
        }
        const message = NotificationViewItem.parseNotificationMessage(notification.message);
        if (!message) {
            return undefined;
        }
        let actions;
        if (notification.actions) {
            actions = notification.actions;
        }
        else if (isErrorWithActions(notification.message)) {
            actions = { primary: notification.message.actions };
        }
        return (
             (new NotificationViewItem(
                notification.id,
                severity,
                notification.sticky,
                notification.silent || filter === NotificationsFilter.SILENT || (filter === NotificationsFilter.ERROR && notification.severity !== Severity.Error),
                message,
                notification.source,
                notification.progress,
                actions
            ))
        );
    }
    static parseNotificationMessage(input) {
        let message;
        if (input instanceof Error) {
            message = toErrorMessage(input, false);
        }
        else if (typeof input === 'string') {
            message = input;
        }
        if (!message) {
            return undefined;
        }
        const raw = message;
        if (message.length > NotificationViewItem.MAX_MESSAGE_LENGTH) {
            message = `${message.substr(0, NotificationViewItem.MAX_MESSAGE_LENGTH)}...`;
        }
        message = message.replace(/(\r\n|\n|\r)/gm, ' ').trim();
        const linkedText = parseLinkedText(message);
        return { raw, linkedText, original: input };
    }
    setProgress(progress) {
        if (progress.infinite) {
            this.progress.infinite();
        }
        else if (progress.total) {
            this.progress.total(progress.total);
            if (progress.worked) {
                this.progress.worked(progress.worked);
            }
        }
    }
    setActions(actions = { primary: [], secondary: [] }) {
        this._actions = {
            primary: Array.isArray(actions.primary) ? actions.primary : [],
            secondary: Array.isArray(actions.secondary) ? actions.secondary : []
        };
        this._expanded = actions.primary && actions.primary.length > 0;
    }
    get canCollapse() {
        return !this.hasActions;
    }
    get expanded() {
        return !!this._expanded;
    }
    get severity() {
        return this._severity;
    }
    get sticky() {
        if (this._sticky) {
            return true;
        }
        const hasActions = this.hasActions;
        if ((hasActions && this._severity === Severity.Error) ||
            (!hasActions && this._expanded) ||
            (this._progress && !this._progress.state.done)
        ) {
            return true;
        }
        return false;
    }
    get silent() {
        return !!this._silent;
    }
    get hasActions() {
        if (!this._actions) {
            return false;
        }
        if (!this._actions.primary) {
            return false;
        }
        return this._actions.primary.length > 0;
    }
    get hasProgress() {
        return !!this._progress;
    }
    get progress() {
        if (!this._progress) {
            this._progress = this._register(( (new NotificationViewItemProgress())));
            this._register(this._progress.onDidChange(() => this._onDidChangeContent.fire({ kind: 3  })));
        }
        return this._progress;
    }
    get message() {
        return this._message;
    }
    get source() {
        return typeof this._source === 'string' ? this._source : (this._source ? this._source.label : undefined);
    }
    get sourceId() {
        return (this._source && typeof this._source !== 'string' && 'id' in this._source) ? this._source.id : undefined;
    }
    get actions() {
        return this._actions;
    }
    get visible() {
        return this._visible;
    }
    updateSeverity(severity) {
        if (severity === this._severity) {
            return;
        }
        this._severity = severity;
        this._onDidChangeContent.fire({ kind: 0  });
    }
    updateMessage(input) {
        const message = NotificationViewItem.parseNotificationMessage(input);
        if (!message || message.raw === this._message.raw) {
            return;
        }
        this._message = message;
        this._onDidChangeContent.fire({ kind: 1  });
    }
    updateActions(actions) {
        this.setActions(actions);
        this._onDidChangeContent.fire({ kind: 2  });
    }
    updateVisibility(visible) {
        if (this._visible !== visible) {
            this._visible = visible;
            this._onDidChangeVisibility.fire(visible);
        }
    }
    expand() {
        if (this._expanded || !this.canCollapse) {
            return;
        }
        this._expanded = true;
        this._onDidChangeExpansion.fire();
    }
    collapse(skipEvents) {
        if (!this._expanded || !this.canCollapse) {
            return;
        }
        this._expanded = false;
        if (!skipEvents) {
            this._onDidChangeExpansion.fire();
        }
    }
    toggle() {
        if (this._expanded) {
            this.collapse();
        }
        else {
            this.expand();
        }
    }
    close() {
        this._onDidClose.fire();
        this.dispose();
    }
    equals(other) {
        if (this.hasProgress || other.hasProgress) {
            return false;
        }
        if (typeof this.id === 'string' || typeof other.id === 'string') {
            return this.id === other.id;
        }
        if (typeof this._source === 'object') {
            if (this._source.label !== other.source || this._source.id !== other.sourceId) {
                return false;
            }
        }
        else if (this._source !== other.source) {
            return false;
        }
        if (this._message.raw !== other.message.raw) {
            return false;
        }
        const primaryActions = (this._actions && this._actions.primary) || [];
        const otherPrimaryActions = (other.actions && other.actions.primary) || [];
        return equals(primaryActions, otherPrimaryActions, (action, otherAction) => (action.id + action.label) === (otherAction.id + otherAction.label));
    }
}
NotificationViewItem.MAX_MESSAGE_LENGTH = 1000;
class ChoiceAction extends Action {
    constructor(id, choice) {
        super(id, choice.label, undefined, true, async () => {
            choice.run();
            this._onDidRun.fire();
        });
        this._onDidRun = this._register(( (new Emitter())));
        this.onDidRun = this._onDidRun.event;
        this._keepOpen = !!choice.keepOpen;
        this._menu = !choice.isSecondary && choice.menu ? choice.menu.map((c, index) => ( (new ChoiceAction(`${id}.${index}`, c)))) : undefined;
    }
    get menu() {
        return this._menu;
    }
    get keepOpen() {
        return this._keepOpen;
    }
}
class StatusMessageViewItem {
    static create(notification, options) {
        if (!notification || isCancellationError(notification)) {
            return undefined;
        }
        let message;
        if (notification instanceof Error) {
            message = toErrorMessage(notification, false);
        }
        else if (typeof notification === 'string') {
            message = notification;
        }
        if (!message) {
            return undefined;
        }
        return { message, options };
    }
}
var css$1 = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-toolbar-container .action-item,\n.monaco-workbench > .notifications-center > .notifications-center-header > .notifications-center-header-toolbar .action-item {\n\tmargin-right: 4px;\n}\n\n.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-toolbar-container .action-item:first-child,\n.monaco-workbench > .notifications-center > .notifications-center-header > .notifications-center-header-toolbar .action-item:first-child {\n\tmargin-left: 4px;\n}\n";
n(css$1,{});
function notificationToMetrics(message, source, silent) {
    return {
        id: ( (hash(( (message.toString()))).toString())),
        silent,
        source: source || 'core'
    };
}
let NotificationsTelemetry = class NotificationsTelemetry extends Disposable {
    constructor(telemetryService, notificationService) {
        super();
        this.telemetryService = telemetryService;
        this.notificationService = notificationService;
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.notificationService.onDidAddNotification(notification => {
            const source = notification.source && typeof notification.source !== 'string' ? notification.source.id : notification.source;
            this.telemetryService.publicLog2('notification:show', notificationToMetrics(notification.message, source, !!notification.silent));
        }));
        this._register(this.notificationService.onDidRemoveNotification(notification => {
            const source = notification.source && typeof notification.source !== 'string' ? notification.source.id : notification.source;
            this.telemetryService.publicLog2('notification:close', notificationToMetrics(notification.message, source, !!notification.silent));
        }));
    }
};
NotificationsTelemetry = ( (__decorate([
    ( (__param(0, ITelemetryService))),
    ( (__param(1, INotificationService)))
], NotificationsTelemetry)));
const MultipleEditorGroupsContext = ( (new RawContextKey(
    'multipleEditorGroups',
    false,
     (localize('multipleEditorGroups', "Whether there are multiple editor groups opened"))
)));
MultipleEditorGroupsContext.toNegated();
const NotificationFocusedContext = ( (new RawContextKey(
    'notificationFocus',
    true,
     (localize('notificationFocus', "Whether a notification has keyboard focus"))
)));
const NotificationsCenterVisibleContext = ( (new RawContextKey(
    'notificationCenterVisible',
    false,
     (localize('notificationCenterVisible', "Whether the notifications center is visible"))
)));
const NotificationsToastsVisibleContext = ( (new RawContextKey(
    'notificationToastsVisible',
    false,
     (localize('notificationToastsVisible', "Whether a notification toast is visible"))
)));
let ResourceContextKey = class ResourceContextKey {
    constructor(_contextKeyService, _fileService, _languageService, _modelService) {
        this._contextKeyService = _contextKeyService;
        this._fileService = _fileService;
        this._languageService = _languageService;
        this._modelService = _modelService;
        this._disposables = ( (new DisposableStore()));
        this._schemeKey = ResourceContextKey.Scheme.bindTo(this._contextKeyService);
        this._filenameKey = ResourceContextKey.Filename.bindTo(this._contextKeyService);
        this._dirnameKey = ResourceContextKey.Dirname.bindTo(this._contextKeyService);
        this._pathKey = ResourceContextKey.Path.bindTo(this._contextKeyService);
        this._langIdKey = ResourceContextKey.LangId.bindTo(this._contextKeyService);
        this._resourceKey = ResourceContextKey.Resource.bindTo(this._contextKeyService);
        this._extensionKey = ResourceContextKey.Extension.bindTo(this._contextKeyService);
        this._hasResource = ResourceContextKey.HasResource.bindTo(this._contextKeyService);
        this._isFileSystemResource = ResourceContextKey.IsFileSystemResource.bindTo(this._contextKeyService);
        this._disposables.add(_fileService.onDidChangeFileSystemProviderRegistrations(() => {
            const resource = this.get();
            this._isFileSystemResource.set(Boolean(resource && _fileService.hasProvider(resource)));
        }));
        this._disposables.add(_modelService.onModelAdded(model => {
            if (isEqual(model.uri, this.get())) {
                this._setLangId();
            }
        }));
        this._disposables.add(_modelService.onModelLanguageChanged(e => {
            if (isEqual(e.model.uri, this.get())) {
                this._setLangId();
            }
        }));
    }
    dispose() {
        this._disposables.dispose();
    }
    _setLangId() {
        const value = this.get();
        if (!value) {
            this._langIdKey.set(null);
            return;
        }
        const langId = this._modelService.getModel(value)?.getLanguageId() ?? this._languageService.guessLanguageIdByFilepathOrFirstLine(value);
        this._langIdKey.set(langId);
    }
    set(value) {
        value = value ?? undefined;
        if (isEqual(this._value, value)) {
            return;
        }
        this._value = value;
        this._contextKeyService.bufferChangeEvents(() => {
            this._resourceKey.set(value ? ( (value.toString())) : null);
            this._schemeKey.set(value ? value.scheme : null);
            this._filenameKey.set(value ? basename(value) : null);
            this._dirnameKey.set(value ? dirname(value).fsPath : null);
            this._pathKey.set(value ? value.fsPath : null);
            this._setLangId();
            this._extensionKey.set(value ? extname(value) : null);
            this._hasResource.set(Boolean(value));
            this._isFileSystemResource.set(value ? this._fileService.hasProvider(value) : false);
        });
    }
    reset() {
        this._value = undefined;
        this._contextKeyService.bufferChangeEvents(() => {
            this._resourceKey.reset();
            this._schemeKey.reset();
            this._filenameKey.reset();
            this._dirnameKey.reset();
            this._pathKey.reset();
            this._langIdKey.reset();
            this._extensionKey.reset();
            this._hasResource.reset();
            this._isFileSystemResource.reset();
        });
    }
    get() {
        return this._value;
    }
};
ResourceContextKey.Scheme = ( (new RawContextKey(
    'resourceScheme',
    undefined,
    { type: 'string', description: ( (localize('resourceScheme', "The scheme of the resource"))) }
)));
ResourceContextKey.Filename = ( (new RawContextKey(
    'resourceFilename',
    undefined,
    { type: 'string', description: ( (localize('resourceFilename', "The file name of the resource"))) }
)));
ResourceContextKey.Dirname = ( (new RawContextKey(
    'resourceDirname',
    undefined,
    { type: 'string', description: ( (localize('resourceDirname', "The folder name the resource is contained in"))) }
)));
ResourceContextKey.Path = ( (new RawContextKey(
    'resourcePath',
    undefined,
    { type: 'string', description: ( (localize('resourcePath', "The full path of the resource"))) }
)));
ResourceContextKey.LangId = ( (new RawContextKey(
    'resourceLangId',
    undefined,
    { type: 'string', description: ( (localize('resourceLangId', "The language identifier of the resource"))) }
)));
ResourceContextKey.Resource = ( (new RawContextKey(
    'resource',
    undefined,
    { type: 'URI', description: ( (localize('resource', "The full value of the resource including scheme and path"))) }
)));
ResourceContextKey.Extension = ( (new RawContextKey(
    'resourceExtname',
    undefined,
    { type: 'string', description: ( (localize('resourceExtname', "The extension name of the resource"))) }
)));
ResourceContextKey.HasResource = ( (new RawContextKey(
    'resourceSet',
    undefined,
    { type: 'boolean', description: ( (localize('resourceSet', "Whether a resource is present or not"))) }
)));
ResourceContextKey.IsFileSystemResource = ( (new RawContextKey(
    'isFileSystemResource',
    undefined,
    { type: 'boolean', description: ( (localize(
        'isFileSystemResource',
        "Whether the resource is backed by a file system provider"
    ))) }
)));
ResourceContextKey = ( (__decorate([
    ( (__param(0, IContextKeyService))),
    ( (__param(1, IFileService))),
    ( (__param(2, ILanguageService))),
    ( (__param(3, IModelService)))
], ResourceContextKey)));
const SHOW_NOTIFICATIONS_CENTER = 'notifications.showList';
const HIDE_NOTIFICATIONS_CENTER = 'notifications.hideList';
const HIDE_NOTIFICATION_TOAST = 'notifications.hideToasts';
const FOCUS_NOTIFICATION_TOAST = 'notifications.focusToasts';
const FOCUS_NEXT_NOTIFICATION_TOAST = 'notifications.focusNextToast';
const FOCUS_PREVIOUS_NOTIFICATION_TOAST = 'notifications.focusPreviousToast';
const FOCUS_FIRST_NOTIFICATION_TOAST = 'notifications.focusFirstToast';
const FOCUS_LAST_NOTIFICATION_TOAST = 'notifications.focusLastToast';
const COLLAPSE_NOTIFICATION = 'notification.collapse';
const EXPAND_NOTIFICATION = 'notification.expand';
const TOGGLE_NOTIFICATION = 'notification.toggle';
const CLEAR_NOTIFICATION = 'notification.clear';
const CLEAR_ALL_NOTIFICATIONS = 'notifications.clearAll';
const TOGGLE_DO_NOT_DISTURB_MODE = 'notifications.toggleDoNotDisturbMode';
function registerNotificationCommands(center, toasts, model) {
    function getNotificationFromContext(listService, context) {
        if (isNotificationViewItem(context)) {
            return context;
        }
        const list = listService.lastFocusedList;
        if (list instanceof WorkbenchList) {
            const focusedElement = list.getFocusedElements()[0];
            if (isNotificationViewItem(focusedElement)) {
                return focusedElement;
            }
        }
        return undefined;
    }
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: HIDE_NOTIFICATIONS_CENTER,
        weight: 200  + 50,
        when: NotificationsCenterVisibleContext,
        primary: 9 ,
        handler: accessor => {
            const telemetryService = accessor.get(ITelemetryService);
            for (const notification of model.notifications) {
                if (notification.visible) {
                    telemetryService.publicLog2('notification:hide', notificationToMetrics(notification.message.original, notification.sourceId, notification.silent));
                }
            }
            center.hide();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: CLEAR_NOTIFICATION,
        weight: 200 ,
        when: NotificationFocusedContext,
        primary: 20 ,
        mac: {
            primary: 2048  | 1
        },
        handler: (accessor, args) => {
            const notification = getNotificationFromContext(accessor.get(IListService), args);
            if (notification && !notification.hasProgress) {
                notification.close();
            }
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: EXPAND_NOTIFICATION,
        weight: 200 ,
        when: NotificationFocusedContext,
        primary: 17 ,
        handler: (accessor, args) => {
            const notification = getNotificationFromContext(accessor.get(IListService), args);
            if (notification) {
                notification.expand();
            }
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: COLLAPSE_NOTIFICATION,
        weight: 200 ,
        when: NotificationFocusedContext,
        primary: 15 ,
        handler: (accessor, args) => {
            const notification = getNotificationFromContext(accessor.get(IListService), args);
            if (notification) {
                notification.collapse();
            }
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: TOGGLE_NOTIFICATION,
        weight: 200 ,
        when: NotificationFocusedContext,
        primary: 10 ,
        secondary: [3 ],
        handler: accessor => {
            const notification = getNotificationFromContext(accessor.get(IListService));
            if (notification) {
                notification.toggle();
            }
        }
    });
    KeybindingsRegistry.registerKeybindingRule({
        id: HIDE_NOTIFICATION_TOAST,
        weight: 200  - 50,
        when: NotificationsToastsVisibleContext,
        primary: 9
    });
    KeybindingsRegistry.registerKeybindingRule({
        id: HIDE_NOTIFICATION_TOAST,
        weight: 200  + 100,
        when: ContextKeyExpr.and(NotificationsToastsVisibleContext, NotificationFocusedContext),
        primary: 9
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: FOCUS_NEXT_NOTIFICATION_TOAST,
        weight: 200 ,
        when: ContextKeyExpr.and(NotificationFocusedContext, NotificationsToastsVisibleContext),
        primary: 18 ,
        handler: (accessor) => {
            toasts.focusNext();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: FOCUS_PREVIOUS_NOTIFICATION_TOAST,
        weight: 200 ,
        when: ContextKeyExpr.and(NotificationFocusedContext, NotificationsToastsVisibleContext),
        primary: 16 ,
        handler: (accessor) => {
            toasts.focusPrevious();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: FOCUS_FIRST_NOTIFICATION_TOAST,
        weight: 200 ,
        when: ContextKeyExpr.and(NotificationFocusedContext, NotificationsToastsVisibleContext),
        primary: 11 ,
        secondary: [14 ],
        handler: (accessor) => {
            toasts.focusFirst();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: FOCUS_LAST_NOTIFICATION_TOAST,
        weight: 200 ,
        when: ContextKeyExpr.and(NotificationFocusedContext, NotificationsToastsVisibleContext),
        primary: 12 ,
        secondary: [13 ],
        handler: (accessor) => {
            toasts.focusLast();
        }
    });
    const category = { value: ( (localize('notifications', "Notifications"))), original: 'Notifications' };
    MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command: { id: SHOW_NOTIFICATIONS_CENTER, title: { value: ( (localize('showNotifications', "Show Notifications"))), original: 'Show Notifications' }, category } });
    MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command: { id: HIDE_NOTIFICATIONS_CENTER, title: { value: ( (localize('hideNotifications', "Hide Notifications"))), original: 'Hide Notifications' }, category }, when: NotificationsCenterVisibleContext });
    MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command: { id: CLEAR_ALL_NOTIFICATIONS, title: { value: ( (localize('clearAllNotifications', "Clear All Notifications"))), original: 'Clear All Notifications' }, category } });
    MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command: { id: TOGGLE_DO_NOT_DISTURB_MODE, title: { value: ( (localize('toggleDoNotDisturbMode', "Toggle Do Not Disturb Mode"))), original: 'Toggle Do Not Disturb Mode' }, category } });
    MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command: { id: FOCUS_NOTIFICATION_TOAST, title: { value: ( (localize('focusNotificationToasts', "Focus Notification Toast"))), original: 'Focus Notification Toast' }, category }, when: NotificationsToastsVisibleContext });
}
const clearIcon = registerIcon('notifications-clear', Codicon.close, ( (localize('clearIcon', 'Icon for the clear action in notifications.'))));
const clearAllIcon = registerIcon('notifications-clear-all', Codicon.clearAll, ( (localize('clearAllIcon', 'Icon for the clear all action in notifications.'))));
const hideIcon = registerIcon('notifications-hide', Codicon.chevronDown, ( (localize('hideIcon', 'Icon for the hide action in notifications.'))));
const expandIcon = registerIcon('notifications-expand', Codicon.chevronUp, ( (localize('expandIcon', 'Icon for the expand action in notifications.'))));
const collapseIcon = registerIcon('notifications-collapse', Codicon.chevronDown, ( (localize('collapseIcon', 'Icon for the collapse action in notifications.'))));
const configureIcon = registerIcon('notifications-configure', Codicon.gear, ( (localize('configureIcon', 'Icon for the configure action in notifications.'))));
const doNotDisturbIcon = registerIcon('notifications-do-not-disturb', Codicon.bellSlash, ( (localize('doNotDisturbIcon', 'Icon for the mute all action in notifications.'))));
let ClearNotificationAction = class ClearNotificationAction extends Action {
    constructor(id, label, commandService) {
        super(id, label, ThemeIcon.asClassName(clearIcon));
        this.commandService = commandService;
    }
    async run(notification) {
        this.commandService.executeCommand(CLEAR_NOTIFICATION, notification);
    }
};
ClearNotificationAction.ID = CLEAR_NOTIFICATION;
ClearNotificationAction.LABEL = ( (localize('clearNotification', "Clear Notification")));
ClearNotificationAction = ( (__decorate([
    ( (__param(2, ICommandService)))
], ClearNotificationAction)));
let ClearAllNotificationsAction = class ClearAllNotificationsAction extends Action {
    constructor(id, label, commandService) {
        super(id, label, ThemeIcon.asClassName(clearAllIcon));
        this.commandService = commandService;
    }
    async run() {
        this.commandService.executeCommand(CLEAR_ALL_NOTIFICATIONS);
    }
};
ClearAllNotificationsAction.ID = CLEAR_ALL_NOTIFICATIONS;
ClearAllNotificationsAction.LABEL = ( (localize('clearNotifications', "Clear All Notifications")));
ClearAllNotificationsAction = ( (__decorate([
    ( (__param(2, ICommandService)))
], ClearAllNotificationsAction)));
let ToggleDoNotDisturbAction = class ToggleDoNotDisturbAction extends Action {
    constructor(id, label, commandService) {
        super(id, label, ThemeIcon.asClassName(doNotDisturbIcon));
        this.commandService = commandService;
    }
    async run() {
        this.commandService.executeCommand(TOGGLE_DO_NOT_DISTURB_MODE);
    }
};
ToggleDoNotDisturbAction.ID = TOGGLE_DO_NOT_DISTURB_MODE;
ToggleDoNotDisturbAction.LABEL = ( (localize('toggleDoNotDisturbMode', "Toggle Do Not Disturb Mode")));
ToggleDoNotDisturbAction = ( (__decorate([
    ( (__param(2, ICommandService)))
], ToggleDoNotDisturbAction)));
let HideNotificationsCenterAction = class HideNotificationsCenterAction extends Action {
    constructor(id, label, commandService) {
        super(id, label, ThemeIcon.asClassName(hideIcon));
        this.commandService = commandService;
    }
    async run() {
        this.commandService.executeCommand(HIDE_NOTIFICATIONS_CENTER);
    }
};
HideNotificationsCenterAction.ID = HIDE_NOTIFICATIONS_CENTER;
HideNotificationsCenterAction.LABEL = ( (localize('hideNotificationsCenter', "Hide Notifications")));
HideNotificationsCenterAction = ( (__decorate([
    ( (__param(2, ICommandService)))
], HideNotificationsCenterAction)));
let ExpandNotificationAction = class ExpandNotificationAction extends Action {
    constructor(id, label, commandService) {
        super(id, label, ThemeIcon.asClassName(expandIcon));
        this.commandService = commandService;
    }
    async run(notification) {
        this.commandService.executeCommand(EXPAND_NOTIFICATION, notification);
    }
};
ExpandNotificationAction.ID = EXPAND_NOTIFICATION;
ExpandNotificationAction.LABEL = ( (localize('expandNotification', "Expand Notification")));
ExpandNotificationAction = ( (__decorate([
    ( (__param(2, ICommandService)))
], ExpandNotificationAction)));
let CollapseNotificationAction = class CollapseNotificationAction extends Action {
    constructor(id, label, commandService) {
        super(id, label, ThemeIcon.asClassName(collapseIcon));
        this.commandService = commandService;
    }
    async run(notification) {
        this.commandService.executeCommand(COLLAPSE_NOTIFICATION, notification);
    }
};
CollapseNotificationAction.ID = COLLAPSE_NOTIFICATION;
CollapseNotificationAction.LABEL = ( (localize('collapseNotification', "Collapse Notification")));
CollapseNotificationAction = ( (__decorate([
    ( (__param(2, ICommandService)))
], CollapseNotificationAction)));
class ConfigureNotificationAction extends Action {
    constructor(id, label, configurationActions) {
        super(id, label, ThemeIcon.asClassName(configureIcon));
        this.configurationActions = configurationActions;
    }
}
ConfigureNotificationAction.ID = 'workbench.action.configureNotification';
ConfigureNotificationAction.LABEL = ( (localize('configureNotification', "Configure Notification")));
let CopyNotificationMessageAction = class CopyNotificationMessageAction extends Action {
    constructor(id, label, clipboardService) {
        super(id, label);
        this.clipboardService = clipboardService;
    }
    run(notification) {
        return this.clipboardService.writeText(notification.message.raw);
    }
};
CopyNotificationMessageAction.ID = 'workbench.action.copyNotificationMessage';
CopyNotificationMessageAction.LABEL = ( (localize('copyNotification', "Copy Text")));
CopyNotificationMessageAction = ( (__decorate([
    ( (__param(2, IClipboardService)))
], CopyNotificationMessageAction)));
let NotificationActionRunner = class NotificationActionRunner extends ActionRunner {
    constructor(telemetryService, notificationService) {
        super();
        this.telemetryService = telemetryService;
        this.notificationService = notificationService;
    }
    async runAction(action, context) {
        this.telemetryService.publicLog2('workbenchActionExecuted', { id: action.id, from: 'message' });
        if (isNotificationViewItem(context)) {
            this.telemetryService.publicLog2('notification:actionExecuted', {
                id: ( (hash(( (context.message.original.toString()))).toString())),
                actionLabel: action.label,
                source: context.sourceId || 'core',
                silent: context.silent
            });
        }
        try {
            await super.runAction(action, context);
        }
        catch (error) {
            this.notificationService.error(error);
        }
    }
};
NotificationActionRunner = ( (__decorate([
    ( (__param(0, ITelemetryService))),
    ( (__param(1, INotificationService)))
], NotificationActionRunner)));
class NotificationsListDelegate {
    constructor(container) {
        this.offsetHelper = this.createOffsetHelper(container);
    }
    createOffsetHelper(container) {
        const offsetHelper = document.createElement('div');
        offsetHelper.classList.add('notification-offset-helper');
        container.appendChild(offsetHelper);
        return offsetHelper;
    }
    getHeight(notification) {
        if (!notification.expanded) {
            return NotificationsListDelegate.ROW_HEIGHT;
        }
        let expandedHeight = NotificationsListDelegate.ROW_HEIGHT;
        const preferredMessageHeight = this.computePreferredHeight(notification);
        const messageOverflows = NotificationsListDelegate.LINE_HEIGHT < preferredMessageHeight;
        if (messageOverflows) {
            const overflow = preferredMessageHeight - NotificationsListDelegate.LINE_HEIGHT;
            expandedHeight += overflow;
        }
        if (notification.source || isNonEmptyArray(notification.actions && notification.actions.primary)) {
            expandedHeight += NotificationsListDelegate.ROW_HEIGHT;
        }
        if (expandedHeight === NotificationsListDelegate.ROW_HEIGHT) {
            notification.collapse(true );
        }
        return expandedHeight;
    }
    computePreferredHeight(notification) {
        let actions = 1;
        if (notification.canCollapse) {
            actions++;
        }
        if (isNonEmptyArray(notification.actions && notification.actions.secondary)) {
            actions++;
        }
        this.offsetHelper.style.width = `${450  - ((10  + 26  + (actions * (24 + 8))  - 4) )}px`;
        const renderedMessage = NotificationMessageRenderer.render(notification.message);
        this.offsetHelper.appendChild(renderedMessage);
        const preferredHeight = Math.max(this.offsetHelper.offsetHeight, this.offsetHelper.scrollHeight);
        clearNode(this.offsetHelper);
        return preferredHeight;
    }
    getTemplateId(element) {
        if (element instanceof NotificationViewItem) {
            return NotificationRenderer.TEMPLATE_ID;
        }
        throw new Error('unknown element type: ' + element);
    }
}
NotificationsListDelegate.ROW_HEIGHT = 42;
NotificationsListDelegate.LINE_HEIGHT = 22;
class NotificationMessageRenderer {
    static render(message, actionHandler) {
        const messageContainer = document.createElement('span');
        for (const node of message.linkedText.nodes) {
            if (typeof node === 'string') {
                messageContainer.appendChild(document.createTextNode(node));
            }
            else {
                let title = node.title;
                if (!title && node.href.startsWith('command:')) {
                    title = ( (localize(
                        'executeCommand',
                        "Click to execute command '{0}'",
                        node.href.substr('command:'.length)
                    )));
                }
                else if (!title) {
                    title = node.href;
                }
                const anchor = $('a', { href: node.href, title: title, }, node.label);
                if (actionHandler) {
                    const onPointer = (e) => {
                        EventHelper.stop(e, true);
                        actionHandler.callback(node.href);
                    };
                    const onClick = actionHandler.toDispose.add(( (new DomEmitter(anchor, 'click')))).event;
                    actionHandler.toDispose.add(Gesture.addTarget(anchor));
                    const onTap = actionHandler.toDispose.add(( (new DomEmitter(anchor, EventType$1.Tap)))).event;
                    Event.any(onClick, onTap)(onPointer, null, actionHandler.toDispose);
                }
                messageContainer.appendChild(anchor);
            }
        }
        return messageContainer;
    }
}
let NotificationRenderer = class NotificationRenderer {
    constructor(actionRunner, themeService, contextMenuService, instantiationService) {
        this.actionRunner = actionRunner;
        this.themeService = themeService;
        this.contextMenuService = contextMenuService;
        this.instantiationService = instantiationService;
    }
    get templateId() {
        return NotificationRenderer.TEMPLATE_ID;
    }
    renderTemplate(container) {
        const data = Object.create(null);
        data.toDispose = ( (new DisposableStore()));
        data.container = document.createElement('div');
        data.container.classList.add('notification-list-item');
        data.mainRow = document.createElement('div');
        data.mainRow.classList.add('notification-list-item-main-row');
        data.icon = document.createElement('div');
        data.icon.classList.add('notification-list-item-icon', 'codicon');
        data.message = document.createElement('div');
        data.message.classList.add('notification-list-item-message');
        const toolbarContainer = document.createElement('div');
        toolbarContainer.classList.add('notification-list-item-toolbar-container');
        data.toolbar = ( (new ActionBar(toolbarContainer, {
            ariaLabel: ( (localize('notificationActions', "Notification Actions"))),
            actionViewItemProvider: action => {
                if (action && action instanceof ConfigureNotificationAction) {
                    const item = ( (new DropdownMenuActionViewItem(
                        action,
                        action.configurationActions,
                        this.contextMenuService,
                        { actionRunner: this.actionRunner, classNames: action.class }
                    )));
                    data.toDispose.add(item);
                    return item;
                }
                return undefined;
            },
            actionRunner: this.actionRunner
        })));
        data.toDispose.add(data.toolbar);
        data.detailsRow = document.createElement('div');
        data.detailsRow.classList.add('notification-list-item-details-row');
        data.source = document.createElement('div');
        data.source.classList.add('notification-list-item-source');
        data.buttonsContainer = document.createElement('div');
        data.buttonsContainer.classList.add('notification-list-item-buttons-container');
        container.appendChild(data.container);
        data.container.appendChild(data.detailsRow);
        data.detailsRow.appendChild(data.source);
        data.detailsRow.appendChild(data.buttonsContainer);
        data.container.appendChild(data.mainRow);
        data.mainRow.appendChild(data.icon);
        data.mainRow.appendChild(data.message);
        data.mainRow.appendChild(toolbarContainer);
        data.progress = ( (new ProgressBar(container)));
        data.toDispose.add(attachProgressBarStyler(data.progress, this.themeService));
        data.toDispose.add(data.progress);
        data.renderer = this.instantiationService.createInstance(NotificationTemplateRenderer, data, this.actionRunner);
        data.toDispose.add(data.renderer);
        return data;
    }
    renderElement(notification, index, data) {
        data.renderer.setInput(notification);
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
};
NotificationRenderer.TEMPLATE_ID = 'notification';
NotificationRenderer = ( (__decorate([
    ( (__param(1, IThemeService))),
    ( (__param(2, IContextMenuService))),
    ( (__param(3, IInstantiationService)))
], NotificationRenderer)));
let NotificationTemplateRenderer = class NotificationTemplateRenderer extends Disposable {
    constructor(template, actionRunner, openerService, instantiationService, themeService, keybindingService, contextMenuService) {
        super();
        this.template = template;
        this.actionRunner = actionRunner;
        this.openerService = openerService;
        this.instantiationService = instantiationService;
        this.themeService = themeService;
        this.keybindingService = keybindingService;
        this.contextMenuService = contextMenuService;
        this.inputDisposables = this._register(( (new DisposableStore())));
        if (!NotificationTemplateRenderer.closeNotificationAction) {
            NotificationTemplateRenderer.closeNotificationAction = instantiationService.createInstance(ClearNotificationAction, ClearNotificationAction.ID, ClearNotificationAction.LABEL);
            NotificationTemplateRenderer.expandNotificationAction = instantiationService.createInstance(ExpandNotificationAction, ExpandNotificationAction.ID, ExpandNotificationAction.LABEL);
            NotificationTemplateRenderer.collapseNotificationAction = instantiationService.createInstance(CollapseNotificationAction, CollapseNotificationAction.ID, CollapseNotificationAction.LABEL);
        }
    }
    setInput(notification) {
        this.inputDisposables.clear();
        this.render(notification);
    }
    render(notification) {
        this.template.container.classList.toggle('expanded', notification.expanded);
        this.inputDisposables.add(addDisposableListener(this.template.container, EventType.MOUSE_UP, e => {
            if (e.button === 1 ) {
                EventHelper.stop(e, true);
            }
        }));
        this.inputDisposables.add(addDisposableListener(this.template.container, EventType.AUXCLICK, e => {
            if (!notification.hasProgress && e.button === 1 ) {
                EventHelper.stop(e, true);
                notification.close();
            }
        }));
        this.renderSeverity(notification);
        const messageOverflows = this.renderMessage(notification);
        this.renderSecondaryActions(notification, messageOverflows);
        this.renderSource(notification);
        this.renderButtons(notification);
        this.renderProgress(notification);
        this.inputDisposables.add(notification.onDidChangeContent(event => {
            switch (event.kind) {
                case 0 :
                    this.renderSeverity(notification);
                    break;
                case 3 :
                    this.renderProgress(notification);
                    break;
                case 1 :
                    this.renderMessage(notification);
                    break;
            }
        }));
    }
    renderSeverity(notification) {
        NotificationTemplateRenderer.SEVERITIES.forEach(severity => {
            if (notification.severity !== severity) {
                this.template.icon.classList.remove(...this.toSeverityIcon(severity).classNamesArray);
            }
        });
        this.template.icon.classList.add(...this.toSeverityIcon(notification.severity).classNamesArray);
    }
    renderMessage(notification) {
        clearNode(this.template.message);
        this.template.message.appendChild(NotificationMessageRenderer.render(notification.message, {
            callback: link => this.openerService.open(( (URI.parse(link))), { allowCommands: true }),
            toDispose: this.inputDisposables
        }));
        const messageOverflows = notification.canCollapse && !notification.expanded && this.template.message.scrollWidth > this.template.message.clientWidth;
        if (messageOverflows) {
            this.template.message.title = this.template.message.textContent + '';
        }
        else {
            this.template.message.removeAttribute('title');
        }
        const links = this.template.message.querySelectorAll('a');
        for (let i = 0; i < links.length; i++) {
            links.item(i).tabIndex = -1;
        }
        return messageOverflows;
    }
    renderSecondaryActions(notification, messageOverflows) {
        const actions = [];
        const secondaryActions = notification.actions ? notification.actions.secondary : undefined;
        if (isNonEmptyArray(secondaryActions)) {
            const configureNotificationAction = this.instantiationService.createInstance(ConfigureNotificationAction, ConfigureNotificationAction.ID, ConfigureNotificationAction.LABEL, secondaryActions);
            actions.push(configureNotificationAction);
            this.inputDisposables.add(configureNotificationAction);
        }
        let showExpandCollapseAction = false;
        if (notification.canCollapse) {
            if (notification.expanded) {
                showExpandCollapseAction = true;
            }
            else if (notification.source) {
                showExpandCollapseAction = true;
            }
            else if (messageOverflows) {
                showExpandCollapseAction = true;
            }
        }
        if (showExpandCollapseAction) {
            actions.push(notification.expanded ? NotificationTemplateRenderer.collapseNotificationAction : NotificationTemplateRenderer.expandNotificationAction);
        }
        if (!notification.hasProgress) {
            actions.push(NotificationTemplateRenderer.closeNotificationAction);
        }
        this.template.toolbar.clear();
        this.template.toolbar.context = notification;
        actions.forEach(action => this.template.toolbar.push(action, { icon: true, label: false, keybinding: this.getKeybindingLabel(action) }));
    }
    renderSource(notification) {
        if (notification.expanded && notification.source) {
            this.template.source.textContent = ( (localize('notificationSource', "Source: {0}", notification.source)));
            this.template.source.title = notification.source;
        }
        else {
            this.template.source.textContent = '';
            this.template.source.removeAttribute('title');
        }
    }
    renderButtons(notification) {
        clearNode(this.template.buttonsContainer);
        const primaryActions = notification.actions ? notification.actions.primary : undefined;
        if (notification.expanded && isNonEmptyArray(primaryActions)) {
            const that = this;
            const actionRunner = new (class extends ActionRunner {
                async runAction(action) {
                    that.actionRunner.run(action, notification);
                    if (!(action instanceof ChoiceAction) || !action.keepOpen) {
                        notification.close();
                    }
                }
            })();
            const buttonToolbar = this.inputDisposables.add(( (new ButtonBar(this.template.buttonsContainer))));
            for (let i = 0; i < primaryActions.length; i++) {
                const action = primaryActions[i];
                const options = {
                    title: true,
                    secondary: i > 0
                };
                const dropdownActions = action instanceof ChoiceAction ? action.menu : undefined;
                const button = this.inputDisposables.add(dropdownActions ?
                    buttonToolbar.addButtonWithDropdown({
                        ...options,
                        contextMenuProvider: this.contextMenuService,
                        actions: dropdownActions,
                        actionRunner
                    }) :
                    buttonToolbar.addButton(options));
                button.label = action.label;
                this.inputDisposables.add(button.onDidClick(e => {
                    if (e) {
                        EventHelper.stop(e, true);
                    }
                    actionRunner.run(action);
                }));
                this.inputDisposables.add(attachButtonStyler(button, this.themeService));
            }
        }
    }
    renderProgress(notification) {
        if (!notification.hasProgress) {
            this.template.progress.stop().hide();
            return;
        }
        const state = notification.progress.state;
        if (state.infinite) {
            this.template.progress.infinite().show();
        }
        else if (typeof state.total === 'number' || typeof state.worked === 'number') {
            if (typeof state.total === 'number' && !this.template.progress.hasTotal()) {
                this.template.progress.total(state.total);
            }
            if (typeof state.worked === 'number') {
                this.template.progress.setWorked(state.worked).show();
            }
        }
        else {
            this.template.progress.done().hide();
        }
    }
    toSeverityIcon(severity) {
        switch (severity) {
            case Severity.Warning:
                return Codicon.warning;
            case Severity.Error:
                return Codicon.error;
        }
        return Codicon.info;
    }
    getKeybindingLabel(action) {
        const keybinding = this.keybindingService.lookupKeybinding(action.id);
        return keybinding ? keybinding.getLabel() : null;
    }
};
NotificationTemplateRenderer.SEVERITIES = [Severity.Info, Severity.Warning, Severity.Error];
NotificationTemplateRenderer = ( (__decorate([
    ( (__param(2, IOpenerService))),
    ( (__param(3, IInstantiationService))),
    ( (__param(4, IThemeService))),
    ( (__param(5, IKeybindingService))),
    ( (__param(6, IContextMenuService)))
], NotificationTemplateRenderer)));
let NotificationsList = class NotificationsList extends Themable {
    constructor(container, options, instantiationService, themeService, contextMenuService) {
        super(themeService);
        this.container = container;
        this.options = options;
        this.instantiationService = instantiationService;
        this.contextMenuService = contextMenuService;
        this.viewModel = [];
    }
    show(focus) {
        if (this.isVisible) {
            if (focus) {
                const list = assertIsDefined(this.list);
                list.domFocus();
            }
            return;
        }
        if (!this.list) {
            this.createNotificationsList();
        }
        this.isVisible = true;
        if (focus) {
            const list = assertIsDefined(this.list);
            list.domFocus();
        }
    }
    createNotificationsList() {
        this.listContainer = document.createElement('div');
        this.listContainer.classList.add('notifications-list-container');
        const actionRunner = this._register(this.instantiationService.createInstance(NotificationActionRunner));
        const renderer = this.instantiationService.createInstance(NotificationRenderer, actionRunner);
        const listDelegate = this.listDelegate = ( (new NotificationsListDelegate(this.listContainer)));
        const options = this.options;
        const list = this.list = this._register(this.instantiationService.createInstance(WorkbenchList, 'NotificationsList', this.listContainer, listDelegate, [renderer], {
            ...options,
            setRowLineHeight: false,
            horizontalScrolling: false,
            overrideStyles: {
                listBackground: NOTIFICATIONS_BACKGROUND
            },
            accessibilityProvider: {
                getAriaLabel(element) {
                    if (!element.source) {
                        return (
                             (localize('notificationAriaLabel', "{0}, notification", element.message.raw))
                        );
                    }
                    return (
                         (localize(
                            'notificationWithSourceAriaLabel',
                            "{0}, source: {1}, notification",
                            element.message.raw,
                            element.source
                        ))
                    );
                },
                getWidgetAriaLabel() {
                    return options.widgetAriaLabel ?? ( (localize('notificationsList', "Notifications List")));
                },
                getRole() {
                    return 'dialog';
                }
            }
        }));
        const copyAction = this._register(this.instantiationService.createInstance(CopyNotificationMessageAction, CopyNotificationMessageAction.ID, CopyNotificationMessageAction.LABEL));
        this._register((list.onContextMenu(e => {
            if (!e.element) {
                return;
            }
            this.contextMenuService.showContextMenu({
                getAnchor: () => e.anchor,
                getActions: () => [copyAction],
                getActionsContext: () => e.element,
                actionRunner
            });
        })));
        this._register((list.onMouseDblClick(event => event.element.toggle())));
        const listFocusTracker = this._register(trackFocus(list.getHTMLElement()));
        this._register(listFocusTracker.onDidBlur(() => {
            if (document.hasFocus()) {
                list.setFocus([]);
            }
        }));
        NotificationFocusedContext.bindTo(list.contextKeyService);
        this._register(list.onDidChangeSelection(e => {
            if (e.indexes.length > 0) {
                list.setSelection([]);
            }
        }));
        this.container.appendChild(this.listContainer);
        this.updateStyles();
    }
    updateNotificationsList(start, deleteCount, items = []) {
        const [list, listContainer] = assertAllDefined(this.list, this.listContainer);
        const listHasDOMFocus = isAncestor(document.activeElement, listContainer);
        const focusedIndex = list.getFocus()[0];
        const focusedItem = this.viewModel[focusedIndex];
        let focusRelativeTop = null;
        if (typeof focusedIndex === 'number') {
            focusRelativeTop = list.getRelativeTop(focusedIndex);
        }
        this.viewModel.splice(start, deleteCount, ...items);
        list.splice(start, deleteCount, items);
        list.layout();
        if (this.viewModel.length === 0) {
            this.hide();
        }
        else if (typeof focusedIndex === 'number') {
            let indexToFocus = 0;
            if (focusedItem) {
                let indexToFocusCandidate = this.viewModel.indexOf(focusedItem);
                if (indexToFocusCandidate === -1) {
                    indexToFocusCandidate = focusedIndex - 1;
                }
                if (indexToFocusCandidate < this.viewModel.length && indexToFocusCandidate >= 0) {
                    indexToFocus = indexToFocusCandidate;
                }
            }
            if (typeof focusRelativeTop === 'number') {
                list.reveal(indexToFocus, focusRelativeTop);
            }
            list.setFocus([indexToFocus]);
        }
        if (this.isVisible && listHasDOMFocus) {
            list.domFocus();
        }
    }
    updateNotificationHeight(item) {
        const index = this.viewModel.indexOf(item);
        if (index === -1) {
            return;
        }
        const [list, listDelegate] = assertAllDefined(this.list, this.listDelegate);
        list.updateElementHeight(index, listDelegate.getHeight(item));
        list.layout();
    }
    hide() {
        if (!this.isVisible || !this.list) {
            return;
        }
        this.isVisible = false;
        this.list.splice(0, this.viewModel.length);
        this.viewModel = [];
    }
    focusFirst() {
        if (!this.isVisible || !this.list) {
            return;
        }
        this.list.focusFirst();
        this.list.domFocus();
    }
    hasFocus() {
        if (!this.isVisible || !this.listContainer) {
            return false;
        }
        return isAncestor(document.activeElement, this.listContainer);
    }
    updateStyles() {
        if (this.listContainer) {
            const foreground = this.getColor(NOTIFICATIONS_FOREGROUND);
            this.listContainer.style.color = foreground ? foreground : '';
            const background = this.getColor(NOTIFICATIONS_BACKGROUND);
            this.listContainer.style.background = background ? background : '';
            const outlineColor = this.getColor(contrastBorder);
            this.listContainer.style.outlineColor = outlineColor ? outlineColor : '';
        }
    }
    layout(width, maxHeight) {
        if (this.listContainer && this.list) {
            this.listContainer.style.width = `${width}px`;
            if (typeof maxHeight === 'number') {
                this.list.getHTMLElement().style.maxHeight = `${maxHeight}px`;
            }
            this.list.layout();
        }
    }
    dispose() {
        this.hide();
        super.dispose();
    }
};
NotificationsList = ( (__decorate([
    ( (__param(2, IInstantiationService))),
    ( (__param(3, IThemeService))),
    ( (__param(4, IContextMenuService)))
], NotificationsList)));
registerThemingParticipant((theme, collector) => {
    const linkColor = theme.getColor(NOTIFICATIONS_LINKS);
    if (linkColor) {
        collector.addRule(`.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-message a { color: ${linkColor}; }`);
    }
    const focusOutline = theme.getColor(focusBorder);
    if (focusOutline) {
        collector.addRule(`
		.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-message a:focus {
			outline-color: ${focusOutline};
		}`);
    }
    const notificationErrorIconForegroundColor = theme.getColor(NOTIFICATIONS_ERROR_ICON_FOREGROUND);
    if (notificationErrorIconForegroundColor) {
        collector.addRule(`
		.monaco-workbench .notifications-center ${Codicon.error.cssSelector},
		.monaco-workbench .notifications-toasts ${Codicon.error.cssSelector} {
			color: ${notificationErrorIconForegroundColor};
		}`);
    }
    const notificationWarningIconForegroundColor = theme.getColor(NOTIFICATIONS_WARNING_ICON_FOREGROUND);
    if (notificationWarningIconForegroundColor) {
        collector.addRule(`
		.monaco-workbench .notifications-center ${Codicon.warning.cssSelector},
		.monaco-workbench .notifications-toasts ${Codicon.warning.cssSelector} {
			color: ${notificationWarningIconForegroundColor};
		}`);
    }
    const notificationInfoIconForegroundColor = theme.getColor(NOTIFICATIONS_INFO_ICON_FOREGROUND);
    if (notificationInfoIconForegroundColor) {
        collector.addRule(`
		.monaco-workbench .notifications-center ${Codicon.info.cssSelector},
		.monaco-workbench .notifications-toasts ${Codicon.info.cssSelector} {
			color: ${notificationInfoIconForegroundColor};
		}`);
    }
});
var ToastVisibility;
( ((function(ToastVisibility) {
    ToastVisibility[ToastVisibility["HIDDEN_OR_VISIBLE"] = 0] = "HIDDEN_OR_VISIBLE";
    ToastVisibility[ToastVisibility["HIDDEN"] = 1] = "HIDDEN";
    ToastVisibility[ToastVisibility["VISIBLE"] = 2] = "VISIBLE";
})(ToastVisibility || (ToastVisibility = {}))));
let NotificationsToasts = class NotificationsToasts extends Themable {
    constructor(container, model, instantiationService, layoutService, themeService, editorGroupService, contextKeyService, lifecycleService, hostService) {
        super(themeService);
        this.container = container;
        this.model = model;
        this.instantiationService = instantiationService;
        this.layoutService = layoutService;
        this.editorGroupService = editorGroupService;
        this.contextKeyService = contextKeyService;
        this.lifecycleService = lifecycleService;
        this.hostService = hostService;
        this._onDidChangeVisibility = this._register(( (new Emitter())));
        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
        this._isVisible = false;
        this.mapNotificationToToast = ( (new Map()));
        this.mapNotificationToDisposable = ( (new Map()));
        this.notificationsToastsVisibleContextKey = NotificationsToastsVisibleContext.bindTo(this.contextKeyService);
        this.addedToastsIntervalCounter = ( (new IntervalCounter(NotificationsToasts.SPAM_PROTECTION.interval)));
        this.registerListeners();
    }
    get isVisible() { return !!this._isVisible; }
    registerListeners() {
        this._register(this.layoutService.onDidLayout(dimension => this.layout(Dimension.lift(dimension))));
        this.lifecycleService.when(3 ).then(() => {
            this.model.notifications.forEach(notification => this.addToast(notification));
            this._register(this.model.onDidChangeNotification(e => this.onDidChangeNotification(e)));
        });
        this._register(this.model.onDidChangeFilter(filter => {
            if (filter === NotificationsFilter.SILENT || filter === NotificationsFilter.ERROR) {
                this.hide();
            }
        }));
    }
    onDidChangeNotification(e) {
        switch (e.kind) {
            case 0 :
                return this.addToast(e.item);
            case 3 :
                return this.removeToast(e.item);
        }
    }
    addToast(item) {
        if (this.isNotificationsCenterVisible) {
            return;
        }
        if (item.silent) {
            return;
        }
        if (this.addedToastsIntervalCounter.increment() > NotificationsToasts.SPAM_PROTECTION.limit) {
            return;
        }
        const itemDisposables = ( (new DisposableStore()));
        this.mapNotificationToDisposable.set(item, itemDisposables);
        itemDisposables.add(scheduleAtNextAnimationFrame(() => this.doAddToast(item, itemDisposables)));
    }
    doAddToast(item, itemDisposables) {
        let notificationsToastsContainer = this.notificationsToastsContainer;
        if (!notificationsToastsContainer) {
            notificationsToastsContainer = this.notificationsToastsContainer = document.createElement('div');
            notificationsToastsContainer.classList.add('notifications-toasts');
            this.container.appendChild(notificationsToastsContainer);
        }
        notificationsToastsContainer.classList.add('visible');
        const notificationToastContainer = document.createElement('div');
        notificationToastContainer.classList.add('notification-toast-container');
        const firstToast = notificationsToastsContainer.firstChild;
        if (firstToast) {
            notificationsToastsContainer.insertBefore(notificationToastContainer, firstToast);
        }
        else {
            notificationsToastsContainer.appendChild(notificationToastContainer);
        }
        const notificationToast = document.createElement('div');
        notificationToast.classList.add('notification-toast');
        notificationToastContainer.appendChild(notificationToast);
        const notificationList = this.instantiationService.createInstance(NotificationsList, notificationToast, {
            verticalScrollMode: 2 ,
            widgetAriaLabel: (() => {
                if (!item.source) {
                    return (
                         (localize('notificationAriaLabel', "{0}, notification", item.message.raw))
                    );
                }
                return (
                     (localize(
                        'notificationWithSourceAriaLabel',
                        "{0}, source: {1}, notification",
                        item.message.raw,
                        item.source
                    ))
                );
            })()
        });
        itemDisposables.add(notificationList);
        const toast = { item, list: notificationList, container: notificationToastContainer, toast: notificationToast };
        this.mapNotificationToToast.set(item, toast);
        itemDisposables.add(toDisposable(() => this.updateToastVisibility(toast, false)));
        notificationList.show();
        const maxDimensions = this.computeMaxDimensions();
        this.layoutLists(maxDimensions.width);
        notificationList.updateNotificationsList(0, 0, [item]);
        this.layoutContainer(maxDimensions.height);
        itemDisposables.add(item.onDidChangeExpansion(() => {
            notificationList.updateNotificationsList(0, 1, [item]);
        }));
        itemDisposables.add(item.onDidChangeContent(e => {
            switch (e.kind) {
                case 2 :
                    notificationList.updateNotificationsList(0, 1, [item]);
                    break;
                case 1 :
                    if (item.expanded) {
                        notificationList.updateNotificationHeight(item);
                    }
                    break;
            }
        }));
        Event.once(item.onDidClose)(() => {
            this.removeToast(item);
        });
        this.purgeNotification(item, notificationToastContainer, notificationList, itemDisposables);
        this.updateStyles();
        this.notificationsToastsVisibleContextKey.set(true);
        notificationToast.classList.add('notification-fade-in');
        itemDisposables.add(addDisposableListener(notificationToast, 'transitionend', () => {
            notificationToast.classList.remove('notification-fade-in');
            notificationToast.classList.add('notification-fade-in-done');
        }));
        item.updateVisibility(true);
        if (!this._isVisible) {
            this._isVisible = true;
            this._onDidChangeVisibility.fire();
        }
    }
    purgeNotification(item, notificationToastContainer, notificationList, disposables) {
        let isMouseOverToast = false;
        disposables.add(addDisposableListener(notificationToastContainer, EventType.MOUSE_OVER, () => isMouseOverToast = true));
        disposables.add(addDisposableListener(notificationToastContainer, EventType.MOUSE_OUT, () => isMouseOverToast = false));
        let purgeTimeoutHandle;
        let listener;
        const hideAfterTimeout = () => {
            purgeTimeoutHandle = setTimeout(() => {
                if (!this.hostService.hasFocus) {
                    if (!listener) {
                        listener = this.hostService.onDidChangeFocus(focus => {
                            if (focus) {
                                hideAfterTimeout();
                            }
                        });
                        disposables.add(listener);
                    }
                }
                else if (item.sticky ||
                    notificationList.hasFocus() ||
                    isMouseOverToast
                ) {
                    hideAfterTimeout();
                }
                else {
                    this.removeToast(item);
                }
            }, NotificationsToasts.PURGE_TIMEOUT[item.severity]);
        };
        hideAfterTimeout();
        disposables.add(toDisposable(() => clearTimeout(purgeTimeoutHandle)));
    }
    removeToast(item) {
        let focusEditor = false;
        const notificationToast = this.mapNotificationToToast.get(item);
        if (notificationToast) {
            const toastHasDOMFocus = isAncestor(document.activeElement, notificationToast.container);
            if (toastHasDOMFocus) {
                focusEditor = !(this.focusNext() || this.focusPrevious());
            }
            this.mapNotificationToToast.delete(item);
        }
        const notificationDisposables = this.mapNotificationToDisposable.get(item);
        if (notificationDisposables) {
            dispose(notificationDisposables);
            this.mapNotificationToDisposable.delete(item);
        }
        if (this.mapNotificationToToast.size > 0) {
            this.layout(this.workbenchDimensions);
        }
        else {
            this.doHide();
            if (focusEditor) {
                this.editorGroupService.activeGroup.focus();
            }
        }
    }
    removeToasts() {
        this.mapNotificationToToast.clear();
        this.mapNotificationToDisposable.forEach(disposable => dispose(disposable));
        this.mapNotificationToDisposable.clear();
        this.doHide();
    }
    doHide() {
        this.notificationsToastsContainer?.classList.remove('visible');
        this.notificationsToastsVisibleContextKey.set(false);
        if (this._isVisible) {
            this._isVisible = false;
            this._onDidChangeVisibility.fire();
        }
    }
    hide() {
        const focusEditor = this.notificationsToastsContainer ? isAncestor(document.activeElement, this.notificationsToastsContainer) : false;
        this.removeToasts();
        if (focusEditor) {
            this.editorGroupService.activeGroup.focus();
        }
    }
    focus() {
        const toasts = this.getToasts(ToastVisibility.VISIBLE);
        if (toasts.length > 0) {
            toasts[0].list.focusFirst();
            return true;
        }
        return false;
    }
    focusNext() {
        const toasts = this.getToasts(ToastVisibility.VISIBLE);
        for (let i = 0; i < toasts.length; i++) {
            const toast = toasts[i];
            if (toast.list.hasFocus()) {
                const nextToast = toasts[i + 1];
                if (nextToast) {
                    nextToast.list.focusFirst();
                    return true;
                }
                break;
            }
        }
        return false;
    }
    focusPrevious() {
        const toasts = this.getToasts(ToastVisibility.VISIBLE);
        for (let i = 0; i < toasts.length; i++) {
            const toast = toasts[i];
            if (toast.list.hasFocus()) {
                const previousToast = toasts[i - 1];
                if (previousToast) {
                    previousToast.list.focusFirst();
                    return true;
                }
                break;
            }
        }
        return false;
    }
    focusFirst() {
        const toast = this.getToasts(ToastVisibility.VISIBLE)[0];
        if (toast) {
            toast.list.focusFirst();
            return true;
        }
        return false;
    }
    focusLast() {
        const toasts = this.getToasts(ToastVisibility.VISIBLE);
        if (toasts.length > 0) {
            toasts[toasts.length - 1].list.focusFirst();
            return true;
        }
        return false;
    }
    update(isCenterVisible) {
        if (this.isNotificationsCenterVisible !== isCenterVisible) {
            this.isNotificationsCenterVisible = isCenterVisible;
            if (this.isNotificationsCenterVisible) {
                this.removeToasts();
            }
        }
    }
    updateStyles() {
        this.mapNotificationToToast.forEach(({ toast }) => {
            const backgroundColor = this.getColor(NOTIFICATIONS_BACKGROUND);
            toast.style.background = backgroundColor ? backgroundColor : '';
            const widgetShadowColor = this.getColor(widgetShadow);
            toast.style.boxShadow = widgetShadowColor ? `0 0 8px 2px ${widgetShadowColor}` : '';
            const borderColor = this.getColor(NOTIFICATIONS_TOAST_BORDER);
            toast.style.border = borderColor ? `1px solid ${borderColor}` : '';
        });
    }
    getToasts(state) {
        const notificationToasts = [];
        this.mapNotificationToToast.forEach(toast => {
            switch (state) {
                case ToastVisibility.HIDDEN_OR_VISIBLE:
                    notificationToasts.push(toast);
                    break;
                case ToastVisibility.HIDDEN:
                    if (!this.isToastInDOM(toast)) {
                        notificationToasts.push(toast);
                    }
                    break;
                case ToastVisibility.VISIBLE:
                    if (this.isToastInDOM(toast)) {
                        notificationToasts.push(toast);
                    }
                    break;
            }
        });
        return notificationToasts.reverse();
    }
    layout(dimension) {
        this.workbenchDimensions = dimension;
        const maxDimensions = this.computeMaxDimensions();
        if (maxDimensions.height) {
            this.layoutContainer(maxDimensions.height);
        }
        this.layoutLists(maxDimensions.width);
    }
    computeMaxDimensions() {
        const maxWidth = NotificationsToasts.MAX_WIDTH;
        let availableWidth = maxWidth;
        let availableHeight;
        if (this.workbenchDimensions) {
            availableWidth = this.workbenchDimensions.width;
            availableWidth -= (2 * 8);
            availableHeight = this.workbenchDimensions.height;
            if (this.layoutService.isVisible("workbench.parts.statusbar" )) {
                availableHeight -= 22;
            }
            if (this.layoutService.isVisible("workbench.parts.titlebar" )) {
                availableHeight -= 22;
            }
            availableHeight -= (2 * 12);
        }
        availableHeight = typeof availableHeight === 'number'
            ? Math.round(availableHeight * 0.618)
            : 0;
        return (
             (new Dimension(Math.min(maxWidth, availableWidth), availableHeight))
        );
    }
    layoutLists(width) {
        this.mapNotificationToToast.forEach(({ list }) => list.layout(width));
    }
    layoutContainer(heightToGive) {
        let visibleToasts = 0;
        for (const toast of this.getToasts(ToastVisibility.HIDDEN_OR_VISIBLE)) {
            toast.container.style.opacity = '0';
            this.updateToastVisibility(toast, true);
            heightToGive -= toast.container.offsetHeight;
            let makeVisible = false;
            if (visibleToasts === NotificationsToasts.MAX_NOTIFICATIONS) {
                makeVisible = false;
            }
            else if (heightToGive >= 0) {
                makeVisible = true;
            }
            this.updateToastVisibility(toast, makeVisible);
            toast.container.style.opacity = '';
            if (makeVisible) {
                visibleToasts++;
            }
        }
    }
    updateToastVisibility(toast, visible) {
        if (this.isToastInDOM(toast) === visible) {
            return;
        }
        const notificationsToastsContainer = assertIsDefined(this.notificationsToastsContainer);
        if (visible) {
            notificationsToastsContainer.appendChild(toast.container);
        }
        else {
            notificationsToastsContainer.removeChild(toast.container);
        }
        toast.item.updateVisibility(visible);
    }
    isToastInDOM(toast) {
        return !!toast.container.parentElement;
    }
};
NotificationsToasts.MAX_WIDTH = 450;
NotificationsToasts.MAX_NOTIFICATIONS = 3;
NotificationsToasts.PURGE_TIMEOUT = {
    [Severity.Info]: 15000,
    [Severity.Warning]: 18000,
    [Severity.Error]: 20000
};
NotificationsToasts.SPAM_PROTECTION = {
    interval: 800,
    limit: NotificationsToasts.MAX_NOTIFICATIONS
};
NotificationsToasts = ( (__decorate([
    ( (__param(2, IInstantiationService))),
    ( (__param(3, IWorkbenchLayoutService))),
    ( (__param(4, IThemeService))),
    ( (__param(5, IEditorGroupsService))),
    ( (__param(6, IContextKeyService))),
    ( (__param(7, ILifecycleService))),
    ( (__param(8, IHostService)))
], NotificationsToasts)));
let NotificationService = class NotificationService extends Disposable {
    constructor(storageService) {
        super();
        this.storageService = storageService;
        this.model = this._register(( (new NotificationsModel())));
        this._onDidAddNotification = this._register(( (new Emitter())));
        this.onDidAddNotification = this._onDidAddNotification.event;
        this._onDidRemoveNotification = this._register(( (new Emitter())));
        this.onDidRemoveNotification = this._onDidRemoveNotification.event;
        this._onDidChangeDoNotDisturbMode = this._register(( (new Emitter())));
        this.onDidChangeDoNotDisturbMode = this._onDidChangeDoNotDisturbMode.event;
        this._doNotDisturbMode = this.storageService.getBoolean(NotificationService.DND_SETTINGS_KEY, -1 , false);
        this.updateDoNotDisturbFilters();
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.model.onDidChangeNotification(e => {
            switch (e.kind) {
                case 0 :
                case 3 : {
                    const notification = {
                        message: e.item.message.original,
                        severity: e.item.severity,
                        source: typeof e.item.sourceId === 'string' && typeof e.item.source === 'string' ? { id: e.item.sourceId, label: e.item.source } : e.item.source,
                        silent: e.item.silent
                    };
                    if (e.kind === 0 ) {
                        this._onDidAddNotification.fire(notification);
                    }
                    if (e.kind === 3 ) {
                        this._onDidRemoveNotification.fire(notification);
                    }
                    break;
                }
            }
        }));
    }
    get doNotDisturbMode() {
        return this._doNotDisturbMode;
    }
    set doNotDisturbMode(enabled) {
        if (this._doNotDisturbMode === enabled) {
            return;
        }
        this.storageService.store(NotificationService.DND_SETTINGS_KEY, enabled, -1 , 1 );
        this._doNotDisturbMode = enabled;
        this.updateDoNotDisturbFilters();
        this._onDidChangeDoNotDisturbMode.fire();
    }
    updateDoNotDisturbFilters() {
        let filter;
        if (this._doNotDisturbMode) {
            filter = NotificationsFilter.ERROR;
        }
        else {
            filter = NotificationsFilter.OFF;
        }
        this.model.setFilter(filter);
    }
    info(message) {
        if (Array.isArray(message)) {
            message.forEach(m => this.info(m));
            return;
        }
        this.model.addNotification({ severity: Severity.Info, message });
    }
    warn(message) {
        if (Array.isArray(message)) {
            message.forEach(m => this.warn(m));
            return;
        }
        this.model.addNotification({ severity: Severity.Warning, message });
    }
    error(message) {
        if (Array.isArray(message)) {
            message.forEach(m => this.error(m));
            return;
        }
        this.model.addNotification({ severity: Severity.Error, message });
    }
    notify(notification) {
        const toDispose = ( (new DisposableStore()));
        if (notification.neverShowAgain) {
            const scope = this.toStorageScope(notification.neverShowAgain);
            const id = notification.neverShowAgain.id;
            if (this.storageService.getBoolean(id, scope)) {
                return (
                     (new NoOpNotification())
                );
            }
            const neverShowAgainAction = toDispose.add(( (new Action(
                'workbench.notification.neverShowAgain',
                 (localize('neverShowAgain', "Don't Show Again")),
                undefined,
                true,
                async () => {
                    handle.close();
                    this.storageService.store(id, true, scope, 0 );
                }
            ))));
            const actions = {
                primary: notification.actions?.primary || [],
                secondary: notification.actions?.secondary || []
            };
            if (!notification.neverShowAgain.isSecondary) {
                actions.primary = [neverShowAgainAction, ...actions.primary];
            }
            else {
                actions.secondary = [...actions.secondary, neverShowAgainAction];
            }
            notification.actions = actions;
        }
        const handle = this.model.addNotification(notification);
        Event.once(handle.onDidClose)(() => toDispose.dispose());
        return handle;
    }
    toStorageScope(options) {
        switch (options.scope) {
            case NeverShowAgainScope.APPLICATION:
                return -1 ;
            case NeverShowAgainScope.PROFILE:
                return 0 ;
            case NeverShowAgainScope.WORKSPACE:
                return 1 ;
            default:
                return -1 ;
        }
    }
    prompt(severity, message, choices, options) {
        const toDispose = ( (new DisposableStore()));
        if (options?.neverShowAgain) {
            const scope = this.toStorageScope(options.neverShowAgain);
            const id = options.neverShowAgain.id;
            if (this.storageService.getBoolean(id, scope)) {
                return (
                     (new NoOpNotification())
                );
            }
            const neverShowAgainChoice = {
                label: ( (localize('neverShowAgain', "Don't Show Again"))),
                run: () => this.storageService.store(id, true, scope, 0 ),
                isSecondary: options.neverShowAgain.isSecondary
            };
            if (!options.neverShowAgain.isSecondary) {
                choices = [neverShowAgainChoice, ...choices];
            }
            else {
                choices = [...choices, neverShowAgainChoice];
            }
        }
        let choiceClicked = false;
        const primaryActions = [];
        const secondaryActions = [];
        choices.forEach((choice, index) => {
            const action = ( (new ChoiceAction(`workbench.dialog.choice.${index}`, choice)));
            if (!choice.isSecondary) {
                primaryActions.push(action);
            }
            else {
                secondaryActions.push(action);
            }
            toDispose.add(action.onDidRun(() => {
                choiceClicked = true;
                if (!choice.keepOpen) {
                    handle.close();
                }
            }));
            toDispose.add(action);
        });
        const actions = { primary: primaryActions, secondary: secondaryActions };
        const handle = this.notify({ severity, message, actions, sticky: options?.sticky, silent: options?.silent });
        Event.once(handle.onDidClose)(() => {
            toDispose.dispose();
            if (options && typeof options.onCancel === 'function' && !choiceClicked) {
                options.onCancel();
            }
        });
        return handle;
    }
    status(message, options) {
        return this.model.showStatusMessage(message, options);
    }
};
NotificationService.DND_SETTINGS_KEY = 'notifications.doNotDisturbMode';
NotificationService = ( (__decorate([
    ( (__param(0, IStorageService)))
], NotificationService)));
var css = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n.monaco-workbench > .notifications-center {\n\tposition: absolute;\n\tz-index: 1000;\n\tright: 8px;\n\tbottom: 31px;\n\tdisplay: none;\n\toverflow: hidden;\n}\n\n.monaco-workbench.nostatusbar > .notifications-center {\n\tbottom: 8px;\n}\n\n.monaco-workbench > .notifications-center.visible {\n\tdisplay: block;\n}\n\n/* Header */\n\n.monaco-workbench > .notifications-center > .notifications-center-header {\n\tdisplay: flex;\n\talign-items: center;\n\tpadding-left: 8px;\n\tpadding-right: 5px;\n\theight: 35px;\n}\n\n.monaco-workbench > .notifications-center > .notifications-center-header > .notifications-center-header-title {\n\ttext-transform: uppercase;\n\tfont-size: 11px;\n}\n\n.monaco-workbench > .notifications-center > .notifications-center-header > .notifications-center-header-toolbar {\n\tflex: 1;\n}\n\n.monaco-workbench > .notifications-center > .notifications-center-header > .notifications-center-header-toolbar .actions-container {\n\tjustify-content: flex-end;\n}\n";
n(css,{});
let NotificationsCenter = class NotificationsCenter extends Themable {
    constructor(container, model, themeService, instantiationService, layoutService, contextKeyService, editorGroupService, keybindingService, notificationService) {
        super(themeService);
        this.container = container;
        this.model = model;
        this.instantiationService = instantiationService;
        this.layoutService = layoutService;
        this.contextKeyService = contextKeyService;
        this.editorGroupService = editorGroupService;
        this.keybindingService = keybindingService;
        this.notificationService = notificationService;
        this._onDidChangeVisibility = this._register(( (new Emitter())));
        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
        this.notificationsCenterVisibleContextKey = NotificationsCenterVisibleContext.bindTo(this.contextKeyService);
        this.notificationsCenterVisibleContextKey = NotificationsCenterVisibleContext.bindTo(contextKeyService);
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.model.onDidChangeNotification(e => this.onDidChangeNotification(e)));
        this._register(this.layoutService.onDidLayout(dimension => this.layout(Dimension.lift(dimension))));
        this._register(this.notificationService.onDidChangeDoNotDisturbMode(() => this.onDidChangeDoNotDisturbMode()));
    }
    onDidChangeDoNotDisturbMode() {
        this.hide();
    }
    get isVisible() {
        return !!this._isVisible;
    }
    show() {
        if (this._isVisible) {
            const notificationsList = assertIsDefined(this.notificationsList);
            notificationsList.show(true );
            return;
        }
        if (!this.notificationsCenterContainer) {
            this.create();
        }
        this.updateTitle();
        const [notificationsList, notificationsCenterContainer] = assertAllDefined(this.notificationsList, this.notificationsCenterContainer);
        this._isVisible = true;
        notificationsCenterContainer.classList.add('visible');
        notificationsList.show();
        this.layout(this.workbenchDimensions);
        notificationsList.updateNotificationsList(0, 0, this.model.notifications);
        notificationsList.focusFirst();
        this.updateStyles();
        this.model.notifications.forEach(notification => notification.updateVisibility(true));
        this.notificationsCenterVisibleContextKey.set(true);
        this._onDidChangeVisibility.fire();
    }
    updateTitle() {
        const [notificationsCenterTitle, clearAllAction] = assertAllDefined(this.notificationsCenterTitle, this.clearAllAction);
        if (this.model.notifications.length === 0) {
            notificationsCenterTitle.textContent = ( (localize('notificationsEmpty', "No new notifications")));
            clearAllAction.enabled = false;
        }
        else {
            notificationsCenterTitle.textContent = ( (localize('notifications', "Notifications")));
            clearAllAction.enabled = this.model.notifications.some(notification => !notification.hasProgress);
        }
    }
    create() {
        this.notificationsCenterContainer = document.createElement('div');
        this.notificationsCenterContainer.classList.add('notifications-center');
        this.notificationsCenterHeader = document.createElement('div');
        this.notificationsCenterHeader.classList.add('notifications-center-header');
        this.notificationsCenterContainer.appendChild(this.notificationsCenterHeader);
        this.notificationsCenterTitle = document.createElement('span');
        this.notificationsCenterTitle.classList.add('notifications-center-header-title');
        this.notificationsCenterHeader.appendChild(this.notificationsCenterTitle);
        const toolbarContainer = document.createElement('div');
        toolbarContainer.classList.add('notifications-center-header-toolbar');
        this.notificationsCenterHeader.appendChild(toolbarContainer);
        const actionRunner = this._register(this.instantiationService.createInstance(NotificationActionRunner));
        const notificationsToolBar = this._register(( (new ActionBar(toolbarContainer, {
            ariaLabel: ( (localize('notificationsToolbar', "Notification Center Actions"))),
            actionRunner
        }))));
        this.clearAllAction = this._register(this.instantiationService.createInstance(ClearAllNotificationsAction, ClearAllNotificationsAction.ID, ClearAllNotificationsAction.LABEL));
        notificationsToolBar.push(this.clearAllAction, { icon: true, label: false, keybinding: this.getKeybindingLabel(this.clearAllAction) });
        this.toggleDoNotDisturbAction = this._register(this.instantiationService.createInstance(ToggleDoNotDisturbAction, ToggleDoNotDisturbAction.ID, ToggleDoNotDisturbAction.LABEL));
        notificationsToolBar.push(this.toggleDoNotDisturbAction, { icon: true, label: false, keybinding: this.getKeybindingLabel(this.toggleDoNotDisturbAction) });
        const hideAllAction = this._register(this.instantiationService.createInstance(HideNotificationsCenterAction, HideNotificationsCenterAction.ID, HideNotificationsCenterAction.LABEL));
        notificationsToolBar.push(hideAllAction, { icon: true, label: false, keybinding: this.getKeybindingLabel(hideAllAction) });
        this.notificationsList = this.instantiationService.createInstance(NotificationsList, this.notificationsCenterContainer, {
            widgetAriaLabel: ( (localize('notificationsCenterWidgetAriaLabel', "Notifications Center")))
        });
        this.container.appendChild(this.notificationsCenterContainer);
    }
    getKeybindingLabel(action) {
        const keybinding = this.keybindingService.lookupKeybinding(action.id);
        return keybinding ? keybinding.getLabel() : null;
    }
    onDidChangeNotification(e) {
        if (!this._isVisible) {
            return;
        }
        let focusEditor = false;
        const [notificationsList, notificationsCenterContainer] = assertAllDefined(this.notificationsList, this.notificationsCenterContainer);
        switch (e.kind) {
            case 0 :
                notificationsList.updateNotificationsList(e.index, 0, [e.item]);
                e.item.updateVisibility(true);
                break;
            case 1 :
                switch (e.detail) {
                    case 2 :
                        notificationsList.updateNotificationsList(e.index, 1, [e.item]);
                        break;
                    case 1 :
                        if (e.item.expanded) {
                            notificationsList.updateNotificationHeight(e.item);
                        }
                        break;
                }
                break;
            case 2 :
                notificationsList.updateNotificationsList(e.index, 1, [e.item]);
                break;
            case 3 :
                focusEditor = isAncestor(document.activeElement, notificationsCenterContainer);
                notificationsList.updateNotificationsList(e.index, 1);
                e.item.updateVisibility(false);
                break;
        }
        this.updateTitle();
        if (this.model.notifications.length === 0) {
            this.hide();
            if (focusEditor) {
                this.editorGroupService.activeGroup.focus();
            }
        }
    }
    hide() {
        if (!this._isVisible || !this.notificationsCenterContainer || !this.notificationsList) {
            return;
        }
        const focusEditor = isAncestor(document.activeElement, this.notificationsCenterContainer);
        this._isVisible = false;
        this.notificationsCenterContainer.classList.remove('visible');
        this.notificationsList.hide();
        this.model.notifications.forEach(notification => notification.updateVisibility(false));
        this.notificationsCenterVisibleContextKey.set(false);
        this._onDidChangeVisibility.fire();
        if (focusEditor) {
            this.editorGroupService.activeGroup.focus();
        }
    }
    updateStyles() {
        if (this.notificationsCenterContainer && this.notificationsCenterHeader) {
            const widgetShadowColor = this.getColor(widgetShadow);
            this.notificationsCenterContainer.style.boxShadow = widgetShadowColor ? `0 0 8px 2px ${widgetShadowColor}` : '';
            const borderColor = this.getColor(NOTIFICATIONS_CENTER_BORDER);
            this.notificationsCenterContainer.style.border = borderColor ? `1px solid ${borderColor}` : '';
            const headerForeground = this.getColor(NOTIFICATIONS_CENTER_HEADER_FOREGROUND);
            this.notificationsCenterHeader.style.color = headerForeground ? ( (headerForeground.toString())) : '';
            const headerBackground = this.getColor(NOTIFICATIONS_CENTER_HEADER_BACKGROUND);
            this.notificationsCenterHeader.style.background = headerBackground ? ( (headerBackground.toString())) : '';
        }
    }
    layout(dimension) {
        this.workbenchDimensions = dimension;
        if (this._isVisible && this.notificationsCenterContainer) {
            const maxWidth = NotificationsCenter.MAX_DIMENSIONS.width;
            const maxHeight = NotificationsCenter.MAX_DIMENSIONS.height;
            let availableWidth = maxWidth;
            let availableHeight = maxHeight;
            if (this.workbenchDimensions) {
                availableWidth = this.workbenchDimensions.width;
                availableWidth -= (2 * 8);
                availableHeight = this.workbenchDimensions.height - 35 ;
                if (this.layoutService.isVisible("workbench.parts.statusbar" )) {
                    availableHeight -= 22;
                }
                if (this.layoutService.isVisible("workbench.parts.titlebar" )) {
                    availableHeight -= 22;
                }
                availableHeight -= (2 * 12);
            }
            const notificationsList = assertIsDefined(this.notificationsList);
            notificationsList.layout(Math.min(maxWidth, availableWidth), Math.min(maxHeight, availableHeight));
        }
    }
    clearAll() {
        this.hide();
        for (const notification of [...this.model.notifications] ) {
            if (!notification.hasProgress) {
                notification.close();
            }
        }
    }
};
NotificationsCenter.MAX_DIMENSIONS = ( (new Dimension(450, 400)));
NotificationsCenter = ( (__decorate([
    ( (__param(2, IThemeService))),
    ( (__param(3, IInstantiationService))),
    ( (__param(4, IWorkbenchLayoutService))),
    ( (__param(5, IContextKeyService))),
    ( (__param(6, IEditorGroupsService))),
    ( (__param(7, IKeybindingService))),
    ( (__param(8, INotificationService)))
], NotificationsCenter)));
registerThemingParticipant((theme, collector) => {
    const notificationBorderColor = theme.getColor(NOTIFICATIONS_BORDER);
    if (notificationBorderColor) {
        collector.addRule(`.monaco-workbench > .notifications-center .notifications-list-container .monaco-list-row[data-last-element="false"] > .notification-list-item { border-bottom: 1px solid ${notificationBorderColor}; }`);
    }
});
class NotificationsAlerts extends Disposable {
    constructor(model) {
        super();
        this.model = model;
        for (const notification of model.notifications) {
            this.triggerAriaAlert(notification);
        }
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.model.onDidChangeNotification(e => this.onDidChangeNotification(e)));
    }
    onDidChangeNotification(e) {
        if (e.kind === 0 ) {
            this.triggerAriaAlert(e.item);
            if (e.item.severity === Severity.Error) {
                if (e.item.message.original instanceof Error) {
                    console.error(e.item.message.original);
                }
                else {
                    console.error(toErrorMessage(( (e.item.message.linkedText.toString())), true));
                }
            }
        }
    }
    triggerAriaAlert(notification) {
        if (notification.silent) {
            return;
        }
        const listener = notification.onDidChangeContent(e => {
            if (e.kind === 1 ) {
                this.doTriggerAriaAlert(notification);
            }
        });
        Event.once(notification.onDidClose)(() => listener.dispose());
        this.doTriggerAriaAlert(notification);
    }
    doTriggerAriaAlert(notification) {
        let alertText;
        if (notification.severity === Severity.Error) {
            alertText = ( (localize(
                'alertErrorMessage',
                "Error: {0}",
                 (notification.message.linkedText.toString())
            )));
        }
        else if (notification.severity === Severity.Warning) {
            alertText = ( (localize(
                'alertWarningMessage',
                "Warning: {0}",
                 (notification.message.linkedText.toString())
            )));
        }
        else {
            alertText = ( (localize(
                'alertInfoMessage',
                "Info: {0}",
                 (notification.message.linkedText.toString())
            )));
        }
        alert(alertText);
    }
}
function initialize(instantiationService) {
    const container = instantiationService.invokeFunction((accessor) => accessor.get(ILayoutService)).container;
    const model = instantiationService.invokeFunction((accessor) => accessor.get(INotificationService)).model;
    const notificationsCenter = instantiationService.createInstance(NotificationsCenter, container, model);
    const notificationsToasts = instantiationService.createInstance(NotificationsToasts, container, model);
    instantiationService.createInstance(NotificationsAlerts, model);
    instantiationService.createInstance(NotificationsTelemetry);
    registerNotificationCommands(notificationsCenter, notificationsToasts, model);
    notificationsToasts.layout(getClientArea(container));
    instantiationService.createInstance(DialogHandlerContribution);
}
function getServiceOverride(container) {
    onServicesInitialized(initialize);
    return {
        [( INotificationService.toString())]: new SyncDescriptor(NotificationService),
        ...getServiceOverride$1(container)
    };
}
export { getServiceOverride as default };

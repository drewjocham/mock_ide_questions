import { E as Emitter } from './polyfill.js';
import { B as Breakpoint$1, C as CallHierarchyIncomingCall$1, a as CallHierarchyItem$1, b as CallHierarchyOutgoingCall$1, c as CodeAction$1, d as CodeActionKind$1, e as CodeActionTriggerKind$1, f as CodeLens$1, g as Color$1, h as ColorInformation$1, i as ColorPresentation$1, j as CommentMode$1, k as CommentThreadCollapsibleState$1, l as CompletionItem$1, m as CompletionItemKind$1, n as CompletionItemTag$1, o as CompletionList$1, p as CompletionTriggerKind$1, q as ConfigurationTarget$1, r as CustomExecution$1, D as DebugAdapterExecutable$1, s as DebugAdapterInlineImplementation$1, t as DebugAdapterNamedPipeServer$1, u as DebugAdapterServer$1, v as DebugConsoleMode$1, w as DecorationRangeBehavior$1, x as Diagnostic$1, y as DiagnosticRelatedInformation$1, z as DiagnosticSeverity$1, A as DiagnosticTag$1, E as Disposable$1, F as DocumentHighlight$1, G as DocumentHighlightKind$1, H as DocumentLink$1, I as DocumentSymbol$1, J as EndOfLine$1, K as EnvironmentVariableMutatorType$1, L as EvaluatableExpression$1, M as InlineValueText$1, N as InlineValueVariableLookup$1, O as InlineValueEvaluatableExpression$1, P as ExtensionKind$1, Q as ExtensionMode$1, R as FileChangeType$1, S as FileDecoration$1, T as FileSystemError$1, U as FoldingRange$1, V as FoldingRangeKind$1, W as FunctionBreakpoint$1, X as Hover$1, Y as Location$1, Z as MarkdownString$1, _ as ParameterInformation$1, $ as Position$1, a0 as ProcessExecution$1, a1 as ProgressLocation$1, a2 as QuickInputButtons$1, a3 as Range$1, a4 as RelativePattern$1, a5 as Selection$2, a6 as SelectionRange$1, a7 as SemanticTokens$1, a8 as SemanticTokensBuilder$1, a9 as SemanticTokensEdit$1, aa as SemanticTokensEdits$1, ab as SemanticTokensLegend$1, ac as ShellExecution$1, ad as ShellQuoting$1, ae as SignatureHelp$1, af as SignatureHelpTriggerKind$1, ag as SignatureInformation$1, ah as SnippetString$1, ai as SourceBreakpoint$1, aj as StatusBarAlignment$1, ak as SymbolInformation$1, al as SymbolKind$1, am as SymbolTag$1, an as Task$1, ao as TaskGroup$1, ap as TaskPanelKind$1, aq as TaskRevealKind$1, ar as TaskScope$1, as as TerminalLink$1, at as TerminalLocation$1, au as TerminalProfile$1, av as TextDocumentSaveReason$1, aw as TextEdit$1, ax as TextEditorLineNumbersStyle$1, ay as TextEditorRevealType$1, az as TextEditorSelectionChangeKind$1, aA as TextDocumentChangeReason$1, aB as ThemeColor$1, aC as ThemeIcon$1, aD as TreeItem$1, aE as TreeItemCollapsibleState$1, aF as TypeHierarchyItem$1, aG as UIKind$1, aH as ViewColumn$1, aI as WorkspaceEdit$1, aJ as InlayHint$1, aK as InlayHintLabelPart$1, aL as InlayHintKind$1, aM as NotebookRange$1, aN as NotebookCellKind$1, aO as NotebookCellData$1, aP as NotebookData$1, aQ as NotebookCellStatusBarAlignment$1, aR as NotebookCellOutput$1, aS as NotebookCellOutputItem$1, aT as NotebookCellStatusBarItem$1, aU as NotebookControllerAffinity$1, aV as LinkedEditingRanges$1, aW as TestRunRequest$1, aX as TestMessage$1, aY as TestTag$1, aZ as TestRunProfileKind$1, a_ as LanguageStatusSeverity$1, a$ as QuickPickItemKind$1, b0 as TextDiffTabInput, b1 as CustomEditorTabInput, b2 as NotebookEditorTabInput, b3 as NotebookDiffEditorTabInput, b4 as WebviewEditorTabInput, b5 as TerminalEditorTabInput, b6 as InputBoxValidationSeverity$1, b7 as InlineSuggestionList, b8 as InlineCompletionTriggerKind$1, b9 as InlineSuggestion, ba as DocumentDropEdit$1, bb as NotebookEditorRevealType$1, bc as getExtHostServices, bd as DEFAULT_EXTENSION, be as LanguageSelector } from './extHost.js';
import { C as CancellationTokenSource$1, F as FileType$1, a as FilePermission$1, S as Services } from './services2.js';
import { score } from 'monaco-editor/esm/vs/editor/common/languageSelector.js';
import { u as unsupported$1 } from './missing-services.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import Severity from 'monaco-editor/esm/vs/base/common/severity.js';
import { StandaloneServices } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { matchesScheme } from 'monaco-editor/esm/vs/platform/opener/common/opener.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import { CancellationError as CancellationError$1 } from 'monaco-editor/esm/vs/base/common/errors.js';
import { IndentAction as IndentAction$1 } from 'monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js';
import { OverviewRulerLane as OverviewRulerLane$1 } from 'monaco-editor/esm/vs/editor/common/model.js';
import { TextEditorCursorStyle as TextEditorCursorStyle$1 } from 'monaco-editor/esm/vs/editor/common/config/editorOptions.js';
var DebugConfigurationProviderTriggerKind$1;
( ((function(DebugConfigurationProviderTriggerKind) {
    DebugConfigurationProviderTriggerKind[DebugConfigurationProviderTriggerKind["Initial"] = 1] = "Initial";
    DebugConfigurationProviderTriggerKind[DebugConfigurationProviderTriggerKind["Dynamic"] = 2] = "Dynamic";
})(
    DebugConfigurationProviderTriggerKind$1 || (DebugConfigurationProviderTriggerKind$1 = {})
)));
function checkSelector(selector) {
    return selector;
}
const languages$1 = {
    createDiagnosticCollection(name) {
        const { extHostDiagnostics } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostDiagnostics.createDiagnosticCollection(extension.identifier, name);
    },
    get onDidChangeDiagnostics() {
        const { extHostDiagnostics } = getExtHostServices();
        return extHostDiagnostics.onDidChangeDiagnostics;
    },
    getDiagnostics: (resource) => {
        const { extHostDiagnostics } = getExtHostServices();
        return extHostDiagnostics.getDiagnostics(resource);
    },
    getLanguages() {
        const { extHostLanguages } = getExtHostServices();
        return extHostLanguages.getLanguages();
    },
    setTextDocumentLanguage(document, languageId) {
        const { extHostLanguages } = getExtHostServices();
        return extHostLanguages.changeLanguage(document.uri, languageId);
    },
    match(selector, document) {
        return score(LanguageSelector.from(selector), document.uri, document.languageId, true, undefined, undefined);
    },
    registerCodeActionsProvider(selector, provider, metadata) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerCodeActionProvider(extension, checkSelector(selector), provider, metadata);
    },
    registerCodeLensProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerCodeLensProvider(extension, checkSelector(selector), provider);
    },
    registerDefinitionProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerDefinitionProvider(extension, checkSelector(selector), provider);
    },
    registerDeclarationProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerDeclarationProvider(extension, checkSelector(selector), provider);
    },
    registerImplementationProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerImplementationProvider(extension, checkSelector(selector), provider);
    },
    registerTypeDefinitionProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerTypeDefinitionProvider(extension, checkSelector(selector), provider);
    },
    registerHoverProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerHoverProvider(extension, checkSelector(selector), provider, extension.identifier);
    },
    registerEvaluatableExpressionProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerEvaluatableExpressionProvider(extension, checkSelector(selector), provider, extension.identifier);
    },
    registerInlineValuesProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerInlineValuesProvider(extension, checkSelector(selector), provider, extension.identifier);
    },
    registerDocumentHighlightProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerDocumentHighlightProvider(extension, checkSelector(selector), provider);
    },
    registerLinkedEditingRangeProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerLinkedEditingRangeProvider(extension, checkSelector(selector), provider);
    },
    registerReferenceProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerReferenceProvider(extension, checkSelector(selector), provider);
    },
    registerRenameProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerRenameProvider(extension, checkSelector(selector), provider);
    },
    registerDocumentSymbolProvider(selector, provider, metadata) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerDocumentSymbolProvider(extension, checkSelector(selector), provider, metadata);
    },
    registerWorkspaceSymbolProvider(provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerWorkspaceSymbolProvider(extension, provider);
    },
    registerDocumentFormattingEditProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerDocumentFormattingEditProvider(extension, checkSelector(selector), provider);
    },
    registerDocumentRangeFormattingEditProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerDocumentRangeFormattingEditProvider(extension, checkSelector(selector), provider);
    },
    registerOnTypeFormattingEditProvider(selector, provider, firstTriggerCharacter, ...moreTriggerCharacters) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerOnTypeFormattingEditProvider(extension, checkSelector(selector), provider, [firstTriggerCharacter].concat(moreTriggerCharacters));
    },
    registerDocumentSemanticTokensProvider(selector, provider, legend) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerDocumentSemanticTokensProvider(extension, checkSelector(selector), provider, legend);
    },
    registerDocumentRangeSemanticTokensProvider(selector, provider, legend) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerDocumentRangeSemanticTokensProvider(extension, checkSelector(selector), provider, legend);
    },
    registerSignatureHelpProvider(selector, provider, firstItem, ...remaining) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        if (typeof firstItem === 'object') {
            return extHostLanguageFeatures.registerSignatureHelpProvider(extension, checkSelector(selector), provider, firstItem);
        }
        return extHostLanguageFeatures.registerSignatureHelpProvider(extension, checkSelector(selector), provider, typeof firstItem === 'undefined' ? [] : [firstItem, ...remaining]);
    },
    registerCompletionItemProvider(selector, provider, ...triggerCharacters) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerCompletionItemProvider(extension, checkSelector(selector), provider, triggerCharacters);
    },
    registerDocumentLinkProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerDocumentLinkProvider(extension, checkSelector(selector), provider);
    },
    registerColorProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerColorProvider(extension, checkSelector(selector), provider);
    },
    registerFoldingRangeProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerFoldingRangeProvider(extension, checkSelector(selector), provider);
    },
    registerSelectionRangeProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerSelectionRangeProvider(extension, selector, provider);
    },
    registerCallHierarchyProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerCallHierarchyProvider(extension, selector, provider);
    },
    registerTypeHierarchyProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerTypeHierarchyProvider(extension, selector, provider);
    },
    setLanguageConfiguration: (language, configuration) => {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.setLanguageConfiguration(extension, language, configuration);
    },
    registerInlayHintsProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerInlayHintsProvider(extension, selector, provider);
    },
    createLanguageStatusItem(id, selector) {
        const { extHostLanguages } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguages.createLanguageStatusItem(extension, id, selector);
    },
    registerInlineCompletionItemProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerInlineCompletionsProvider(extension, checkSelector(selector), provider);
    },
    registerDocumentDropEditProvider(selector, provider) {
        const { extHostLanguageFeatures } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostLanguageFeatures.registerDocumentOnDropEditProvider(extension, selector, provider);
    }
};
const commands$1 = {
    registerCommand(id, command, thisArgs) {
        const { extHostCommands } = getExtHostServices();
        return extHostCommands.registerCommand(true, id, command, thisArgs, undefined, Services.get().extension ?? DEFAULT_EXTENSION);
    },
    registerTextEditorCommand(id, callback, thisArg) {
        const { extHostCommands, extHostEditors, extHostLogService } = getExtHostServices();
        return extHostCommands.registerCommand(true, id, (...args) => {
            const activeTextEditor = extHostEditors.getActiveTextEditor();
            if (activeTextEditor == null) {
                extHostLogService.warn('Cannot execute ' + id + ' because there is no active text editor.');
                return undefined;
            }
            return activeTextEditor.edit((edit) => {
                callback.apply(thisArg, [activeTextEditor, edit, ...args]);
            }).then((result) => {
                if (!result) {
                    extHostLogService.warn('Edits from command ' + id + ' were not applied.');
                }
            }, (err) => {
                extHostLogService.warn('An error occurred while running command ' + id, err);
            });
        }, undefined, undefined, Services.get().extension ?? DEFAULT_EXTENSION);
    },
    executeCommand(id, ...args) {
        const { extHostCommands } = getExtHostServices();
        return extHostCommands.executeCommand(id, ...args);
    },
    getCommands(filterInternal = false) {
        const { extHostCommands } = getExtHostServices();
        return extHostCommands.getCommands(filterInternal);
    }
};
class EmptyFileSystem {
    constructor() {
        this.stat = unsupported$1;
    }
    isWritableFileSystem() {
        return false;
    }
    readDirectory() {
        return Promise.resolve([]);
    }
    createDirectory() {
        return Promise.resolve();
    }
    readFile() {
        return Promise.resolve(new Uint8Array(0));
    }
    writeFile() {
        return Promise.resolve();
    }
    delete() {
        return Promise.resolve();
    }
    rename() {
        return Promise.resolve();
    }
    copy() {
        return Promise.resolve();
    }
}
const workspace$1 = {
    fs: new EmptyFileSystem(),
    workspaceFile: undefined,
    createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        const { workspace } = Services.get();
        if (workspace?.createFileSystemWatcher != null) {
            return workspace.createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);
        }
        return {
            ignoreCreateEvents: ignoreCreateEvents ?? false,
            ignoreChangeEvents: ignoreChangeEvents ?? false,
            ignoreDeleteEvents: ignoreDeleteEvents ?? false,
            onDidCreate: Event.None,
            onDidChange: Event.None,
            onDidDelete: Event.None,
            dispose: () => { }
        };
    },
    applyEdit: async (edit) => {
        const { extHostBulkEdits } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostBulkEdits.applyWorkspaceEdit(edit, extension);
    },
    getConfiguration: (section, scope) => {
        const { extHostConfiguration } = getExtHostServices();
        const configProvider = extHostConfiguration.getConfigProvider();
        return configProvider.getConfiguration(section, scope, Services.get().extension ?? DEFAULT_EXTENSION);
    },
    onDidChangeConfiguration(listener, thisArgs, disposables) {
        const { extHostConfiguration } = getExtHostServices();
        const configProvider = extHostConfiguration.getConfigProvider();
        return configProvider.onDidChangeConfiguration(listener, thisArgs, disposables);
    },
    get rootPath() {
        const { workspace } = Services.get();
        return workspace?.rootPath;
    },
    get workspaceFolders() {
        const { workspace } = Services.get();
        if (workspace == null) {
            return undefined;
        }
        if ('workspaceFolders' in workspace) {
            return workspace.workspaceFolders;
        }
        const rootPath = workspace.rootPath;
        if (rootPath == null) {
            return undefined;
        }
        const uri = URI.file(rootPath);
        return [{
                uri,
                index: 0,
                name: ( uri.toString())
            }];
    },
    getWorkspaceFolder(uri) {
        return this.workspaceFolders?.find(folder => {
            return uri.path.startsWith(folder.uri.path);
        });
    },
    get onDidChangeWorkspaceFolders() {
        const { workspace } = Services.get();
        return workspace?.onDidChangeWorkspaceFolders ?? Event.None;
    },
    get textDocuments() {
        const { extHostDocuments } = getExtHostServices();
        return Array.from(extHostDocuments.getAllDocumentData().map(data => data.document));
    },
    get onDidOpenTextDocument() {
        const { extHostDocuments } = getExtHostServices();
        return extHostDocuments.onDidAddDocument;
    },
    get onDidCloseTextDocument() {
        const { extHostDocuments } = getExtHostServices();
        return extHostDocuments.onDidRemoveDocument;
    },
    get onDidChangeTextDocument() {
        const { extHostDocuments } = getExtHostServices();
        return extHostDocuments.onDidChangeDocument;
    },
    get onWillSaveTextDocument() {
        const { workspace } = Services.get();
        return workspace?.onWillSaveTextDocument ?? Event.None;
    },
    get onDidSaveTextDocument() {
        const { workspace } = Services.get();
        return workspace?.onDidSaveTextDocument ?? Event.None;
    },
    get onWillCreateFiles() {
        return Event.None;
    },
    get onDidCreateFiles() {
        return Event.None;
    },
    get onWillDeleteFiles() {
        return Event.None;
    },
    get onDidDeleteFiles() {
        return Event.None;
    },
    get onWillRenameFiles() {
        return Event.None;
    },
    get onDidRenameFiles() {
        return Event.None;
    },
    get onDidGrantWorkspaceTrust() {
        return Event.None;
    },
    asRelativePath: unsupported$1,
    updateWorkspaceFolders(start, deleteCount, ...workspaceFoldersToAdd) {
        const { workspace } = Services.get();
        if (workspace?.updateWorkspaceFolders != null) {
            return workspace.updateWorkspaceFolders(start, deleteCount, ...workspaceFoldersToAdd);
        }
        return false;
    },
    findFiles: unsupported$1,
    saveAll: unsupported$1,
    openTextDocument(uriOrFileNameOrOptions) {
        const { extHostDocuments } = getExtHostServices();
        let uriPromise;
        const options = uriOrFileNameOrOptions;
        if (typeof uriOrFileNameOrOptions === 'string') {
            uriPromise = Promise.resolve(URI.file(uriOrFileNameOrOptions));
        }
        else if (URI.isUri(uriOrFileNameOrOptions)) {
            uriPromise = Promise.resolve(uriOrFileNameOrOptions);
        }
        else if (options == null || typeof options === 'object') {
            uriPromise = extHostDocuments.createDocumentData(options);
        }
        else {
            throw new Error('illegal argument - uriOrFileNameOrOptions');
        }
        return uriPromise.then(uri => {
            return extHostDocuments.ensureDocumentData(uri).then(documentData => {
                return documentData.document;
            });
        });
    },
    registerTextDocumentContentProvider(scheme, provider) {
        const { extHostDocumentContentProviders } = getExtHostServices();
        return extHostDocumentContentProviders.registerTextDocumentContentProvider(scheme, provider);
    },
    registerTaskProvider: unsupported$1,
    registerFileSystemProvider: unsupported$1,
    openNotebookDocument: unsupported$1,
    registerNotebookSerializer: unsupported$1,
    notebookDocuments: [],
    onDidOpenNotebookDocument: unsupported$1,
    onDidCloseNotebookDocument: unsupported$1,
    isTrusted: true,
    name: undefined,
    onDidChangeNotebookDocument: unsupported$1,
    onDidSaveNotebookDocument: unsupported$1
};
class TextTabInput {
    constructor(uri) {
        this.uri = uri;
    }
}
function getTabFromModel(model, tabGroup) {
    return {
        label: model.uri.fsPath,
        group: tabGroup,
        get isActive() { return model.isAttachedToEditor(); },
        isDirty: false,
        isPinned: false,
        isPreview: false,
        input: new TextTabInput(model.uri)
    };
}
const tabGroup = {
    isActive: true,
    activeTab: undefined,
    viewColumn: ViewColumn$1.One,
    get tabs() {
        const modelService = StandaloneServices.get(IModelService);
        return modelService.getModels().map(model => getTabFromModel(model, tabGroup));
    }
};
const window$2 = {
    showInformationMessage(message, ...rest) {
        const { extHostMessageService } = getExtHostServices();
        return extHostMessageService.showMessage(Services.get().extension ?? DEFAULT_EXTENSION, Severity.Info, message, rest[0], rest.slice(1));
    },
    showWarningMessage(message, ...rest) {
        const { extHostMessageService } = getExtHostServices();
        return extHostMessageService.showMessage(Services.get().extension ?? DEFAULT_EXTENSION, Severity.Warning, message, rest[0], rest.slice(1));
    },
    showErrorMessage(message, ...rest) {
        const { extHostMessageService } = getExtHostServices();
        return extHostMessageService.showMessage(Services.get().extension ?? DEFAULT_EXTENSION, Severity.Error, message, rest[0], rest.slice(1));
    },
    createOutputChannel(name) {
        const { window } = Services.get();
        const createOutputChannel = window?.createOutputChannel;
        const channel = createOutputChannel?.call(window, name);
        return channel ?? {
            name,
            append: () => { },
            appendLine: () => { },
            clear: unsupported$1,
            show: () => { },
            hide: unsupported$1,
            replace: unsupported$1,
            dispose: () => { }
        };
    },
    withScmProgress(task) {
        const { extHostProgress } = getExtHostServices();
        return extHostProgress.withProgress(Services.get().extension ?? DEFAULT_EXTENSION, { location: ProgressLocation$1.SourceControl }, () => task({ report() { } }));
    },
    withProgress(options, task) {
        const { extHostProgress } = getExtHostServices();
        return extHostProgress.withProgress(Services.get().extension ?? DEFAULT_EXTENSION, options, task);
    },
    showTextDocument: async (documentOrUri, columnOrOptions, preserveFocus) => {
        const { extHostEditors } = getExtHostServices();
        const document = await (URI.isUri(documentOrUri)
            ? Promise.resolve(workspace$1.openTextDocument(documentOrUri))
            : Promise.resolve(documentOrUri));
        return extHostEditors.showTextDocument(document, columnOrOptions, preserveFocus);
    },
    createQuickPick() {
        const { extHostQuickOpen } = getExtHostServices();
        return extHostQuickOpen.createQuickPick(Services.get().extension ?? DEFAULT_EXTENSION);
    },
    showQuickPick(items, options, token) {
        const { extHostQuickOpen } = getExtHostServices();
        return extHostQuickOpen.showQuickPick(items, options, token);
    },
    createInputBox() {
        const { extHostQuickOpen } = getExtHostServices();
        const extension = Services.get().extension ?? DEFAULT_EXTENSION;
        return extHostQuickOpen.createInputBox(extension);
    },
    showInputBox(options, token) {
        const { extHostQuickOpen } = getExtHostServices();
        return extHostQuickOpen.showInput(options, token);
    },
    createTextEditorDecorationType: unsupported$1,
    showWorkspaceFolderPick: unsupported$1,
    showOpenDialog: unsupported$1,
    showSaveDialog: unsupported$1,
    createWebviewPanel: unsupported$1,
    setStatusBarMessage: unsupported$1,
    createStatusBarItem: unsupported$1,
    createTerminal: unsupported$1,
    registerTreeDataProvider: unsupported$1,
    createTreeView: unsupported$1,
    registerWebviewPanelSerializer: unsupported$1,
    get activeTextEditor() {
        const { extHostEditors } = getExtHostServices();
        return extHostEditors.getActiveTextEditor();
    },
    get visibleTextEditors() {
        const { extHostEditors } = getExtHostServices();
        return extHostEditors.getVisibleTextEditors();
    },
    onDidChangeActiveTextEditor(listener, thisArg, disposables) {
        const { extHostEditors } = getExtHostServices();
        return extHostEditors.onDidChangeActiveTextEditor(listener, thisArg, disposables);
    },
    onDidChangeVisibleTextEditors(listener, thisArg, disposables) {
        const { extHostEditors } = getExtHostServices();
        return extHostEditors.onDidChangeVisibleTextEditors(listener, thisArg, disposables);
    },
    onDidChangeTextEditorSelection(listener, thisArgs, disposables) {
        const { extHostEditors } = getExtHostServices();
        return extHostEditors.onDidChangeTextEditorSelection(listener, thisArgs, disposables);
    },
    onDidChangeTextEditorVisibleRanges(listener, thisArgs, disposables) {
        const { extHostEditors } = getExtHostServices();
        return extHostEditors.onDidChangeTextEditorVisibleRanges(listener, thisArgs, disposables);
    },
    onDidChangeTextEditorOptions(listener, thisArgs, disposables) {
        const { extHostEditors } = getExtHostServices();
        return extHostEditors.onDidChangeTextEditorOptions(listener, thisArgs, disposables);
    },
    onDidChangeTextEditorViewColumn(listener, thisArg, disposables) {
        const { extHostEditors } = getExtHostServices();
        return extHostEditors.onDidChangeTextEditorViewColumn(listener, thisArg, disposables);
    },
    get terminals() {
        return unsupported$1();
    },
    get activeTerminal() {
        return unsupported$1();
    },
    onDidChangeActiveTerminal: Event.None,
    onDidOpenTerminal: Event.None,
    onDidCloseTerminal: Event.None,
    get state() {
        return unsupported$1();
    },
    onDidChangeWindowState: Event.None,
    registerUriHandler: unsupported$1,
    registerWebviewViewProvider: unsupported$1,
    registerCustomEditorProvider: unsupported$1,
    registerTerminalLinkProvider: unsupported$1,
    get activeColorTheme() {
        return unsupported$1();
    },
    onDidChangeActiveColorTheme: Event.None,
    registerFileDecorationProvider: unsupported$1,
    registerTerminalProfileProvider: unsupported$1,
    onDidChangeTerminalState: Event.None,
    tabGroups: {
        get all() {
            return [tabGroup];
        },
        activeTabGroup: tabGroup,
        onDidChangeTabGroups: Event.None,
        onDidChangeTabs(listener) {
            const modelService = StandaloneServices.get(IModelService);
            const store = new DisposableStore();
            store.add(modelService.onModelAdded((model) => {
                listener({
                    opened: [getTabFromModel(model, tabGroup)],
                    closed: [],
                    changed: []
                });
            }));
            store.add(modelService.onModelRemoved((model) => {
                listener({
                    opened: [],
                    closed: [getTabFromModel(model, tabGroup)],
                    changed: []
                });
            }));
            return store;
        },
        close: unsupported$1
    },
    showNotebookDocument: unsupported$1,
    visibleNotebookEditors: [],
    onDidChangeVisibleNotebookEditors: Event.None,
    activeNotebookEditor: undefined,
    onDidChangeActiveNotebookEditor: Event.None,
    onDidChangeNotebookEditorSelection: Event.None,
    onDidChangeNotebookEditorVisibleRanges: Event.None
};
const env$1 = {
    appName: 'Monaco',
    appRoot: '',
    language: window.navigator.language ?? 'en-US',
    get uriScheme() {
        return unsupported$1();
    },
    get clipboard() {
        const { extHostClipboard } = getExtHostServices();
        return extHostClipboard.value;
    },
    get machineId() {
        return unsupported$1();
    },
    get sessionId() {
        return unsupported$1();
    },
    remoteName: undefined,
    shell: '',
    uiKind: UIKind$1.Web,
    async asExternalUri(uri) {
        const { extHostWindow } = getExtHostServices();
        try {
            return await extHostWindow.asExternalUri(uri, { allowTunneling: false });
        }
        catch (err) {
            if (matchesScheme(uri, Schemas.http) || matchesScheme(uri, Schemas.https)) {
                return uri;
            }
            throw err;
        }
    },
    openExternal: async (uri, options) => {
        const { extHostWindow } = getExtHostServices();
        return extHostWindow.openUri(uri, {
            allowTunneling: false,
            allowContributedOpeners: options?.allowContributedOpeners
        });
    },
    appHost: 'web',
    isNewAppInstall: false,
    isTelemetryEnabled: false,
    onDidChangeTelemetryEnabled: Event.None
};
const unsupported = undefined;
const api = {
    version: "1.69.0",
    tasks: unsupported,
    notebooks: unsupported,
    scm: unsupported,
    debug: unsupported,
    extensions: unsupported,
    comments: unsupported,
    authentication: unsupported,
    tests: unsupported,
    env: env$1,
    commands: commands$1,
    window: window$2,
    workspace: workspace$1,
    languages: languages$1,
    Breakpoint: Breakpoint$1,
    CallHierarchyIncomingCall: CallHierarchyIncomingCall$1,
    CallHierarchyItem: CallHierarchyItem$1,
    CallHierarchyOutgoingCall: CallHierarchyOutgoingCall$1,
    CancellationError: CancellationError$1,
    CancellationTokenSource: CancellationTokenSource$1,
    CodeAction: CodeAction$1,
    CodeActionKind: CodeActionKind$1,
    CodeActionTriggerKind: CodeActionTriggerKind$1,
    CodeLens: CodeLens$1,
    Color: Color$1,
    ColorInformation: ColorInformation$1,
    ColorPresentation: ColorPresentation$1,
    ColorThemeKind: unsupported,
    CommentMode: CommentMode$1,
    CommentThreadCollapsibleState: CommentThreadCollapsibleState$1,
    CompletionItem: CompletionItem$1,
    CompletionItemKind: CompletionItemKind$1,
    CompletionItemTag: CompletionItemTag$1,
    CompletionList: CompletionList$1,
    CompletionTriggerKind: CompletionTriggerKind$1,
    ConfigurationTarget: ConfigurationTarget$1,
    CustomExecution: CustomExecution$1,
    DebugAdapterExecutable: DebugAdapterExecutable$1,
    DebugAdapterInlineImplementation: DebugAdapterInlineImplementation$1,
    DebugAdapterNamedPipeServer: DebugAdapterNamedPipeServer$1,
    DebugAdapterServer: DebugAdapterServer$1,
    DebugConfigurationProviderTriggerKind: DebugConfigurationProviderTriggerKind$1,
    DebugConsoleMode: DebugConsoleMode$1,
    DecorationRangeBehavior: DecorationRangeBehavior$1,
    Diagnostic: Diagnostic$1,
    DiagnosticRelatedInformation: DiagnosticRelatedInformation$1,
    DiagnosticSeverity: DiagnosticSeverity$1,
    DiagnosticTag: DiagnosticTag$1,
    Disposable: Disposable$1,
    DocumentHighlight: DocumentHighlight$1,
    DocumentHighlightKind: DocumentHighlightKind$1,
    DocumentLink: DocumentLink$1,
    DocumentSymbol: DocumentSymbol$1,
    EndOfLine: EndOfLine$1,
    EnvironmentVariableMutatorType: EnvironmentVariableMutatorType$1,
    EvaluatableExpression: EvaluatableExpression$1,
    InlineValueText: InlineValueText$1,
    InlineValueVariableLookup: InlineValueVariableLookup$1,
    InlineValueEvaluatableExpression: InlineValueEvaluatableExpression$1,
    EventEmitter: Emitter,
    ExtensionKind: ExtensionKind$1,
    ExtensionMode: ExtensionMode$1,
    FileChangeType: FileChangeType$1,
    FileDecoration: FileDecoration$1,
    FileSystemError: FileSystemError$1,
    FileType: FileType$1,
    FilePermission: FilePermission$1,
    FoldingRange: FoldingRange$1,
    FoldingRangeKind: FoldingRangeKind$1,
    FunctionBreakpoint: FunctionBreakpoint$1,
    Hover: Hover$1,
    IndentAction: IndentAction$1,
    Location: Location$1,
    MarkdownString: MarkdownString$1,
    OverviewRulerLane: OverviewRulerLane$1,
    ParameterInformation: ParameterInformation$1,
    Position: Position$1,
    ProcessExecution: ProcessExecution$1,
    ProgressLocation: ProgressLocation$1,
    QuickInputButtons: QuickInputButtons$1,
    Range: Range$1,
    RelativePattern: RelativePattern$1,
    Selection: Selection$2,
    SelectionRange: SelectionRange$1,
    SemanticTokens: SemanticTokens$1,
    SemanticTokensBuilder: SemanticTokensBuilder$1,
    SemanticTokensEdit: SemanticTokensEdit$1,
    SemanticTokensEdits: SemanticTokensEdits$1,
    SemanticTokensLegend: SemanticTokensLegend$1,
    ShellExecution: ShellExecution$1,
    ShellQuoting: ShellQuoting$1,
    SignatureHelp: SignatureHelp$1,
    SignatureHelpTriggerKind: SignatureHelpTriggerKind$1,
    SignatureInformation: SignatureInformation$1,
    SnippetString: SnippetString$1,
    SourceBreakpoint: SourceBreakpoint$1,
    StatusBarAlignment: StatusBarAlignment$1,
    SymbolInformation: SymbolInformation$1,
    SymbolKind: SymbolKind$1,
    SymbolTag: SymbolTag$1,
    Task: Task$1,
    TaskGroup: TaskGroup$1,
    TaskPanelKind: TaskPanelKind$1,
    TaskRevealKind: TaskRevealKind$1,
    TaskScope: TaskScope$1,
    TerminalLink: TerminalLink$1,
    TerminalLocation: TerminalLocation$1,
    TerminalProfile: TerminalProfile$1,
    TextDocumentSaveReason: TextDocumentSaveReason$1,
    TextEdit: TextEdit$1,
    TextEditorCursorStyle: TextEditorCursorStyle$1,
    TextEditorLineNumbersStyle: TextEditorLineNumbersStyle$1,
    TextEditorRevealType: TextEditorRevealType$1,
    TextEditorSelectionChangeKind: TextEditorSelectionChangeKind$1,
    TextDocumentChangeReason: TextDocumentChangeReason$1,
    ThemeColor: ThemeColor$1,
    ThemeIcon: ThemeIcon$1,
    TreeItem: TreeItem$1,
    TreeItemCollapsibleState: TreeItemCollapsibleState$1,
    TypeHierarchyItem: TypeHierarchyItem$1,
    UIKind: UIKind$1,
    Uri: URI,
    ViewColumn: ViewColumn$1,
    WorkspaceEdit: WorkspaceEdit$1,
    InlayHint: InlayHint$1,
    InlayHintLabelPart: InlayHintLabelPart$1,
    InlayHintKind: InlayHintKind$1,
    NotebookRange: NotebookRange$1,
    NotebookCellKind: NotebookCellKind$1,
    NotebookCellData: NotebookCellData$1,
    NotebookData: NotebookData$1,
    NotebookCellStatusBarAlignment: NotebookCellStatusBarAlignment$1,
    NotebookCellOutput: NotebookCellOutput$1,
    NotebookCellOutputItem: NotebookCellOutputItem$1,
    NotebookCellStatusBarItem: NotebookCellStatusBarItem$1,
    NotebookControllerAffinity: NotebookControllerAffinity$1,
    LinkedEditingRanges: LinkedEditingRanges$1,
    TestRunRequest: TestRunRequest$1,
    TestMessage: TestMessage$1,
    TestTag: TestTag$1,
    TestRunProfileKind: TestRunProfileKind$1,
    DataTransfer: unsupported,
    DataTransferItem: unsupported,
    LanguageStatusSeverity: LanguageStatusSeverity$1,
    QuickPickItemKind: QuickPickItemKind$1,
    TabInputText: TextTabInput,
    TabInputTextDiff: TextDiffTabInput,
    TabInputCustom: CustomEditorTabInput,
    TabInputNotebook: NotebookEditorTabInput,
    TabInputNotebookDiff: NotebookDiffEditorTabInput,
    TabInputWebview: WebviewEditorTabInput,
    TabInputTerminal: TerminalEditorTabInput,
    InputBoxValidationSeverity: InputBoxValidationSeverity$1,
    InlineCompletionList: InlineSuggestionList,
    InlineCompletionTriggerKind: InlineCompletionTriggerKind$1,
    InlineCompletionItem: InlineSuggestion,
    DocumentDropEdit: DocumentDropEdit$1,
    NotebookEditorRevealType: NotebookEditorRevealType$1
};
const { version, tasks, notebooks, scm, debug, extensions, comments, authentication, tests, env, commands, window: window$1, workspace, languages, Breakpoint, CallHierarchyIncomingCall, CallHierarchyItem, CallHierarchyOutgoingCall, CancellationError, CancellationTokenSource, CodeAction, CodeActionKind, CodeActionTriggerKind, CodeLens, Color, ColorInformation, ColorPresentation, ColorThemeKind, CommentMode, CommentThreadCollapsibleState, CompletionItem, CompletionItemKind, CompletionItemTag, CompletionList, CompletionTriggerKind, ConfigurationTarget, CustomExecution, DebugAdapterExecutable, DebugAdapterInlineImplementation, DebugAdapterNamedPipeServer, DebugAdapterServer, DebugConfigurationProviderTriggerKind, DebugConsoleMode, DecorationRangeBehavior, Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, Disposable, DocumentHighlight, DocumentHighlightKind, DocumentLink, DocumentSymbol, EndOfLine, EnvironmentVariableMutatorType, EvaluatableExpression, InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression, EventEmitter, ExtensionKind, ExtensionMode, FileChangeType, FileDecoration, FileSystemError, FileType, FilePermission, FoldingRange, FoldingRangeKind, FunctionBreakpoint, Hover, IndentAction, Location, MarkdownString, OverviewRulerLane, ParameterInformation, Position, ProcessExecution, ProgressLocation, QuickInputButtons, Range, RelativePattern, Selection, SelectionRange, SemanticTokens, SemanticTokensBuilder, SemanticTokensEdit, SemanticTokensEdits, SemanticTokensLegend, ShellExecution, ShellQuoting, SignatureHelp, SignatureHelpTriggerKind, SignatureInformation, SnippetString, SourceBreakpoint, StatusBarAlignment, SymbolInformation, SymbolKind, SymbolTag, Task, TaskGroup, TaskPanelKind, TaskRevealKind, TaskScope, TerminalLink, TerminalLocation, TerminalProfile, TextDocumentSaveReason, TextEdit, TextEditorCursorStyle, TextEditorLineNumbersStyle, TextEditorRevealType, TextEditorSelectionChangeKind, TextDocumentChangeReason, ThemeColor, ThemeIcon, TreeItem, TreeItemCollapsibleState, TypeHierarchyItem, UIKind, Uri, ViewColumn, WorkspaceEdit, InlayHint, InlayHintLabelPart, InlayHintKind, NotebookRange, NotebookCellKind, NotebookCellData, NotebookData, NotebookCellStatusBarAlignment, NotebookCellOutput, NotebookCellOutputItem, NotebookCellStatusBarItem, NotebookControllerAffinity, LinkedEditingRanges, TestRunRequest, TestMessage, TestTag, TestRunProfileKind, DataTransfer, DataTransferItem, LanguageStatusSeverity, QuickPickItemKind, TabInputText, TabInputTextDiff, TabInputCustom, TabInputNotebook, TabInputNotebookDiff, TabInputWebview, TabInputTerminal, InputBoxValidationSeverity, InlineCompletionList, InlineCompletionTriggerKind, InlineCompletionItem, DocumentDropEdit, NotebookEditorRevealType } = api;
export { Breakpoint, CallHierarchyIncomingCall, CallHierarchyItem, CallHierarchyOutgoingCall, CancellationError, CancellationTokenSource, CodeAction, CodeActionKind, CodeActionTriggerKind, CodeLens, Color, ColorInformation, ColorPresentation, ColorThemeKind, CommentMode, CommentThreadCollapsibleState, CompletionItem, CompletionItemKind, CompletionItemTag, CompletionList, CompletionTriggerKind, ConfigurationTarget, CustomExecution, DataTransfer, DataTransferItem, DebugAdapterExecutable, DebugAdapterInlineImplementation, DebugAdapterNamedPipeServer, DebugAdapterServer, DebugConfigurationProviderTriggerKind, DebugConsoleMode, DecorationRangeBehavior, Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, Disposable, DocumentDropEdit, DocumentHighlight, DocumentHighlightKind, DocumentLink, DocumentSymbol, EndOfLine, EnvironmentVariableMutatorType, EvaluatableExpression, EventEmitter, ExtensionKind, ExtensionMode, FileChangeType, FileDecoration, FilePermission, FileSystemError, FileType, FoldingRange, FoldingRangeKind, FunctionBreakpoint, Hover, IndentAction, InlayHint, InlayHintKind, InlayHintLabelPart, InlineCompletionItem, InlineCompletionList, InlineCompletionTriggerKind, InlineValueEvaluatableExpression, InlineValueText, InlineValueVariableLookup, InputBoxValidationSeverity, LanguageStatusSeverity, LinkedEditingRanges, Location, MarkdownString, NotebookCellData, NotebookCellKind, NotebookCellOutput, NotebookCellOutputItem, NotebookCellStatusBarAlignment, NotebookCellStatusBarItem, NotebookControllerAffinity, NotebookData, NotebookEditorRevealType, NotebookRange, OverviewRulerLane, ParameterInformation, Position, ProcessExecution, ProgressLocation, QuickInputButtons, QuickPickItemKind, Range, RelativePattern, Selection, SelectionRange, SemanticTokens, SemanticTokensBuilder, SemanticTokensEdit, SemanticTokensEdits, SemanticTokensLegend, ShellExecution, ShellQuoting, SignatureHelp, SignatureHelpTriggerKind, SignatureInformation, SnippetString, SourceBreakpoint, StatusBarAlignment, SymbolInformation, SymbolKind, SymbolTag, TabInputCustom, TabInputNotebook, TabInputNotebookDiff, TabInputTerminal, TabInputText, TabInputTextDiff, TabInputWebview, Task, TaskGroup, TaskPanelKind, TaskRevealKind, TaskScope, TerminalLink, TerminalLocation, TerminalProfile, TestMessage, TestRunProfileKind, TestRunRequest, TestTag, TextDocumentChangeReason, TextDocumentSaveReason, TextEdit, TextEditorCursorStyle, TextEditorLineNumbersStyle, TextEditorRevealType, TextEditorSelectionChangeKind, ThemeColor, ThemeIcon, TreeItem, TreeItemCollapsibleState, TypeHierarchyItem, UIKind, Uri, ViewColumn, WorkspaceEdit, authentication, commands, comments, debug, env, extensions, languages, notebooks, scm, tasks, tests, version, window$1 as window, workspace };

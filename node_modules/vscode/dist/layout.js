import { _ as __decorate, a as __param } from './contextkey.js';
import { c as IProductService } from './services2.js';
import { E as Emitter } from './polyfill.js';
import { Widget } from 'monaco-editor/esm/vs/base/browser/ui/widget.js';
import { CSSIcon, Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { Color } from 'monaco-editor/esm/vs/base/common/color.js';
import { Disposable, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { addDisposableListener, EventType, EventHelper, trackFocus, reset, getClientArea, $, hide, clearNode, isAncestor, show } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { mixin } from 'monaco-editor/esm/vs/base/common/objects.js';
import { Gesture, EventType as EventType$1 } from 'monaco-editor/esm/vs/base/browser/touch.js';
import { renderLabelWithIcons } from 'monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabels.js';
import { Action } from 'monaco-editor/esm/vs/base/common/actions.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { StandardKeyboardEvent } from 'monaco-editor/esm/vs/base/browser/keyboardEvent.js';
import { isMacintosh, isLinux, isWindows } from 'monaco-editor/esm/vs/base/common/platform.js';
import { InputBox } from 'monaco-editor/esm/vs/base/browser/ui/inputbox/inputBox.js';
import { ActionBar } from 'monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.js';
import { buttonForeground, buttonSeparator, buttonBackground, buttonHoverBackground, buttonSecondaryForeground, buttonSecondaryBackground, buttonSecondaryHoverBackground, buttonBorder, progressBarBackground, resolveColorValue, editorWidgetBackground, editorWidgetForeground, widgetShadow, contrastBorder, checkboxBorder, checkboxBackground, checkboxForeground, problemsErrorIconForeground, problemsWarningIconForeground, problemsInfoIconForeground, inputBackground, inputForeground, inputBorder, textLinkForeground } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { MarkdownRenderer } from 'monaco-editor/esm/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.js';
import Severity from 'monaco-editor/esm/vs/base/common/severity.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { ILayoutService } from 'monaco-editor/esm/vs/platform/layout/browser/layoutService.js';
import { IThemeService } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IClipboardService } from 'monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js';
import { IDialogService } from 'monaco-editor/esm/vs/platform/dialogs/common/dialogs.js';
import './missing-services.js';
import { I as IWorkbenchLayoutService } from './layoutService.js';
import { o as onServicesInitialized } from './tools.js';
import { SyncDescriptor } from 'monaco-editor/esm/vs/platform/instantiation/common/descriptors.js';
import { StandaloneServices } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js';
import { ICodeEditorService } from 'monaco-editor/esm/vs/editor/browser/services/codeEditorService.js';
var e=[],t=[];function n(n,r){if(n&&"undefined"!=typeof document){var a,s=!0===r.prepend?"prepend":"append",d=!0===r.singleTag,i="string"==typeof r.container?document.querySelector(r.container):document.getElementsByTagName("head")[0];if(d){var u=e.indexOf(i);-1===u&&(u=e.push(i)-1,t[u]={}),a=t[u]&&t[u][s]?t[u][s]:t[u][s]=c();}else a=c();65279===n.charCodeAt(0)&&(n=n.substring(1)),a.styleSheet?a.styleSheet.cssText+=n:a.appendChild(document.createTextNode(n));}function c(){var e=document.createElement("style");if(e.setAttribute("type","text/css"),r.attributes)for(var t=( Object.keys(r.attributes)),n=0;n<t.length;n++)e.setAttribute(t[n],r.attributes[t[n]]);var a="prepend"===s?"afterbegin":"beforeend";return i.insertAdjacentElement(a,e),e}}
const defaultOpts = {
    inputActiveOptionBorder: ( (Color.fromHex('#007ACC00'))),
    inputActiveOptionForeground: ( (Color.fromHex('#FFFFFF'))),
    inputActiveOptionBackground: ( (Color.fromHex('#0E639C50')))
};
class Toggle extends Widget {
    constructor(opts) {
        super();
        this._onChange = this._register(( (new Emitter())));
        this.onChange = this._onChange.event;
        this._onKeyDown = this._register(( (new Emitter())));
        this.onKeyDown = this._onKeyDown.event;
        this._opts = { ...defaultOpts, ...opts };
        this._checked = this._opts.isChecked;
        const classes = ['monaco-custom-toggle'];
        if (this._opts.icon) {
            this._icon = this._opts.icon;
            classes.push(...CSSIcon.asClassNameArray(this._icon));
        }
        if (this._opts.actionClassName) {
            classes.push(...this._opts.actionClassName.split(' '));
        }
        if (this._checked) {
            classes.push('checked');
        }
        this.domNode = document.createElement('div');
        this.domNode.title = this._opts.title;
        this.domNode.classList.add(...classes);
        if (!this._opts.notFocusable) {
            this.domNode.tabIndex = 0;
        }
        this.domNode.setAttribute('role', 'checkbox');
        this.domNode.setAttribute('aria-checked', String(this._checked));
        this.domNode.setAttribute('aria-label', this._opts.title);
        this.applyStyles();
        this.onclick(this.domNode, (ev) => {
            if (this.enabled) {
                this.checked = !this._checked;
                this._onChange.fire(false);
                ev.preventDefault();
            }
        });
        this.ignoreGesture(this.domNode);
        this.onkeydown(this.domNode, (keyboardEvent) => {
            if (keyboardEvent.keyCode === 10  || keyboardEvent.keyCode === 3 ) {
                this.checked = !this._checked;
                this._onChange.fire(true);
                keyboardEvent.preventDefault();
                keyboardEvent.stopPropagation();
                return;
            }
            this._onKeyDown.fire(keyboardEvent);
        });
    }
    get enabled() {
        return this.domNode.getAttribute('aria-disabled') !== 'true';
    }
    focus() {
        this.domNode.focus();
    }
    get checked() {
        return this._checked;
    }
    set checked(newIsChecked) {
        this._checked = newIsChecked;
        this.domNode.setAttribute('aria-checked', String(this._checked));
        this.domNode.classList.toggle('checked', this._checked);
        this.applyStyles();
    }
    setIcon(icon) {
        if (this._icon) {
            this.domNode.classList.remove(...CSSIcon.asClassNameArray(this._icon));
        }
        this._icon = icon;
        if (this._icon) {
            this.domNode.classList.add(...CSSIcon.asClassNameArray(this._icon));
        }
    }
    width() {
        return 2  + 2  + 2  + 16 ;
    }
    style(styles) {
        if (styles.inputActiveOptionBorder) {
            this._opts.inputActiveOptionBorder = styles.inputActiveOptionBorder;
        }
        if (styles.inputActiveOptionForeground) {
            this._opts.inputActiveOptionForeground = styles.inputActiveOptionForeground;
        }
        if (styles.inputActiveOptionBackground) {
            this._opts.inputActiveOptionBackground = styles.inputActiveOptionBackground;
        }
        this.applyStyles();
    }
    applyStyles() {
        if (this.domNode) {
            this.domNode.style.borderColor = this._checked && this._opts.inputActiveOptionBorder ? ( (this._opts.inputActiveOptionBorder.toString())) : '';
            this.domNode.style.color = this._checked && this._opts.inputActiveOptionForeground ? ( (this._opts.inputActiveOptionForeground.toString())) : 'inherit';
            this.domNode.style.backgroundColor = this._checked && this._opts.inputActiveOptionBackground ? ( (this._opts.inputActiveOptionBackground.toString())) : '';
        }
    }
    enable() {
        this.domNode.setAttribute('aria-disabled', String(false));
    }
    disable() {
        this.domNode.setAttribute('aria-disabled', String(true));
    }
    setTitle(newTitle) {
        this.domNode.title = newTitle;
        this.domNode.setAttribute('aria-label', newTitle);
    }
}
class Checkbox extends Widget {
    constructor(title, isChecked) {
        super();
        this.title = title;
        this.isChecked = isChecked;
        this.checkbox = ( (new Toggle(
            { title: this.title, isChecked: this.isChecked, icon: Codicon.check, actionClassName: 'monaco-checkbox' }
        )));
        this.domNode = this.checkbox.domNode;
        this.styles = {};
        this.checkbox.onChange(() => {
            this.applyStyles();
        });
    }
    get checked() {
        return this.checkbox.checked;
    }
    set checked(newIsChecked) {
        this.checkbox.checked = newIsChecked;
        this.applyStyles();
    }
    focus() {
        this.domNode.focus();
    }
    hasFocus() {
        return this.domNode === document.activeElement;
    }
    style(styles) {
        this.styles = styles;
        this.applyStyles();
    }
    applyStyles() {
        this.domNode.style.color = this.styles.checkboxForeground ? ( (this.styles.checkboxForeground.toString())) : '';
        this.domNode.style.backgroundColor = this.styles.checkboxBackground ? ( (this.styles.checkboxBackground.toString())) : '';
        this.domNode.style.borderColor = this.styles.checkboxBorder ? ( (this.styles.checkboxBorder.toString())) : '';
    }
}
function computeStyles(theme, styleMap) {
    const styles = Object.create(null);
    for (const key in styleMap) {
        const value = styleMap[key];
        if (value) {
            styles[key] = resolveColorValue(value, theme);
        }
    }
    return styles;
}
function attachStyler(themeService, styleMap, widgetOrCallback) {
    function applyStyles() {
        const styles = computeStyles(themeService.getColorTheme(), styleMap);
        if (typeof widgetOrCallback === 'function') {
            widgetOrCallback(styles);
        }
        else {
            widgetOrCallback.style(styles);
        }
    }
    applyStyles();
    return themeService.onDidColorThemeChange(applyStyles);
}
function attachButtonStyler(widget, themeService, style) {
    return attachStyler(themeService, {
        buttonForeground: style?.buttonForeground || buttonForeground,
        buttonSeparator: style?.buttonSeparator || buttonSeparator,
        buttonBackground: style?.buttonBackground || buttonBackground,
        buttonHoverBackground: style?.buttonHoverBackground || buttonHoverBackground,
        buttonSecondaryForeground: style?.buttonSecondaryForeground || buttonSecondaryForeground,
        buttonSecondaryBackground: style?.buttonSecondaryBackground || buttonSecondaryBackground,
        buttonSecondaryHoverBackground: style?.buttonSecondaryHoverBackground || buttonSecondaryHoverBackground,
        buttonBorder: style?.buttonBorder || buttonBorder,
    }, widget);
}
function attachProgressBarStyler(widget, themeService, style) {
    return attachStyler(themeService, {
        progressBarBackground: style?.progressBarBackground || progressBarBackground
    }, widget);
}
const defaultDialogStyles = {
    dialogBackground: editorWidgetBackground,
    dialogForeground: editorWidgetForeground,
    dialogShadow: widgetShadow,
    dialogBorder: contrastBorder,
    buttonForeground: buttonForeground,
    buttonSeparator: buttonSeparator,
    buttonBackground: buttonBackground,
    buttonSecondaryBackground: buttonSecondaryBackground,
    buttonSecondaryForeground: buttonSecondaryForeground,
    buttonSecondaryHoverBackground: buttonSecondaryHoverBackground,
    buttonHoverBackground: buttonHoverBackground,
    buttonBorder: buttonBorder,
    checkboxBorder: checkboxBorder,
    checkboxBackground: checkboxBackground,
    checkboxForeground: checkboxForeground,
    errorIconForeground: problemsErrorIconForeground,
    warningIconForeground: problemsWarningIconForeground,
    infoIconForeground: problemsInfoIconForeground,
    inputBackground: inputBackground,
    inputForeground: inputForeground,
    inputBorder: inputBorder,
    textLinkForeground: textLinkForeground
};
function attachDialogStyler(widget, themeService, style) {
    return attachStyler(themeService, { ...defaultDialogStyles, ...style }, widget);
}
const defaultOptions = {
    buttonBackground: ( (Color.fromHex('#0E639C'))),
    buttonHoverBackground: ( (Color.fromHex('#006BB3'))),
    buttonSeparator: Color.white,
    buttonForeground: Color.white
};
class Button extends Disposable {
    constructor(container, options) {
        super();
        this._onDidClick = this._register(( (new Emitter())));
        this.options = options || Object.create(null);
        mixin(this.options, defaultOptions, false);
        this.buttonForeground = this.options.buttonForeground;
        this.buttonBackground = this.options.buttonBackground;
        this.buttonHoverBackground = this.options.buttonHoverBackground;
        this.buttonSecondaryForeground = this.options.buttonSecondaryForeground;
        this.buttonSecondaryBackground = this.options.buttonSecondaryBackground;
        this.buttonSecondaryHoverBackground = this.options.buttonSecondaryHoverBackground;
        this.buttonBorder = this.options.buttonBorder;
        this._element = document.createElement('a');
        this._element.classList.add('monaco-button');
        this._element.tabIndex = 0;
        this._element.setAttribute('role', 'button');
        container.appendChild(this._element);
        this._register(Gesture.addTarget(this._element));
        [EventType.CLICK, EventType$1.Tap].forEach(eventType => {
            this._register(addDisposableListener(this._element, eventType, e => {
                if (!this.enabled) {
                    EventHelper.stop(e);
                    return;
                }
                this._onDidClick.fire(e);
            }));
        });
        this._register(addDisposableListener(this._element, EventType.KEY_DOWN, e => {
            const event = ( (new StandardKeyboardEvent(e)));
            let eventHandled = false;
            if (this.enabled && (event.equals(3 ) || event.equals(10 ))) {
                this._onDidClick.fire(e);
                eventHandled = true;
            }
            else if (event.equals(9 )) {
                this._element.blur();
                eventHandled = true;
            }
            if (eventHandled) {
                EventHelper.stop(event, true);
            }
        }));
        this._register(addDisposableListener(this._element, EventType.MOUSE_OVER, e => {
            if (!this._element.classList.contains('disabled')) {
                this.setHoverBackground();
            }
        }));
        this._register(addDisposableListener(this._element, EventType.MOUSE_OUT, e => {
            this.applyStyles();
        }));
        this.focusTracker = this._register(trackFocus(this._element));
        this._register(this.focusTracker.onDidFocus(() => { if (this.enabled) {
            this.setHoverBackground();
        } }));
        this._register(this.focusTracker.onDidBlur(() => { if (this.enabled) {
            this.applyStyles();
        } }));
        this.applyStyles();
    }
    get onDidClick() { return this._onDidClick.event; }
    setHoverBackground() {
        let hoverBackground;
        if (this.options.secondary) {
            hoverBackground = this.buttonSecondaryHoverBackground ? ( (this.buttonSecondaryHoverBackground.toString())) : null;
        }
        else {
            hoverBackground = this.buttonHoverBackground ? ( (this.buttonHoverBackground.toString())) : null;
        }
        if (hoverBackground) {
            this._element.style.backgroundColor = hoverBackground;
        }
    }
    style(styles) {
        this.buttonForeground = styles.buttonForeground;
        this.buttonBackground = styles.buttonBackground;
        this.buttonHoverBackground = styles.buttonHoverBackground;
        this.buttonSecondaryForeground = styles.buttonSecondaryForeground;
        this.buttonSecondaryBackground = styles.buttonSecondaryBackground;
        this.buttonSecondaryHoverBackground = styles.buttonSecondaryHoverBackground;
        this.buttonBorder = styles.buttonBorder;
        this.applyStyles();
    }
    applyStyles() {
        if (this._element) {
            let background, foreground;
            if (this.options.secondary) {
                foreground = this.buttonSecondaryForeground ? ( (this.buttonSecondaryForeground.toString())) : '';
                background = this.buttonSecondaryBackground ? ( (this.buttonSecondaryBackground.toString())) : '';
            }
            else {
                foreground = this.buttonForeground ? ( (this.buttonForeground.toString())) : '';
                background = this.buttonBackground ? ( (this.buttonBackground.toString())) : '';
            }
            const border = this.buttonBorder ? ( (this.buttonBorder.toString())) : '';
            this._element.style.color = foreground;
            this._element.style.backgroundColor = background;
            this._element.style.borderWidth = border ? '1px' : '';
            this._element.style.borderStyle = border ? 'solid' : '';
            this._element.style.borderColor = border;
        }
    }
    get element() {
        return this._element;
    }
    set label(value) {
        this._element.classList.add('monaco-text-button');
        if (this.options.supportIcons) {
            reset(this._element, ...renderLabelWithIcons(value));
        }
        else {
            this._element.textContent = value;
        }
        if (typeof this.options.title === 'string') {
            this._element.title = this.options.title;
        }
        else if (this.options.title) {
            this._element.title = value;
        }
    }
    set icon(icon) {
        this._element.classList.add(...CSSIcon.asClassNameArray(icon));
    }
    set enabled(value) {
        if (value) {
            this._element.classList.remove('disabled');
            this._element.setAttribute('aria-disabled', String(false));
            this._element.tabIndex = 0;
        }
        else {
            this._element.classList.add('disabled');
            this._element.setAttribute('aria-disabled', String(true));
        }
    }
    get enabled() {
        return !this._element.classList.contains('disabled');
    }
    focus() {
        this._element.focus();
    }
    hasFocus() {
        return this._element === document.activeElement;
    }
}
class ButtonWithDropdown extends Disposable {
    constructor(container, options) {
        super();
        this._onDidClick = this._register(( (new Emitter())));
        this.onDidClick = this._onDidClick.event;
        this.element = document.createElement('div');
        this.element.classList.add('monaco-button-dropdown');
        container.appendChild(this.element);
        this.button = this._register(( (new Button(this.element, options))));
        this._register(this.button.onDidClick(e => this._onDidClick.fire(e)));
        this.action = this._register(( (new Action(
            'primaryAction',
            this.button.label,
            undefined,
            true,
            async () => this._onDidClick.fire(undefined)
        ))));
        this.separatorContainer = document.createElement('div');
        this.separatorContainer.classList.add('monaco-button-dropdown-separator');
        this.separator = document.createElement('div');
        this.separatorContainer.appendChild(this.separator);
        this.element.appendChild(this.separatorContainer);
        this.dropdownButton = this._register(( (new Button(this.element, { ...options, title: false, supportIcons: true }))));
        this.dropdownButton.element.title = ( (localize("button dropdown more actions", 'More Actions...')));
        this.dropdownButton.element.setAttribute('aria-haspopup', 'true');
        this.dropdownButton.element.setAttribute('aria-expanded', 'false');
        this.dropdownButton.element.classList.add('monaco-dropdown-button');
        this.dropdownButton.icon = Codicon.dropDownButton;
        this._register(this.dropdownButton.onDidClick(e => {
            options.contextMenuProvider.showContextMenu({
                getAnchor: () => this.dropdownButton.element,
                getActions: () => options.addPrimaryActionToDropdown === false ? [...options.actions] : [this.action, ...options.actions],
                actionRunner: options.actionRunner,
                onHide: () => this.dropdownButton.element.setAttribute('aria-expanded', 'false')
            });
            this.dropdownButton.element.setAttribute('aria-expanded', 'true');
        }));
    }
    set label(value) {
        this.button.label = value;
        this.action.label = value;
    }
    set icon(icon) {
        this.button.icon = icon;
    }
    set enabled(enabled) {
        this.button.enabled = enabled;
        this.dropdownButton.enabled = enabled;
        this.element.classList.toggle('disabled', !enabled);
    }
    get enabled() {
        return this.button.enabled;
    }
    style(styles) {
        this.button.style(styles);
        this.dropdownButton.style(styles);
        const border = styles.buttonBorder ? ( (styles.buttonBorder.toString())) : '';
        this.separatorContainer.style.borderTopWidth = border ? '1px' : '';
        this.separatorContainer.style.borderTopStyle = border ? 'solid' : '';
        this.separatorContainer.style.borderTopColor = border;
        this.separatorContainer.style.borderBottomWidth = border ? '1px' : '';
        this.separatorContainer.style.borderBottomStyle = border ? 'solid' : '';
        this.separatorContainer.style.borderBottomColor = border;
        this.separatorContainer.style.backgroundColor = styles.buttonBackground?.toString() ?? '';
        this.separator.style.backgroundColor = styles.buttonSeparator?.toString() ?? '';
    }
    focus() {
        this.button.focus();
    }
    hasFocus() {
        return this.button.hasFocus() || this.dropdownButton.hasFocus();
    }
}
class ButtonWithDescription extends Button {
    constructor(container, options) {
        super(container, options);
        this._element.classList.add('monaco-description-button');
        this._labelElement = document.createElement('div');
        this._labelElement.classList.add('monaco-button-label');
        this._element.appendChild(this._labelElement);
        this._descriptionElement = document.createElement('div');
        this._descriptionElement.classList.add('monaco-button-description');
        this._element.appendChild(this._descriptionElement);
    }
    set label(value) {
        this._element.classList.add('monaco-text-button');
        if (this.options.supportIcons) {
            reset(this._labelElement, ...renderLabelWithIcons(value));
        }
        else {
            this._labelElement.textContent = value;
        }
        if (typeof this.options.title === 'string') {
            this._element.title = this.options.title;
        }
        else if (this.options.title) {
            this._element.title = value;
        }
    }
    set description(value) {
        if (this.options.supportIcons) {
            reset(this._descriptionElement, ...renderLabelWithIcons(value));
        }
        else {
            this._descriptionElement.textContent = value;
        }
    }
}
class ButtonBar extends Disposable {
    constructor(container) {
        super();
        this.container = container;
        this._buttons = [];
    }
    get buttons() {
        return this._buttons;
    }
    addButton(options) {
        const button = this._register(( (new Button(this.container, options))));
        this.pushButton(button);
        return button;
    }
    addButtonWithDescription(options) {
        const button = this._register(( (new ButtonWithDescription(this.container, options))));
        this.pushButton(button);
        return button;
    }
    addButtonWithDropdown(options) {
        const button = this._register(( (new ButtonWithDropdown(this.container, options))));
        this.pushButton(button);
        return button;
    }
    pushButton(button) {
        this._buttons.push(button);
        const index = this._buttons.length - 1;
        this._register(addDisposableListener(button.element, EventType.KEY_DOWN, e => {
            const event = ( (new StandardKeyboardEvent(e)));
            let eventHandled = true;
            let buttonIndexToFocus;
            if (event.equals(15 )) {
                buttonIndexToFocus = index > 0 ? index - 1 : this._buttons.length - 1;
            }
            else if (event.equals(17 )) {
                buttonIndexToFocus = index === this._buttons.length - 1 ? 0 : index + 1;
            }
            else {
                eventHandled = false;
            }
            if (eventHandled && typeof buttonIndexToFocus === 'number') {
                this._buttons[buttonIndexToFocus].focus();
                EventHelper.stop(e, true);
            }
        }));
    }
}
function mnemonicButtonLabel(label, forceDisableMnemonics) {
    if (isMacintosh || forceDisableMnemonics) {
        return label.replace(/\(&&\w\)|&&/g, '');
    }
    if (isWindows) {
        return label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');
    }
    return label.replace(/&&/g, '_');
}
var css = "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/** Dialog: Modal Block */\n.monaco-dialog-modal-block {\n\tposition: fixed;\n\theight: 100%;\n\twidth: 100%;\n\tleft:0;\n\ttop:0;\n\tz-index: 2600;\n\tdisplay: flex;\n\tjustify-content: center;\n\talign-items: center;\n}\n\n.monaco-dialog-modal-block.dimmed {\n\tbackground: rgba(0, 0, 0, 0.3);\n}\n\n/** Dialog: Container */\n.monaco-dialog-box {\n\tdisplay: flex;\n\tflex-direction: column-reverse;\n\twidth: min-content;\n\tmin-width: 500px;\n\tmax-width: 90vw;\n\tmin-height: 75px;\n\tpadding: 10px;\n\ttransform: translate3d(0px, 0px, 0px);\n}\n\n/** Dialog: Title Actions Row */\n.monaco-dialog-box .dialog-toolbar-row {\n\theight: 22px;\n\tpadding-bottom: 4px;\n}\n\n.monaco-dialog-box .dialog-toolbar-row .actions-container {\n\tjustify-content: flex-end;\n}\n\n/** Dialog: Message Row */\n.monaco-dialog-box .dialog-message-row {\n\tdisplay: flex;\n\tflex-grow: 1;\n\talign-items: center;\n\tpadding: 0 10px;\n}\n\n.monaco-dialog-box .dialog-message-row > .dialog-icon.codicon {\n\tflex: 0 0 48px;\n\theight: 48px;\n\talign-self: baseline;\n\tfont-size: 48px;\n}\n\n/** Dialog: Message Container */\n.monaco-dialog-box .dialog-message-row .dialog-message-container {\n\tdisplay: flex;\n\tflex-direction: column;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\tpadding-left: 24px;\n\tuser-select: text;\n\t-webkit-user-select: text;\n\t-ms-user-select: text;\n\tword-wrap: break-word; /* never overflow long words, but break to next line */\n\twhite-space: normal;\n}\n\n/** Dialog: Message */\n.monaco-dialog-box .dialog-message-row .dialog-message-container .dialog-message {\n\tline-height: 22px;\n\tfont-size: 18px;\n\tflex: 1; /* let the message always grow */\n\twhite-space: normal;\n\tword-wrap: break-word; /* never overflow long words, but break to next line */\n\tmin-height: 48px; /* matches icon height */\n\tmargin-bottom: 8px;\n\tdisplay: flex;\n\talign-items: center;\n}\n\n/** Dialog: Details */\n.monaco-dialog-box .dialog-message-row .dialog-message-container .dialog-message-detail {\n\tline-height: 22px;\n\tflex: 1; /* let the message always grow */\n}\n\n.monaco-dialog-box .dialog-message-row .dialog-message-container .dialog-message a:focus {\n\toutline-width: 1px;\n\toutline-style: solid;\n}\n\n/** Dialog: Checkbox */\n.monaco-dialog-box .dialog-message-row .dialog-message-container .dialog-checkbox-row {\n\tpadding: 15px 0px 0px;\n\tdisplay: flex;\n}\n\n.monaco-dialog-box .dialog-message-row .dialog-message-container .dialog-checkbox-row .dialog-checkbox-message {\n\tcursor: pointer;\n\tuser-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n}\n\n/** Dialog: Input */\n.monaco-dialog-box .dialog-message-row .dialog-message-container .dialog-message-input {\n\tpadding: 15px 0px 0px;\n\tdisplay: flex;\n}\n\n.monaco-dialog-box .dialog-message-row .dialog-message-container .dialog-message-input .monaco-inputbox {\n\tflex: 1;\n}\n\n/** Dialog: File Path */\n.monaco-dialog-box code {\n\tfont-family: var(--monaco-monospace-font);\n}\n\n/** Dialog: Buttons Row */\n.monaco-dialog-box > .dialog-buttons-row {\n\tdisplay: flex;\n\talign-items: center;\n\tpadding-right: 1px;\n\toverflow: hidden; /* buttons row should never overflow */\n}\n\n.monaco-dialog-box > .dialog-buttons-row {\n\tdisplay: flex;\n\twhite-space: nowrap;\n\tpadding: 20px 10px 10px;\n}\n\n/** Dialog: Buttons */\n.monaco-dialog-box > .dialog-buttons-row > .dialog-buttons {\n\tdisplay: flex;\n\twidth: 100%;\n\tjustify-content: flex-end;\n\toverflow: hidden;\n\tmargin-left: 67px; /* for long buttons, force align with text */\n}\n\n.monaco-dialog-box > .dialog-buttons-row > .dialog-buttons > .monaco-button {\n\twidth: fit-content;\n\twidth: -moz-fit-content;\n\tpadding: 5px 10px;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\tmargin: 4px 5px; /* allows button focus outline to be visible */\n\toutline-offset: 2px !important;\n}\n";
n(css,{});
class Dialog extends Disposable {
    constructor(container, message, buttons, options) {
        super();
        this.container = container;
        this.message = message;
        this.options = options;
        this.modalElement = this.container.appendChild($(`.monaco-dialog-modal-block.dimmed`));
        this.shadowElement = this.modalElement.appendChild($('.dialog-shadow'));
        this.element = this.shadowElement.appendChild($('.monaco-dialog-box'));
        this.element.setAttribute('role', 'dialog');
        this.element.tabIndex = -1;
        hide(this.element);
        if (Array.isArray(buttons) && buttons.length > 0) {
            this.buttons = buttons;
        }
        else if (!this.options.disableDefaultAction) {
            this.buttons = [( (localize('ok', "OK")))];
        }
        else {
            this.buttons = [];
        }
        const buttonsRowElement = this.element.appendChild($('.dialog-buttons-row'));
        this.buttonsContainer = buttonsRowElement.appendChild($('.dialog-buttons'));
        const messageRowElement = this.element.appendChild($('.dialog-message-row'));
        this.iconElement = messageRowElement.appendChild($('#monaco-dialog-icon.dialog-icon'));
        this.iconElement.setAttribute('aria-label', this.getIconAriaLabel());
        this.messageContainer = messageRowElement.appendChild($('.dialog-message-container'));
        if (this.options.detail || this.options.renderBody) {
            const messageElement = this.messageContainer.appendChild($('.dialog-message'));
            const messageTextElement = messageElement.appendChild($('#monaco-dialog-message-text.dialog-message-text'));
            messageTextElement.innerText = this.message;
        }
        this.messageDetailElement = this.messageContainer.appendChild($('#monaco-dialog-message-detail.dialog-message-detail'));
        if (this.options.detail || !this.options.renderBody) {
            this.messageDetailElement.innerText = this.options.detail ? this.options.detail : message;
        }
        else {
            this.messageDetailElement.style.display = 'none';
        }
        if (this.options.renderBody) {
            const customBody = this.messageContainer.appendChild($('#monaco-dialog-message-body.dialog-message-body'));
            this.options.renderBody(customBody);
            for (const el of this.messageContainer.querySelectorAll('a')) {
                el.tabIndex = 0;
            }
        }
        if (this.options.inputs) {
            this.inputs = this.options.inputs.map(input => {
                const inputRowElement = this.messageContainer.appendChild($('.dialog-message-input'));
                const inputBox = this._register(( (new InputBox(inputRowElement, undefined, {
                    placeholder: input.placeholder,
                    type: input.type ?? 'text',
                }))));
                if (input.value) {
                    inputBox.value = input.value;
                }
                return inputBox;
            });
        }
        else {
            this.inputs = [];
        }
        if (this.options.checkboxLabel) {
            const checkboxRowElement = this.messageContainer.appendChild($('.dialog-checkbox-row'));
            const checkbox = this.checkbox = this._register(( (new Checkbox(this.options.checkboxLabel, !!this.options.checkboxChecked))));
            checkboxRowElement.appendChild(checkbox.domNode);
            const checkboxMessageElement = checkboxRowElement.appendChild($('.dialog-checkbox-message'));
            checkboxMessageElement.innerText = this.options.checkboxLabel;
            this._register(addDisposableListener(checkboxMessageElement, EventType.CLICK, () => checkbox.checked = !checkbox.checked));
        }
        const toolbarRowElement = this.element.appendChild($('.dialog-toolbar-row'));
        this.toolbarContainer = toolbarRowElement.appendChild($('.dialog-toolbar'));
    }
    getIconAriaLabel() {
        const typeLabel = ( (localize('dialogInfoMessage', 'Info')));
        return typeLabel;
    }
    updateMessage(message) {
        this.messageDetailElement.innerText = message;
    }
    async show() {
        this.focusToReturn = document.activeElement;
        return (
             (new Promise((resolve) => {
                clearNode(this.buttonsContainer);
                const buttonBar = this.buttonBar = this._register(( (new ButtonBar(this.buttonsContainer))));
                const buttonMap = this.rearrangeButtons(this.buttons, this.options.cancelId);
                buttonMap.forEach((entry, index) => {
                    const primary = buttonMap[index].index === 0;
                    const button = this.options.buttonDetails ? this._register(buttonBar.addButtonWithDescription({ title: true, secondary: !primary })) : this._register(buttonBar.addButton({ title: true, secondary: !primary }));
                    button.label = mnemonicButtonLabel(buttonMap[index].label, true);
                    if (button instanceof ButtonWithDescription) {
                        button.description = this.options.buttonDetails[buttonMap[index].index];
                    }
                    this._register(button.onDidClick(e => {
                        if (e) {
                            EventHelper.stop(e);
                        }
                        resolve({
                            button: buttonMap[index].index,
                            checkboxChecked: this.checkbox ? this.checkbox.checked : undefined,
                            values: this.inputs.length > 0 ? this.inputs.map(input => input.value) : undefined
                        });
                    }));
                });
                this._register(addDisposableListener(window, 'keydown', e => {
                    const evt = ( (new StandardKeyboardEvent(e)));
                    if (evt.equals(512 )) {
                        evt.preventDefault();
                    }
                    if (evt.equals(3 )) {
                        if (this.inputs.some(input => input.hasFocus())) {
                            EventHelper.stop(e);
                            resolve({
                                button: buttonMap.find(button => button.index !== this.options.cancelId)?.index ?? 0,
                                checkboxChecked: this.checkbox ? this.checkbox.checked : undefined,
                                values: this.inputs.length > 0 ? this.inputs.map(input => input.value) : undefined
                            });
                        }
                        return;
                    }
                    if (evt.equals(10 )) {
                        return;
                    }
                    let eventHandled = false;
                    if (evt.equals(2 ) || evt.equals(17 ) || evt.equals(1024  | 2 ) || evt.equals(15 )) {
                        const focusableElements = [];
                        let focusedIndex = -1;
                        if (this.messageContainer) {
                            const links = this.messageContainer.querySelectorAll('a');
                            for (const link of links) {
                                focusableElements.push(link);
                                if (link === document.activeElement) {
                                    focusedIndex = focusableElements.length - 1;
                                }
                            }
                        }
                        for (const input of this.inputs) {
                            focusableElements.push(input);
                            if (input.hasFocus()) {
                                focusedIndex = focusableElements.length - 1;
                            }
                        }
                        if (this.checkbox) {
                            focusableElements.push(this.checkbox);
                            if (this.checkbox.hasFocus()) {
                                focusedIndex = focusableElements.length - 1;
                            }
                        }
                        if (this.buttonBar) {
                            for (const button of this.buttonBar.buttons) {
                                focusableElements.push(button);
                                if (button.hasFocus()) {
                                    focusedIndex = focusableElements.length - 1;
                                }
                            }
                        }
                        if (evt.equals(2 ) || evt.equals(17 )) {
                            if (focusedIndex === -1) {
                                focusedIndex = 0;
                            }
                            const newFocusedIndex = (focusedIndex + 1) % focusableElements.length;
                            focusableElements[newFocusedIndex].focus();
                        }
                        else {
                            if (focusedIndex === -1) {
                                focusedIndex = focusableElements.length;
                            }
                            let newFocusedIndex = focusedIndex - 1;
                            if (newFocusedIndex === -1) {
                                newFocusedIndex = focusableElements.length - 1;
                            }
                            focusableElements[newFocusedIndex].focus();
                        }
                        eventHandled = true;
                    }
                    if (eventHandled) {
                        EventHelper.stop(e, true);
                    }
                    else if (this.options.keyEventProcessor) {
                        this.options.keyEventProcessor(evt);
                    }
                }, true));
                this._register(addDisposableListener(window, 'keyup', e => {
                    EventHelper.stop(e, true);
                    const evt = ( (new StandardKeyboardEvent(e)));
                    if (!this.options.disableCloseAction && evt.equals(9 )) {
                        resolve({
                            button: this.options.cancelId || 0,
                            checkboxChecked: this.checkbox ? this.checkbox.checked : undefined
                        });
                    }
                }, true));
                this._register(addDisposableListener(this.element, 'focusout', e => {
                    if (!!e.relatedTarget && !!this.element) {
                        if (!isAncestor(e.relatedTarget, this.element)) {
                            this.focusToReturn = e.relatedTarget;
                            if (e.target) {
                                e.target.focus();
                                EventHelper.stop(e, true);
                            }
                        }
                    }
                }, false));
                const spinModifierClassName = 'codicon-modifier-spin';
                this.iconElement.classList.remove(...Codicon.dialogError.classNamesArray, ...Codicon.dialogWarning.classNamesArray, ...Codicon.dialogInfo.classNamesArray, ...Codicon.loading.classNamesArray, spinModifierClassName);
                if (this.options.icon) {
                    this.iconElement.classList.add(...this.options.icon.classNamesArray);
                }
                else {
                    switch (this.options.type) {
                        case 'error':
                            this.iconElement.classList.add(...Codicon.dialogError.classNamesArray);
                            break;
                        case 'warning':
                            this.iconElement.classList.add(...Codicon.dialogWarning.classNamesArray);
                            break;
                        case 'pending':
                            this.iconElement.classList.add(...Codicon.loading.classNamesArray, spinModifierClassName);
                            break;
                        case 'none':
                        case 'info':
                        case 'question':
                        default:
                            this.iconElement.classList.add(...Codicon.dialogInfo.classNamesArray);
                            break;
                    }
                }
                if (!this.options.disableCloseAction) {
                    const actionBar = this._register(( (new ActionBar(this.toolbarContainer, {}))));
                    const action = this._register(( (new Action(
                        'dialog.close',
                         (localize('dialogClose', "Close Dialog")),
                        Codicon.dialogClose.classNames,
                        true,
                        async () => {
                            resolve({
                                button: this.options.cancelId || 0,
                                checkboxChecked: this.checkbox ? this.checkbox.checked : undefined
                            });
                        }
                    ))));
                    actionBar.push(action, { icon: true, label: false, });
                }
                this.applyStyles();
                this.element.setAttribute('aria-modal', 'true');
                this.element.setAttribute('aria-labelledby', 'monaco-dialog-icon monaco-dialog-message-text');
                this.element.setAttribute('aria-describedby', 'monaco-dialog-icon monaco-dialog-message-text monaco-dialog-message-detail monaco-dialog-message-body');
                show(this.element);
                if (this.inputs.length > 0) {
                    this.inputs[0].focus();
                    this.inputs[0].select();
                }
                else {
                    buttonMap.forEach((value, index) => {
                        if (value.index === 0) {
                            buttonBar.buttons[index].focus();
                        }
                    });
                }
            }))
        );
    }
    applyStyles() {
        if (this.styles) {
            const style = this.styles;
            const fgColor = style.dialogForeground;
            const bgColor = style.dialogBackground;
            const shadowColor = style.dialogShadow ? `0 0px 8px ${style.dialogShadow}` : '';
            const border = style.dialogBorder ? `1px solid ${style.dialogBorder}` : '';
            const linkFgColor = style.textLinkForeground;
            this.shadowElement.style.boxShadow = shadowColor;
            this.element.style.color = fgColor?.toString() ?? '';
            this.element.style.backgroundColor = bgColor?.toString() ?? '';
            this.element.style.border = border;
            this.buttonBar?.buttons.forEach(button => button.style(style));
            this.checkbox?.style(style);
            if (fgColor && bgColor) {
                const messageDetailColor = ( (fgColor.transparent(.9)));
                this.messageDetailElement.style.color = ( (messageDetailColor.makeOpaque(bgColor).toString()));
            }
            if (linkFgColor) {
                for (const el of this.messageContainer.getElementsByTagName('a')) {
                    el.style.color = ( (linkFgColor.toString()));
                }
            }
            let color;
            switch (this.options.type) {
                case 'error':
                    color = style.errorIconForeground;
                    break;
                case 'warning':
                    color = style.warningIconForeground;
                    break;
                default:
                    color = style.infoIconForeground;
                    break;
            }
            if (color) {
                this.iconElement.style.color = ( (color.toString()));
            }
            for (const input of this.inputs) {
                input.style(style);
            }
        }
    }
    style(style) {
        this.styles = style;
        this.applyStyles();
    }
    dispose() {
        super.dispose();
        if (this.modalElement) {
            this.modalElement.remove();
            this.modalElement = undefined;
        }
        if (this.focusToReturn && isAncestor(this.focusToReturn, document.body)) {
            this.focusToReturn.focus();
            this.focusToReturn = undefined;
        }
    }
    rearrangeButtons(buttons, cancelId) {
        const buttonMap = [];
        if (buttons.length === 0) {
            return buttonMap;
        }
        buttons.forEach((button, index) => {
            buttonMap.push({ label: button, index });
        });
        if (isMacintosh || isLinux) {
            if (cancelId !== undefined && cancelId < buttons.length) {
                const cancelButton = buttonMap.splice(cancelId, 1)[0];
                buttonMap.reverse();
                buttonMap.splice(buttonMap.length - 1, 0, cancelButton);
            }
        }
        return buttonMap;
    }
}
const minute = 60;
const hour = minute * 60;
const day = hour * 24;
const week = day * 7;
const month = day * 30;
const year = day * 365;
function fromNow(date, appendAgoLabel, useFullTimeWords) {
    if (typeof date !== 'number') {
        date = date.getTime();
    }
    const seconds = Math.round((( (new Date())).getTime() - date) / 1000);
    if (seconds < -30) {
        return (
             (localize(
                'date.fromNow.in',
                'in {0}',
                fromNow(( (new Date())).getTime() + seconds * 1000, false)
            ))
        );
    }
    if (seconds < 30) {
        return (
             (localize('date.fromNow.now', 'now'))
        );
    }
    let value;
    if (seconds < minute) {
        value = seconds;
        if (appendAgoLabel) {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.seconds.singular.ago.fullWord', '{0} second ago', value)))
                    : ( (localize('date.fromNow.seconds.singular.ago', '{0} sec ago', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.seconds.plural.ago.fullWord', '{0} seconds ago', value)))
                    : ( (localize('date.fromNow.seconds.plural.ago', '{0} secs ago', value)));
            }
        }
        else {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.seconds.singular.fullWord', '{0} second', value)))
                    : ( (localize('date.fromNow.seconds.singular', '{0} sec', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.seconds.plural.fullWord', '{0} seconds', value)))
                    : ( (localize('date.fromNow.seconds.plural', '{0} secs', value)));
            }
        }
    }
    if (seconds < hour) {
        value = Math.floor(seconds / minute);
        if (appendAgoLabel) {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.minutes.singular.ago.fullWord', '{0} minute ago', value)))
                    : ( (localize('date.fromNow.minutes.singular.ago', '{0} min ago', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.minutes.plural.ago.fullWord', '{0} minutes ago', value)))
                    : ( (localize('date.fromNow.minutes.plural.ago', '{0} mins ago', value)));
            }
        }
        else {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.minutes.singular.fullWord', '{0} minute', value)))
                    : ( (localize('date.fromNow.minutes.singular', '{0} min', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.minutes.plural.fullWord', '{0} minutes', value)))
                    : ( (localize('date.fromNow.minutes.plural', '{0} mins', value)));
            }
        }
    }
    if (seconds < day) {
        value = Math.floor(seconds / hour);
        if (appendAgoLabel) {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.hours.singular.ago.fullWord', '{0} hour ago', value)))
                    : ( (localize('date.fromNow.hours.singular.ago', '{0} hr ago', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.hours.plural.ago.fullWord', '{0} hours ago', value)))
                    : ( (localize('date.fromNow.hours.plural.ago', '{0} hrs ago', value)));
            }
        }
        else {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.hours.singular.fullWord', '{0} hour', value)))
                    : ( (localize('date.fromNow.hours.singular', '{0} hr', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.hours.plural.fullWord', '{0} hours', value)))
                    : ( (localize('date.fromNow.hours.plural', '{0} hrs', value)));
            }
        }
    }
    if (seconds < week) {
        value = Math.floor(seconds / day);
        if (appendAgoLabel) {
            return value === 1
                ? ( (localize('date.fromNow.days.singular.ago', '{0} day ago', value)))
                : ( (localize('date.fromNow.days.plural.ago', '{0} days ago', value)));
        }
        else {
            return value === 1
                ? ( (localize('date.fromNow.days.singular', '{0} day', value)))
                : ( (localize('date.fromNow.days.plural', '{0} days', value)));
        }
    }
    if (seconds < month) {
        value = Math.floor(seconds / week);
        if (appendAgoLabel) {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.weeks.singular.ago.fullWord', '{0} week ago', value)))
                    : ( (localize('date.fromNow.weeks.singular.ago', '{0} wk ago', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.weeks.plural.ago.fullWord', '{0} weeks ago', value)))
                    : ( (localize('date.fromNow.weeks.plural.ago', '{0} wks ago', value)));
            }
        }
        else {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.weeks.singular.fullWord', '{0} week', value)))
                    : ( (localize('date.fromNow.weeks.singular', '{0} wk', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.weeks.plural.fullWord', '{0} weeks', value)))
                    : ( (localize('date.fromNow.weeks.plural', '{0} wks', value)));
            }
        }
    }
    if (seconds < year) {
        value = Math.floor(seconds / month);
        if (appendAgoLabel) {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.months.singular.ago.fullWord', '{0} month ago', value)))
                    : ( (localize('date.fromNow.months.singular.ago', '{0} mo ago', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.months.plural.ago.fullWord', '{0} months ago', value)))
                    : ( (localize('date.fromNow.months.plural.ago', '{0} mos ago', value)));
            }
        }
        else {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.months.singular.fullWord', '{0} month', value)))
                    : ( (localize('date.fromNow.months.singular', '{0} mo', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.months.plural.fullWord', '{0} months', value)))
                    : ( (localize('date.fromNow.months.plural', '{0} mos', value)));
            }
        }
    }
    value = Math.floor(seconds / year);
    if (appendAgoLabel) {
        if (value === 1) {
            return useFullTimeWords
                ? ( (localize('date.fromNow.years.singular.ago.fullWord', '{0} year ago', value)))
                : ( (localize('date.fromNow.years.singular.ago', '{0} yr ago', value)));
        }
        else {
            return useFullTimeWords
                ? ( (localize('date.fromNow.years.plural.ago.fullWord', '{0} years ago', value)))
                : ( (localize('date.fromNow.years.plural.ago', '{0} yrs ago', value)));
        }
    }
    else {
        if (value === 1) {
            return useFullTimeWords
                ? ( (localize('date.fromNow.years.singular.fullWord', '{0} year', value)))
                : ( (localize('date.fromNow.years.singular', '{0} yr', value)));
        }
        else {
            return useFullTimeWords
                ? ( (localize('date.fromNow.years.plural.fullWord', '{0} years', value)))
                : ( (localize('date.fromNow.years.plural', '{0} yrs', value)));
        }
    }
}
let BrowserDialogHandler = class BrowserDialogHandler {
    constructor(logService, layoutService, themeService, keybindingService, instantiationService, productService, clipboardService) {
        this.logService = logService;
        this.layoutService = layoutService;
        this.themeService = themeService;
        this.keybindingService = keybindingService;
        this.instantiationService = instantiationService;
        this.productService = productService;
        this.clipboardService = clipboardService;
        this.markdownRenderer = this.instantiationService.createInstance(MarkdownRenderer, {});
    }
    async confirm(confirmation) {
        this.logService.trace('DialogService#confirm', confirmation.message);
        const buttons = [];
        if (confirmation.primaryButton) {
            buttons.push(confirmation.primaryButton);
        }
        else {
            buttons.push(( (localize({ key: 'yesButton', comment: ['&& denotes a mnemonic'] }, "&&Yes"))));
        }
        if (confirmation.secondaryButton) {
            buttons.push(confirmation.secondaryButton);
        }
        else if (typeof confirmation.secondaryButton === 'undefined') {
            buttons.push(( (localize('cancelButton', "Cancel"))));
        }
        const result = await this.doShow(confirmation.type, confirmation.message, buttons, confirmation.detail, 1, confirmation.checkbox);
        return { confirmed: result.button === 0, checkboxChecked: result.checkboxChecked };
    }
    getDialogType(severity) {
        return (severity === Severity.Info) ? 'question' : (severity === Severity.Error) ? 'error' : (severity === Severity.Warning) ? 'warning' : 'none';
    }
    async show(severity, message, buttons, options) {
        this.logService.trace('DialogService#show', message);
        const result = await this.doShow(this.getDialogType(severity), message, buttons, options?.detail, options?.cancelId, options?.checkbox, undefined, typeof options?.custom === 'object' ? options.custom : undefined);
        return {
            choice: result.button,
            checkboxChecked: result.checkboxChecked
        };
    }
    async doShow(type, message, buttons, detail, cancelId, checkbox, inputs, customOptions) {
        const dialogDisposables = ( (new DisposableStore()));
        const renderBody = customOptions ? (parent) => {
            parent.classList.add(...(customOptions.classes || []));
            customOptions.markdownDetails?.forEach(markdownDetail => {
                const result = this.markdownRenderer.render(markdownDetail.markdown);
                parent.appendChild(result.element);
                result.element.classList.add(...(markdownDetail.classes || []));
                dialogDisposables.add(result);
            });
        } : undefined;
        const dialog = ( (new Dialog(this.layoutService.container, message, buttons, {
            detail,
            cancelId,
            type,
            keyEventProcessor: (event) => {
                const resolved = this.keybindingService.softDispatch(event, this.layoutService.container);
                if (resolved?.commandId) {
                    if (BrowserDialogHandler.ALLOWABLE_COMMANDS.indexOf(resolved.commandId) === -1) {
                        EventHelper.stop(event, true);
                    }
                }
            },
            renderBody,
            icon: customOptions?.icon,
            disableCloseAction: customOptions?.disableCloseAction,
            buttonDetails: customOptions?.buttonDetails,
            checkboxLabel: checkbox?.label,
            checkboxChecked: checkbox?.checked,
            inputs
        })));
        dialogDisposables.add(dialog);
        dialogDisposables.add(attachDialogStyler(dialog, this.themeService));
        const result = await dialog.show();
        dialogDisposables.dispose();
        return result;
    }
    async input(severity, message, buttons, inputs, options) {
        this.logService.trace('DialogService#input', message);
        const result = await this.doShow(this.getDialogType(severity), message, buttons, options?.detail, options?.cancelId, options?.checkbox, inputs);
        return {
            choice: result.button,
            checkboxChecked: result.checkboxChecked,
            values: result.values
        };
    }
    async about() {
        const detailString = (useAgo) => {
            return (
                 (localize(
                    'aboutDetail',
                    "Version: {0}\nCommit: {1}\nDate: {2}\nBrowser: {3}",
                    this.productService.version || 'Unknown',
                    this.productService.commit || 'Unknown',
                    this.productService.date ? `${this.productService.date}${useAgo ? ' (' + fromNow(( new Date(this.productService.date)), true) + ')' : ''}` : 'Unknown',
                    navigator.userAgent
                ))
            );
        };
        const detail = detailString(true);
        const detailToCopy = detailString(false);
        const { choice } = await this.show(Severity.Info, this.productService.nameLong, [( (localize('copy', "Copy"))), ( (localize('ok', "OK")))], { detail, cancelId: 1 });
        if (choice === 0) {
            this.clipboardService.writeText(detailToCopy);
        }
    }
};
BrowserDialogHandler.ALLOWABLE_COMMANDS = [
    'copy',
    'cut',
    'editor.action.selectAll',
    'editor.action.clipboardCopyAction',
    'editor.action.clipboardCutAction',
    'editor.action.clipboardPasteAction'
];
BrowserDialogHandler = ( (__decorate([
    ( (__param(0, ILogService))),
    ( (__param(1, ILayoutService))),
    ( (__param(2, IThemeService))),
    ( (__param(3, IKeybindingService))),
    ( (__param(4, IInstantiationService))),
    ( (__param(5, IProductService))),
    ( (__param(6, IClipboardService)))
], BrowserDialogHandler)));
let DialogHandlerContribution = class DialogHandlerContribution extends Disposable {
    constructor(dialogService, logService, layoutService, themeService, keybindingService, instantiationService, productService, clipboardService) {
        super();
        this.dialogService = dialogService;
        this.impl = ( (new BrowserDialogHandler(
            logService,
            layoutService,
            themeService,
            keybindingService,
            instantiationService,
            productService,
            clipboardService
        )));
        this.model = this.dialogService.model;
        this._register(this.model.onWillShowDialog(() => {
            if (!this.currentDialog) {
                this.processDialogs();
            }
        }));
        this.processDialogs();
    }
    async processDialogs() {
        while (this.model.dialogs.length) {
            this.currentDialog = this.model.dialogs[0];
            let result = undefined;
            if (this.currentDialog.args.confirmArgs) {
                const args = this.currentDialog.args.confirmArgs;
                result = await this.impl.confirm(args.confirmation);
            }
            else if (this.currentDialog.args.inputArgs) {
                const args = this.currentDialog.args.inputArgs;
                result = await this.impl.input(args.severity, args.message, args.buttons, args.inputs, args.options);
            }
            else if (this.currentDialog.args.showArgs) {
                const args = this.currentDialog.args.showArgs;
                result = await this.impl.show(args.severity, args.message, args.buttons, args.options);
            }
            else {
                await this.impl.about();
            }
            this.currentDialog.close(result);
            this.currentDialog = undefined;
        }
    }
};
DialogHandlerContribution = ( (__decorate([
    ( (__param(0, IDialogService))),
    ( (__param(1, ILogService))),
    ( (__param(2, ILayoutService))),
    ( (__param(3, IThemeService))),
    ( (__param(4, IKeybindingService))),
    ( (__param(5, IInstantiationService))),
    ( (__param(6, IProductService))),
    ( (__param(7, IClipboardService)))
], DialogHandlerContribution)));
class LayoutService {
    constructor(container) {
        this.container = container;
        this.offset = { top: 0, quickPickTop: 0 };
        this._onDidLayout = new Emitter();
        this.onDidLayout = this._onDidLayout.event;
        window.addEventListener('resize', () => this.layout());
        this.layout();
    }
    isVisible() {
        return false;
    }
    get dimension() { return this._dimension; }
    layout() {
        this._dimension = getClientArea(window.document.body);
        this._onDidLayout.fire(this._dimension);
    }
    get hasContainer() {
        return true;
    }
    focus() {
        StandaloneServices.get(ICodeEditorService).getFocusedCodeEditor()?.focus();
    }
}
function initialize(instantiationService) {
    const container = instantiationService.invokeFunction((accessor) => accessor.get(ILayoutService)).container;
    container.classList.add('monaco-workbench');
}
function getServiceOverride(container = document.body) {
    onServicesInitialized(initialize);
    return {
        [( ILayoutService.toString())]: new SyncDescriptor(LayoutService, [container]),
        [( IWorkbenchLayoutService.toString())]: new SyncDescriptor(LayoutService, [container])
    };
}
export { ButtonBar as B, DialogHandlerContribution as D, attachButtonStyler as a, attachProgressBarStyler as b, getServiceOverride as g, n };

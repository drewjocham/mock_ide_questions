import { _ as __decorate, a as __param } from './contextkey.js';
import { E as Emitter, U as UserSettings } from './polyfill.js';
import { e as IUserDataProfilesService, f as IPolicyService, N as NullPolicyService } from './missing-services.js';
import { b as isEmptyObject } from './types.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { Extensions, machineOverridableSettings, windowSettings, resourceSettings, allSettings, OVERRIDE_PROPERTY_PATTERN, resourceLanguageSettingsSchemaId, OVERRIDE_PROPERTY_REGEX, overrideIdentifiersFromKey, applicationSettings, machineSettings } from 'monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js';
import { Configuration, ConfigurationModel, ConfigurationChangeEvent } from 'monaco-editor/esm/vs/platform/configuration/common/configurationModels.js';
import { IConfigurationService, addToValueTree, toValuesTree } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { coalesce } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { equals } from 'monaco-editor/esm/vs/base/common/objects.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { isArray } from 'monaco-editor/esm/vs/base/common/types.js';
import { extUriBiasedIgnorePathCase } from 'monaco-editor/esm/vs/base/common/resources.js';
import { RunOnceScheduler } from 'monaco-editor/esm/vs/base/common/async.js';
import { bf as Position$2, bg as configurationDefaultsSchemaId } from './extHost.js';
export { bh as ConfigurationScope } from './extHost.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { i as IFileService, j as IWorkbenchEnvironmentService } from './services2.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { IWorkspaceTrustManagementService } from 'monaco-editor/esm/vs/platform/workspace/common/workspaceTrust.js';
import { Extensions as Extensions$1 } from 'monaco-editor/esm/vs/platform/jsonschemas/common/jsonContributionRegistry.js';
import { g as getServiceOverride$2 } from './workspaceContext.js';
import { g as getServiceOverride$1 } from './files.js';
import { o as onServicesInitialized } from './tools.js';
import { SyncDescriptor } from 'monaco-editor/esm/vs/platform/instantiation/common/descriptors.js';
import { ITextResourceConfigurationService } from 'monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js';
import { StandaloneServices } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js';
import { VSBuffer } from 'monaco-editor/esm/vs/base/common/buffer.js';
function isConfigurationOverrides(thing) {
    return thing
        && typeof thing === 'object'
        && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')
        && (!thing.resource || thing.resource instanceof URI);
}
function isConfigurationUpdateOverrides(thing) {
    return thing
        && typeof thing === 'object'
        && (!thing.overrideIdentifiers || isArray(thing.overrideIdentifiers))
        && !thing.overrideIdentifier
        && (!thing.resource || thing.resource instanceof URI);
}
class DefaultConfiguration extends Disposable {
    constructor() {
        super(...arguments);
        this._onDidChangeConfiguration = this._register(( (new Emitter())));
        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    }
    get configurationModel() {
        if (!this._configurationModel) {
            this._configurationModel = ( (new DefaultConfigurationModel(this.getConfigurationDefaultOverrides())));
        }
        return this._configurationModel;
    }
    async initialize() {
        this._configurationModel = undefined;
        this._register(( (Registry.as(Extensions.Configuration))).onDidUpdateConfiguration(({ properties, defaultsOverrides }) => this.onDidUpdateConfiguration(properties, defaultsOverrides)));
        return this.configurationModel;
    }
    reload() {
        this._configurationModel = undefined;
        return this.configurationModel;
    }
    onDidUpdateConfiguration(properties, defaultsOverrides) {
        this._configurationModel = undefined;
        this._onDidChangeConfiguration.fire({ defaults: this.configurationModel, properties });
    }
    getConfigurationDefaultOverrides() {
        return {};
    }
}
class DefaultConfigurationModel extends ConfigurationModel {
    constructor(configurationDefaultsOverrides = {}) {
        const properties = ( (Registry.as(Extensions.Configuration))).getConfigurationProperties();
        const keys = ( (Object.keys(properties)));
        const contents = Object.create(null);
        const overrides = [];
        for (const key in properties) {
            const defaultOverrideValue = configurationDefaultsOverrides[key];
            const value = defaultOverrideValue !== undefined ? defaultOverrideValue : properties[key].default;
            addToValueTree(contents, key, value, message => console.error(`Conflict in default settings: ${message}`));
        }
        for (const key of ( (Object.keys(contents)))) {
            if (OVERRIDE_PROPERTY_REGEX.test(key)) {
                overrides.push({
                    identifiers: overrideIdentifiersFromKey(key),
                    keys: ( (Object.keys(contents[key]))),
                    contents: toValuesTree(contents[key], message => console.error(`Conflict in default settings file: ${message}`)),
                });
            }
        }
        super(contents, keys, overrides);
    }
}
class NullPolicyConfiguration {
    constructor() {
        this.onDidChangeConfiguration = Event.None;
        this.configurationModel = ( (new ConfigurationModel()));
    }
    async initialize() { return this.configurationModel; }
}
let PolicyConfiguration = class PolicyConfiguration extends Disposable {
    constructor(defaultConfiguration, policyService, logService) {
        super();
        this.defaultConfiguration = defaultConfiguration;
        this.policyService = policyService;
        this.logService = logService;
        this._onDidChangeConfiguration = this._register(( (new Emitter())));
        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
        this._configurationModel = ( (new ConfigurationModel()));
    }
    get configurationModel() { return this._configurationModel; }
    async initialize() {
        this.update(await this.registerPolicyDefinitions(this.defaultConfiguration.configurationModel.keys), false);
        this._register(this.policyService.onDidChange(policyNames => this.onDidChangePolicies(policyNames)));
        this._register(this.defaultConfiguration.onDidChangeConfiguration(async ({ properties }) => this.update(await this.registerPolicyDefinitions(properties), true)));
        return this._configurationModel;
    }
    async registerPolicyDefinitions(properties) {
        const policyDefinitions = {};
        const keys = [];
        const configurationProperties = ( (Registry.as(Extensions.Configuration))).getConfigurationProperties();
        for (const key of properties) {
            const config = configurationProperties[key];
            if (!config) {
                keys.push(key);
                continue;
            }
            if (config.policy) {
                if (config.type !== 'string' && config.type !== 'number') {
                    this.logService.warn(`Policy ${config.policy.name} has unsupported type ${config.type}`);
                    continue;
                }
                keys.push(key);
                policyDefinitions[config.policy.name] = { type: config.type };
            }
        }
        if (!isEmptyObject(policyDefinitions)) {
            await this.policyService.registerPolicyDefinitions(policyDefinitions);
        }
        return keys;
    }
    onDidChangePolicies(policyNames) {
        const policyConfigurations = ( (Registry.as(Extensions.Configuration))).getPolicyConfigurations();
        const keys = coalesce(policyNames.map(policyName => policyConfigurations.get(policyName)));
        this.update(keys, true);
    }
    update(keys, trigger) {
        const configurationProperties = ( (Registry.as(Extensions.Configuration))).getConfigurationProperties();
        const changed = [];
        const wasEmpty = this._configurationModel.isEmpty();
        for (const key of keys) {
            const policyName = configurationProperties[key]?.policy?.name;
            if (policyName) {
                const policyValue = this.policyService.getPolicyValue(policyName);
                if (wasEmpty ? policyValue !== undefined : !equals(this._configurationModel.getValue(key), policyValue)) {
                    changed.push([key, policyValue]);
                }
            }
            else {
                if (this._configurationModel.getValue(key) !== undefined) {
                    changed.push([key, undefined]);
                }
            }
        }
        if (changed.length) {
            const old = this._configurationModel;
            this._configurationModel = ( (new ConfigurationModel()));
            for (const key of old.keys) {
                this._configurationModel.setValue(key, old.getValue(key));
            }
            for (const [key, policyValue] of changed) {
                if (policyValue === undefined) {
                    this._configurationModel.removeValue(key);
                }
                else {
                    this._configurationModel.setValue(key, policyValue);
                }
            }
            if (trigger) {
                this._onDidChangeConfiguration.fire(this._configurationModel);
            }
        }
    }
};
PolicyConfiguration = ( (__decorate([
    ( (__param(1, IPolicyService))),
    ( (__param(2, ILogService)))
], PolicyConfiguration)));
class ConfigurationService extends Disposable {
    constructor(settingsResource, fileService, policyService, logService) {
        super();
        this.settingsResource = settingsResource;
        this._onDidChangeConfiguration = this._register(( (new Emitter())));
        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
        this.defaultConfiguration = this._register(( (new DefaultConfiguration())));
        this.policyConfiguration = policyService instanceof NullPolicyService ? ( (new NullPolicyConfiguration())) : this._register(( (new PolicyConfiguration(this.defaultConfiguration, policyService, logService))));
        this.userConfiguration = this._register(( (new UserSettings(this.settingsResource, undefined, extUriBiasedIgnorePathCase, fileService))));
        this.configuration = ( (new Configuration(
            this.defaultConfiguration.configurationModel,
            this.policyConfiguration.configurationModel,
             (new ConfigurationModel()),
             (new ConfigurationModel())
        )));
        this.reloadConfigurationScheduler = this._register(( (new RunOnceScheduler(() => this.reloadConfiguration(), 50))));
        this._register(this.defaultConfiguration.onDidChangeConfiguration(({ defaults, properties }) => this.onDidDefaultConfigurationChange(defaults, properties)));
        this._register(this.policyConfiguration.onDidChangeConfiguration(model => this.onDidPolicyConfigurationChange(model)));
        this._register(this.userConfiguration.onDidChange(() => this.reloadConfigurationScheduler.schedule()));
    }
    async initialize() {
        const [defaultModel, policyModel, userModel] = await Promise.all([this.defaultConfiguration.initialize(), this.policyConfiguration.initialize(), this.userConfiguration.loadConfiguration()]);
        this.configuration = ( (new Configuration(
            defaultModel,
            policyModel,
             (new ConfigurationModel()),
            userModel
        )));
    }
    getConfigurationData() {
        return this.configuration.toData();
    }
    getValue(arg1, arg2) {
        const section = typeof arg1 === 'string' ? arg1 : undefined;
        const overrides = isConfigurationOverrides(arg1) ? arg1 : isConfigurationOverrides(arg2) ? arg2 : {};
        return this.configuration.getValue(section, overrides, undefined);
    }
    updateValue(key, value, arg3, arg4) {
        return Promise.reject(( (new Error('not supported'))));
    }
    inspect(key) {
        return this.configuration.inspect(key, {}, undefined);
    }
    keys() {
        return (
             (this.configuration.keys(undefined))
        );
    }
    async reloadConfiguration() {
        const configurationModel = await this.userConfiguration.loadConfiguration();
        this.onDidChangeUserConfiguration(configurationModel);
    }
    onDidChangeUserConfiguration(userConfigurationModel) {
        const previous = this.configuration.toData();
        const change = this.configuration.compareAndUpdateLocalUserConfiguration(userConfigurationModel);
        this.trigger(change, previous, 2 );
    }
    onDidDefaultConfigurationChange(defaultConfigurationModel, properties) {
        const previous = this.configuration.toData();
        const change = this.configuration.compareAndUpdateDefaultConfiguration(defaultConfigurationModel, properties);
        this.trigger(change, previous, 7 );
    }
    onDidPolicyConfigurationChange(policyConfiguration) {
        const previous = this.configuration.toData();
        const change = this.configuration.compareAndUpdatePolicyConfiguration(policyConfiguration);
        this.trigger(change, previous, 7 );
    }
    trigger(configurationChange, previous, source) {
        const event = ( (new ConfigurationChangeEvent(configurationChange, { data: previous }, this.configuration)));
        event.source = source;
        event.sourceConfig = this.getTargetConfiguration(source);
        this._onDidChangeConfiguration.fire(event);
    }
    getTargetConfiguration(target) {
        switch (target) {
            case 7 :
                return this.configuration.defaults.contents;
            case 2 :
                return this.configuration.localUserConfiguration.contents;
        }
        return {};
    }
}
let TextResourceConfigurationService = class TextResourceConfigurationService extends Disposable {
    constructor(configurationService, modelService, languageService) {
        super();
        this.configurationService = configurationService;
        this.modelService = modelService;
        this.languageService = languageService;
        this._onDidChangeConfiguration = this._register(( (new Emitter())));
        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
        this._register(this.configurationService.onDidChangeConfiguration(e => this._onDidChangeConfiguration.fire(this.toResourceConfigurationChangeEvent(e))));
    }
    getValue(resource, arg2, arg3) {
        if (typeof arg3 === 'string') {
            return this._getValue(resource, Position$2.isIPosition(arg2) ? arg2 : null, arg3);
        }
        return this._getValue(resource, null, typeof arg2 === 'string' ? arg2 : undefined);
    }
    updateValue(resource, key, value, configurationTarget) {
        const language = this.getLanguage(resource, null);
        const configurationValue = this.configurationService.inspect(key, { resource, overrideIdentifier: language });
        if (configurationTarget === undefined) {
            configurationTarget = this.deriveConfigurationTarget(configurationValue, language);
        }
        switch (configurationTarget) {
            case 8 :
                return this._updateValue(key, value, configurationTarget, configurationValue.memory?.override, resource, language);
            case 6 :
                return this._updateValue(key, value, configurationTarget, configurationValue.workspaceFolder?.override, resource, language);
            case 5 :
                return this._updateValue(key, value, configurationTarget, configurationValue.workspace?.override, resource, language);
            case 4 :
                return this._updateValue(key, value, configurationTarget, configurationValue.userRemote?.override, resource, language);
            default:
                return this._updateValue(key, value, configurationTarget, configurationValue.userLocal?.override, resource, language);
        }
    }
    _updateValue(key, value, configurationTarget, overriddenValue, resource, language) {
        if (language && overriddenValue !== undefined) {
            return this.configurationService.updateValue(key, value, { resource, overrideIdentifier: language }, configurationTarget);
        }
        else {
            return this.configurationService.updateValue(key, value, { resource }, configurationTarget);
        }
    }
    deriveConfigurationTarget(configurationValue, language) {
        if (language) {
            if (configurationValue.memory?.override !== undefined) {
                return 8 ;
            }
            if (configurationValue.workspaceFolder?.override !== undefined) {
                return 6 ;
            }
            if (configurationValue.workspace?.override !== undefined) {
                return 5 ;
            }
            if (configurationValue.userRemote?.override !== undefined) {
                return 4 ;
            }
            if (configurationValue.userLocal?.override !== undefined) {
                return 3 ;
            }
        }
        if (configurationValue.memory?.value !== undefined) {
            return 8 ;
        }
        if (configurationValue.workspaceFolder?.value !== undefined) {
            return 6 ;
        }
        if (configurationValue.workspace?.value !== undefined) {
            return 5 ;
        }
        if (configurationValue.userRemote?.value !== undefined) {
            return 4 ;
        }
        return 3 ;
    }
    _getValue(resource, position, section) {
        const language = resource ? this.getLanguage(resource, position) : undefined;
        if (typeof section === 'undefined') {
            return this.configurationService.getValue({ resource, overrideIdentifier: language });
        }
        return this.configurationService.getValue(section, { resource, overrideIdentifier: language });
    }
    getLanguage(resource, position) {
        const model = this.modelService.getModel(resource);
        if (model) {
            return position ? model.getLanguageIdAtPosition(position.lineNumber, position.column) : model.getLanguageId();
        }
        return this.languageService.guessLanguageIdByFilepathOrFirstLine(resource);
    }
    toResourceConfigurationChangeEvent(configurationChangeEvent) {
        return {
            affectedKeys: configurationChangeEvent.affectedKeys,
            affectsConfiguration: (resource, configuration) => {
                const overrideIdentifier = this.getLanguage(resource, null);
                return configurationChangeEvent.affectsConfiguration(configuration, { resource, overrideIdentifier });
            }
        };
    }
};
TextResourceConfigurationService = ( (__decorate([
    ( (__param(0, IConfigurationService))),
    ( (__param(1, IModelService))),
    ( (__param(2, ILanguageService)))
], TextResourceConfigurationService)));
const FOLDER_CONFIG_FOLDER_NAME = '.vscode';
const defaultSettingsSchemaId = 'vscode://schemas/settings/default';
const userSettingsSchemaId = 'vscode://schemas/settings/user';
const profileSettingsSchemaId = 'vscode://schemas/settings/profile';
const machineSettingsSchemaId = 'vscode://schemas/settings/machine';
const workspaceSettingsSchemaId = 'vscode://schemas/settings/workspace';
const folderSettingsSchemaId = 'vscode://schemas/settings/folder';
const TASKS_CONFIGURATION_KEY = 'tasks';
const LAUNCH_CONFIGURATION_KEY = 'launch';
const WORKSPACE_STANDALONE_CONFIGURATIONS = Object.create(null);
WORKSPACE_STANDALONE_CONFIGURATIONS[TASKS_CONFIGURATION_KEY] = `${FOLDER_CONFIG_FOLDER_NAME}/${TASKS_CONFIGURATION_KEY}.json`;
WORKSPACE_STANDALONE_CONFIGURATIONS[LAUNCH_CONFIGURATION_KEY] = `${FOLDER_CONFIG_FOLDER_NAME}/${LAUNCH_CONFIGURATION_KEY}.json`;
const USER_STANDALONE_CONFIGURATIONS = Object.create(null);
USER_STANDALONE_CONFIGURATIONS[TASKS_CONFIGURATION_KEY] = `${TASKS_CONFIGURATION_KEY}.json`;
let RegisterConfigurationSchemasContribution = class RegisterConfigurationSchemasContribution extends Disposable {
    constructor(workspaceContextService, environmentService, workspaceTrustManagementService) {
        super();
        this.workspaceContextService = workspaceContextService;
        this.environmentService = environmentService;
        this.workspaceTrustManagementService = workspaceTrustManagementService;
        this.registerConfigurationSchemas();
        const configurationRegistry = ( (Registry.as(Extensions.Configuration)));
        this._register(configurationRegistry.onDidUpdateConfiguration(e => this.registerConfigurationSchemas()));
        this._register(configurationRegistry.onDidSchemaChange(e => this.registerConfigurationSchemas()));
        this._register(workspaceTrustManagementService.onDidChangeTrust(() => this.registerConfigurationSchemas()));
    }
    registerConfigurationSchemas() {
        const jsonRegistry = ( (Registry.as(Extensions$1.JSONContribution)));
        const allSettingsSchema = {
            properties: allSettings.properties,
            patternProperties: allSettings.patternProperties,
            additionalProperties: true,
            allowTrailingCommas: true,
            allowComments: true
        };
        const userSettingsSchema = this.environmentService.remoteAuthority ?
            {
                properties: {
                    ...applicationSettings.properties,
                    ...windowSettings.properties,
                    ...resourceSettings.properties
                },
                patternProperties: allSettings.patternProperties,
                additionalProperties: true,
                allowTrailingCommas: true,
                allowComments: true
            }
            : allSettingsSchema;
        const profileSettingsSchema = {
            properties: {
                ...machineSettings.properties,
                ...machineOverridableSettings.properties,
                ...windowSettings.properties,
                ...resourceSettings.properties
            },
            patternProperties: allSettings.patternProperties,
            additionalProperties: true,
            allowTrailingCommas: true,
            allowComments: true
        };
        const machineSettingsSchema = {
            properties: {
                ...machineSettings.properties,
                ...machineOverridableSettings.properties,
                ...windowSettings.properties,
                ...resourceSettings.properties
            },
            patternProperties: allSettings.patternProperties,
            additionalProperties: true,
            allowTrailingCommas: true,
            allowComments: true
        };
        const workspaceSettingsSchema = {
            properties: {
                ...this.checkAndFilterPropertiesRequiringTrust(machineOverridableSettings.properties),
                ...this.checkAndFilterPropertiesRequiringTrust(windowSettings.properties),
                ...this.checkAndFilterPropertiesRequiringTrust(resourceSettings.properties)
            },
            patternProperties: allSettings.patternProperties,
            additionalProperties: true,
            allowTrailingCommas: true,
            allowComments: true
        };
        jsonRegistry.registerSchema(defaultSettingsSchemaId, {
            properties: ( (Object.keys(allSettings.properties))).reduce((result, key) => {
                result[key] = {
                    ...allSettings.properties[key],
                    deprecationMessage: undefined
                };
                return result;
            }, {}),
            patternProperties: ( (Object.keys(allSettings.patternProperties))).reduce((result, key) => {
                result[key] = {
                    ...allSettings.patternProperties[key],
                    deprecationMessage: undefined
                };
                return result;
            }, {}),
            additionalProperties: true,
            allowTrailingCommas: true,
            allowComments: true
        });
        jsonRegistry.registerSchema(userSettingsSchemaId, userSettingsSchema);
        jsonRegistry.registerSchema(profileSettingsSchemaId, profileSettingsSchema);
        jsonRegistry.registerSchema(machineSettingsSchemaId, machineSettingsSchema);
        if (3  === this.workspaceContextService.getWorkbenchState()) {
            const folderSettingsSchema = {
                properties: {
                    ...this.checkAndFilterPropertiesRequiringTrust(machineOverridableSettings.properties),
                    ...this.checkAndFilterPropertiesRequiringTrust(resourceSettings.properties)
                },
                patternProperties: allSettings.patternProperties,
                additionalProperties: true,
                allowTrailingCommas: true,
                allowComments: true
            };
            jsonRegistry.registerSchema(workspaceSettingsSchemaId, workspaceSettingsSchema);
            jsonRegistry.registerSchema(folderSettingsSchemaId, folderSettingsSchema);
        }
        else {
            jsonRegistry.registerSchema(workspaceSettingsSchemaId, workspaceSettingsSchema);
            jsonRegistry.registerSchema(folderSettingsSchemaId, workspaceSettingsSchema);
        }
        jsonRegistry.registerSchema(configurationDefaultsSchemaId, {
            type: 'object',
            description: ( (localize(
                'configurationDefaults.description',
                'Contribute defaults for configurations'
            ))),
            properties: {
                ...machineOverridableSettings.properties,
                ...windowSettings.properties,
                ...resourceSettings.properties
            },
            patternProperties: {
                [OVERRIDE_PROPERTY_PATTERN]: {
                    type: 'object',
                    default: {},
                    $ref: resourceLanguageSettingsSchemaId,
                }
            },
            additionalProperties: false
        });
    }
    checkAndFilterPropertiesRequiringTrust(properties) {
        if (this.workspaceTrustManagementService.isWorkspaceTrusted()) {
            return properties;
        }
        const result = {};
        Object.entries(properties).forEach(([key, value]) => {
            if (!value.restricted) {
                result[key] = value;
            }
        });
        return result;
    }
};
RegisterConfigurationSchemasContribution = ( (__decorate([
    ( (__param(0, IWorkspaceContextService))),
    ( (__param(1, IWorkbenchEnvironmentService))),
    ( (__param(2, IWorkspaceTrustManagementService)))
], RegisterConfigurationSchemasContribution)));
function updateUserConfiguration(configurationJson) {
    const userDataProfilesService = StandaloneServices.get(IUserDataProfilesService);
    void StandaloneServices.get(IFileService).writeFile(userDataProfilesService.defaultProfile.settingsResource, VSBuffer.fromString(configurationJson));
}
const configurationRegistry = ( Registry.as(Extensions.Configuration));
let InjectedConfigurationService = class InjectedConfigurationService extends ConfigurationService {
    constructor(userDataProfilesService, fileService, policyService, logService) {
        super(userDataProfilesService.defaultProfile.settingsResource, fileService, policyService, logService);
        this.initialize().catch(error => {
            logService.error(error);
        });
    }
    updateValue(key, value, arg3, arg4) {
        const overrides = isConfigurationUpdateOverrides(arg3)
            ? arg3
            : isConfigurationOverrides(arg3) ? { resource: arg3.resource, overrideIdentifiers: arg3.overrideIdentifier != null ? [arg3.overrideIdentifier] : undefined } : undefined;
        const target = overrides != null ? arg4 : arg3;
        if (target === 8 ) {
            return Promise.resolve(this['configuration'].updateValue(key, value, overrides));
        }
        return Promise.reject(new Error('not supported'));
    }
};
InjectedConfigurationService = ( __decorate([
    ( __param(0, IUserDataProfilesService)),
    ( __param(1, IFileService)),
    ( __param(2, IPolicyService)),
    ( __param(3, ILogService))
], InjectedConfigurationService));
function initialize(instantiationService) {
    instantiationService.createInstance(RegisterConfigurationSchemasContribution);
}
function getServiceOverride() {
    onServicesInitialized(initialize);
    return {
        ...getServiceOverride$1(),
        ...getServiceOverride$2(),
        [( IConfigurationService.toString())]: new SyncDescriptor(InjectedConfigurationService),
        [( ITextResourceConfigurationService.toString())]: new SyncDescriptor(TextResourceConfigurationService)
    };
}
export { configurationRegistry, getServiceOverride as default, updateUserConfiguration };

import * as monaco from 'monaco-editor';

/**
 * A model.
 */
type ITextModel = monaco.editor.ITextModel

/**
 * A rich code editor.
 */
type ICodeEditor = monaco.editor.ICodeEditor

declare enum EditorActivation {
    /**
     * Activate the editor after it opened. This will automatically restore
     * the editor if it is minimized.
     */
    ACTIVATE = 1,
    /**
     * Only restore the editor if it is minimized but do not activate it.
     *
     * Note: will only work in combination with the `preserveFocus: true` option.
     * Otherwise, if focus moves into the editor, it will activate and restore
     * automatically.
     */
    RESTORE = 2,
    /**
     * Preserve the current active editor.
     *
     * Note: will only work in combination with the `preserveFocus: true` option.
     * Otherwise, if focus moves into the editor, it will activate and restore
     * automatically.
     */
    PRESERVE = 3
}
declare enum EditorResolution {
    /**
     * Displays a picker and allows the user to decide which editor to use.
     */
    PICK = 0,
    /**
     * Disables editor resolving.
     */
    DISABLED = 1,
    /**
     * Only exclusive editors are considered.
     */
    EXCLUSIVE_ONLY = 2
}
declare enum EditorOpenSource {
    /**
     * Default: the editor is opening via a programmatic call
     * to the editor service API.
     */
    API = 0,
    /**
     * Indicates that a user action triggered the opening, e.g.
     * via mouse or keyboard use.
     */
    USER = 1
}
interface IEditorOptions {
    /**
     * Tells the editor to not receive keyboard focus when the editor is being opened.
     *
     * Will also not activate the group the editor opens in unless the group is already
     * the active one. This behaviour can be overridden via the `activation` option.
     */
    preserveFocus?: boolean;
    /**
     * This option is only relevant if an editor is opened into a group that is not active
     * already and allows to control if the inactive group should become active, restored
     * or preserved.
     *
     * By default, the editor group will become active unless `preserveFocus` or `inactive`
     * is specified.
     */
    activation?: EditorActivation;
    /**
     * Tells the editor to reload the editor input in the editor even if it is identical to the one
     * already showing. By default, the editor will not reload the input if it is identical to the
     * one showing.
     */
    forceReload?: boolean;
    /**
     * Will reveal the editor if it is already opened and visible in any of the opened editor groups.
     *
     * Note that this option is just a hint that might be ignored if the user wants to open an editor explicitly
     * to the side of another one or into a specific editor group.
     */
    revealIfVisible?: boolean;
    /**
     * Will reveal the editor if it is already opened (even when not visible) in any of the opened editor groups.
     *
     * Note that this option is just a hint that might be ignored if the user wants to open an editor explicitly
     * to the side of another one or into a specific editor group.
     */
    revealIfOpened?: boolean;
    /**
     * An editor that is pinned remains in the editor stack even when another editor is being opened.
     * An editor that is not pinned will always get replaced by another editor that is not pinned.
     */
    pinned?: boolean;
    /**
     * An editor that is sticky moves to the beginning of the editors list within the group and will remain
     * there unless explicitly closed. Operations such as "Close All" will not close sticky editors.
     */
    sticky?: boolean;
    /**
     * The index in the document stack where to insert the editor into when opening.
     */
    index?: number;
    /**
     * An active editor that is opened will show its contents directly. Set to true to open an editor
     * in the background without loading its contents.
     *
     * Will also not activate the group the editor opens in unless the group is already
     * the active one. This behaviour can be overridden via the `activation` option.
     */
    inactive?: boolean;
    /**
     * Will not show an error in case opening the editor fails and thus allows to show a custom error
     * message as needed. By default, an error will be presented as notification if opening was not possible.
     */
    /**
     * In case of an error opening the editor, will not present this error to the user (e.g. by showing
     * a generic placeholder in the editor area). So it is up to the caller to provide error information
     * in that case.
     *
     * By default, an error when opening an editor will result in a placeholder editor that shows the error.
     * In certain cases a modal dialog may be presented to ask the user for further action.
     */
    ignoreError?: boolean;
    /**
     * Allows to override the editor that should be used to display the input:
     * - `undefined`: let the editor decide for itself
     * - `string`: specific override by id
     * - `EditorResolution`: specific override handling
     */
    override?: string | EditorResolution;
    /**
     * A optional hint to signal in which context the editor opens.
     *
     * If configured to be `EditorOpenSource.USER`, this hint can be
     * used in various places to control the experience. For example,
     * if the editor to open fails with an error, a notification could
     * inform about this in a modal dialog. If the editor opened through
     * some background task, the notification would show in the background,
     * not as a modal dialog.
     */
    source?: EditorOpenSource;
    /**
     * An optional property to signal that certain view state should be
     * applied when opening the editor.
     */
    viewState?: object;
}

type IEditorOverrideServices = monaco.editor.IEditorOverrideServices

declare type OpenEditor = (model: ITextModel, options: IEditorOptions | undefined, sideBySide?: boolean) => Promise<ICodeEditor | undefined>;
declare function getServiceOverride(openEditor: OpenEditor): IEditorOverrideServices;

export { IEditorOptions, OpenEditor, getServiceOverride as default };

import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IEnvironmentService } from 'monaco-editor/esm/vs/platform/environment/common/environment.js';
import './contextkey.js';
import * as monaco from 'monaco-editor/esm/vs/editor/editor.api.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { TernarySearchTree } from 'monaco-editor/esm/vs/base/common/map.js';
function refineServiceDecorator(serviceIdentifier) {
    return serviceIdentifier;
}
const CancellationTokenSource = monaco.CancellationTokenSource;
const IFileService = ( (createDecorator('fileService')));
var FileType;
( ((function(FileType) {
    FileType[FileType["Unknown"] = 0] = "Unknown";
    FileType[FileType["File"] = 1] = "File";
    FileType[FileType["Directory"] = 2] = "Directory";
    FileType[FileType["SymbolicLink"] = 64] = "SymbolicLink";
})(FileType || (FileType = {}))));
var FilePermission;
( ((function(FilePermission) {
    FilePermission[FilePermission["Readonly"] = 1] = "Readonly";
})(FilePermission || (FilePermission = {}))));
function hasReadWriteCapability(provider) {
    return !!((provider.capabilities & 2) );
}
function hasFileFolderCopyCapability(provider) {
    return !!((provider.capabilities & 8) );
}
function hasFileCloneCapability(provider) {
    return !!((provider.capabilities & 32768) );
}
function hasOpenReadWriteCloseCapability(provider) {
    return !!((provider.capabilities & 4) );
}
function hasFileReadStreamCapability(provider) {
    return !!((provider.capabilities & 16) );
}
function hasFileAtomicReadCapability(provider) {
    if (!hasReadWriteCapability(provider)) {
        return false;
    }
    return !!((provider.capabilities & 16384) );
}
var FileSystemProviderErrorCode;
( ((function(FileSystemProviderErrorCode) {
    FileSystemProviderErrorCode["FileExists"] = "EntryExists";
    FileSystemProviderErrorCode["FileNotFound"] = "EntryNotFound";
    FileSystemProviderErrorCode["FileNotADirectory"] = "EntryNotADirectory";
    FileSystemProviderErrorCode["FileIsADirectory"] = "EntryIsADirectory";
    FileSystemProviderErrorCode["FileExceedsMemoryLimit"] = "EntryExceedsMemoryLimit";
    FileSystemProviderErrorCode["FileTooLarge"] = "EntryTooLarge";
    FileSystemProviderErrorCode["FileWriteLocked"] = "EntryWriteLocked";
    FileSystemProviderErrorCode["NoPermissions"] = "NoPermissions";
    FileSystemProviderErrorCode["Unavailable"] = "Unavailable";
    FileSystemProviderErrorCode["Unknown"] = "Unknown";
})(FileSystemProviderErrorCode || (FileSystemProviderErrorCode = {}))));
class FileSystemProviderError extends Error {
    constructor(message, code) {
        super(message);
        this.code = code;
    }
}
function createFileSystemProviderError(error, code) {
    const providerError = ( (new FileSystemProviderError( (error.toString()), code)));
    markAsFileSystemProviderError(providerError, code);
    return providerError;
}
function ensureFileSystemProviderError(error) {
    if (!error) {
        return createFileSystemProviderError(( (localize('unknownError', "Unknown Error"))), FileSystemProviderErrorCode.Unknown);
    }
    return error;
}
function markAsFileSystemProviderError(error, code) {
    error.name = code ? `${code} (FileSystemError)` : `FileSystemError`;
    return error;
}
function toFileSystemProviderErrorCode(error) {
    if (!error) {
        return FileSystemProviderErrorCode.Unknown;
    }
    if (error instanceof FileSystemProviderError) {
        return error.code;
    }
    const match = /^(.+) \(FileSystemError\)$/.exec(error.name);
    if (!match) {
        return FileSystemProviderErrorCode.Unknown;
    }
    switch (match[1]) {
        case FileSystemProviderErrorCode.FileExists: return FileSystemProviderErrorCode.FileExists;
        case FileSystemProviderErrorCode.FileIsADirectory: return FileSystemProviderErrorCode.FileIsADirectory;
        case FileSystemProviderErrorCode.FileNotADirectory: return FileSystemProviderErrorCode.FileNotADirectory;
        case FileSystemProviderErrorCode.FileNotFound: return FileSystemProviderErrorCode.FileNotFound;
        case FileSystemProviderErrorCode.FileExceedsMemoryLimit: return FileSystemProviderErrorCode.FileExceedsMemoryLimit;
        case FileSystemProviderErrorCode.FileTooLarge: return FileSystemProviderErrorCode.FileTooLarge;
        case FileSystemProviderErrorCode.FileWriteLocked: return FileSystemProviderErrorCode.FileWriteLocked;
        case FileSystemProviderErrorCode.NoPermissions: return FileSystemProviderErrorCode.NoPermissions;
        case FileSystemProviderErrorCode.Unavailable: return FileSystemProviderErrorCode.Unavailable;
    }
    return FileSystemProviderErrorCode.Unknown;
}
function toFileOperationResult(error) {
    if (error instanceof FileOperationError) {
        return error.fileOperationResult;
    }
    switch (toFileSystemProviderErrorCode(error)) {
        case FileSystemProviderErrorCode.FileNotFound:
            return 1 ;
        case FileSystemProviderErrorCode.FileIsADirectory:
            return 0 ;
        case FileSystemProviderErrorCode.FileNotADirectory:
            return 10 ;
        case FileSystemProviderErrorCode.FileWriteLocked:
            return 5 ;
        case FileSystemProviderErrorCode.NoPermissions:
            return 6 ;
        case FileSystemProviderErrorCode.FileExists:
            return 4 ;
        case FileSystemProviderErrorCode.FileExceedsMemoryLimit:
            return 9 ;
        case FileSystemProviderErrorCode.FileTooLarge:
            return 7 ;
        default:
            return 11 ;
    }
}
class FileOperationEvent {
    constructor(resource, operation, target) {
        this.resource = resource;
        this.operation = operation;
        this.target = target;
    }
    isOperation(operation) {
        return this.operation === operation;
    }
}
class FileChangesEvent {
    constructor(changes, ignorePathCasing) {
        this.added = undefined;
        this.updated = undefined;
        this.deleted = undefined;
        this.rawChanges = [];
        this.rawAdded = [];
        this.rawUpdated = [];
        this.rawDeleted = [];
        this.rawChanges = changes;
        const entriesByType = ( (new Map()));
        for (const change of changes) {
            const array = entriesByType.get(change.type);
            if (array) {
                array.push([change.resource, change]);
            }
            else {
                entriesByType.set(change.type, [[change.resource, change]]);
            }
            switch (change.type) {
                case 1 :
                    this.rawAdded.push(change.resource);
                    break;
                case 0 :
                    this.rawUpdated.push(change.resource);
                    break;
                case 2 :
                    this.rawDeleted.push(change.resource);
                    break;
            }
        }
        for (const [key, value] of entriesByType) {
            switch (key) {
                case 1 :
                    this.added = TernarySearchTree.forUris(() => ignorePathCasing);
                    this.added.fill(value);
                    break;
                case 0 :
                    this.updated = TernarySearchTree.forUris(() => ignorePathCasing);
                    this.updated.fill(value);
                    break;
                case 2 :
                    this.deleted = TernarySearchTree.forUris(() => ignorePathCasing);
                    this.deleted.fill(value);
                    break;
            }
        }
    }
    contains(resource, ...types) {
        return this.doContains(resource, { includeChildren: false }, ...types);
    }
    affects(resource, ...types) {
        return this.doContains(resource, { includeChildren: true }, ...types);
    }
    doContains(resource, options, ...types) {
        if (!resource) {
            return false;
        }
        const hasTypesFilter = types.length > 0;
        if (!hasTypesFilter || types.includes(1 )) {
            if (this.added?.get(resource)) {
                return true;
            }
            if (options.includeChildren && this.added?.findSuperstr(resource)) {
                return true;
            }
        }
        if (!hasTypesFilter || types.includes(0 )) {
            if (this.updated?.get(resource)) {
                return true;
            }
            if (options.includeChildren && this.updated?.findSuperstr(resource)) {
                return true;
            }
        }
        if (!hasTypesFilter || types.includes(2 )) {
            if (this.deleted?.findSubstr(resource) ) {
                return true;
            }
            if (options.includeChildren && this.deleted?.findSuperstr(resource)) {
                return true;
            }
        }
        return false;
    }
    gotAdded() {
        return !!this.added;
    }
    gotDeleted() {
        return !!this.deleted;
    }
    gotUpdated() {
        return !!this.updated;
    }
}
class FileOperationError extends Error {
    constructor(message, fileOperationResult, options) {
        super(message);
        this.fileOperationResult = fileOperationResult;
        this.options = options;
    }
}
class NotModifiedSinceFileOperationError extends FileOperationError {
    constructor(message, stat, options) {
        super(message, 2 , options);
        this.stat = stat;
    }
}
const FILES_ASSOCIATIONS_CONFIG = 'files.associations';
const ETAG_DISABLED = '';
function etag(stat) {
    if (typeof stat.size !== 'number' || typeof stat.mtime !== 'number') {
        return undefined;
    }
    return ( (stat.mtime.toString(29))) + ( (stat.size.toString(31)));
}
const IUriIdentityService = ( (createDecorator('IUriIdentityService')));
const IEditorGroupsService = ( (createDecorator('editorGroupsService')));
function isEditorGroup(obj) {
    const group = obj;
    return !!group && typeof group.id === 'number' && Array.isArray(group.editors);
}
const IEditorService = ( (createDecorator('editorService')));
const ACTIVE_GROUP = -1;
const SIDE_GROUP = -2;
function isPreferredGroup(obj) {
    const candidate = obj;
    return typeof obj === 'number' || isEditorGroup(candidate);
}
const ITextFileService = ( (createDecorator('textFileService')));
const IWorkbenchEnvironmentService = refineServiceDecorator(IEnvironmentService);
const IWorkingCopyFileService = ( (createDecorator('workingCopyFileService')));
const IPathService = ( (createDecorator('pathService')));
const IPaneCompositePartService = ( (createDecorator('paneCompositePartService')));
const IProductService = ( (createDecorator('productService')));
const productSchemaId = 'vscode://schemas/vscode-product';
const ILanguageStatusService = ( (createDecorator('ILanguageStatusService')));
const IHostService = ( (createDecorator('hostService')));
const ISnippetsService = ( (createDecorator('snippetService')));
let services;
var Services;
( (function(Services) {
    Services.get = () => {
        return services ?? {};
    };
    function install(_services) {
        if (services != null) {
            console.warn('Services have been overridden');
        }
        services = _services;
        return {
            dispose: () => {
                if (services === _services) {
                    services = undefined;
                }
            }
        };
    }
    Services.install = install;
})(Services || (Services = {})));
export { ACTIVE_GROUP as A, ensureFileSystemProviderError as B, CancellationTokenSource as C, etag as D, FileOperationEvent as E, FileType as F, toFileOperationResult as G, ETAG_DISABLED as H, IEditorService as I, hasFileAtomicReadCapability as J, hasFileFolderCopyCapability as K, hasFileCloneCapability as L, createFileSystemProviderError as M, NotModifiedSinceFileOperationError as N, FILES_ASSOCIATIONS_CONFIG as O, Services as S, FilePermission as a, IEditorGroupsService as b, IProductService as c, FileSystemProviderErrorCode as d, SIDE_GROUP as e, IUriIdentityService as f, IPaneCompositePartService as g, ITextFileService as h, IFileService as i, IWorkbenchEnvironmentService as j, IWorkingCopyFileService as k, IPathService as l, markAsFileSystemProviderError as m, ILanguageStatusService as n, IHostService as o, productSchemaId as p, ISnippetsService as q, refineServiceDecorator as r, isPreferredGroup as s, FileSystemProviderError as t, FileChangesEvent as u, FileOperationError as v, hasOpenReadWriteCloseCapability as w, hasReadWriteCapability as x, hasFileReadStreamCapability as y, toFileSystemProviderErrorCode as z };

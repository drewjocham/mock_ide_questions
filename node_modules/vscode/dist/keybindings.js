import { i as index, _ as __decorate, a as __param, h as flatten } from './contextkey.js';
import { E as Emitter, k as parse } from './polyfill.js';
import { i as isProposedApiEnabled, E as ExtensionsRegistry, j as ExtensionMessageCollector, e as IUserDataProfilesService, I as IExtensionService, k as IPreferencesService, l as IUserDataProfileService, m as IKeyboardLayoutService } from './missing-services.js';
import { KeyCodeUtils, IMMUTABLE_CODE_TO_KEY_CODE } from 'monaco-editor/esm/vs/base/common/keyCodes.js';
import { SimpleKeybinding, ScanCodeBinding, ChordKeybinding } from 'monaco-editor/esm/vs/base/common/keybindings.js';
import { ContextKeyExpr, IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { S as Services, i as IFileService, I as IEditorService, b as IEditorGroupsService, o as IHostService } from './services2.js';
import { MenuRegistry, MenuId, MenuItemAction, IMenuService, isIMenuItem } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { getConfiguredDefaultLocale, localize } from 'monaco-editor/esm/vs/nls.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { joinPath, dirname } from 'monaco-editor/esm/vs/base/common/resources.js';
import { Iterable } from 'monaco-editor/esm/vs/base/common/iterator.js';
import { DisposableStore, toDisposable, dispose, Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { isFalsyOrWhitespace } from 'monaco-editor/esm/vs/base/common/strings.js';
import { EditorExtensionsRegistry } from 'monaco-editor/esm/vs/editor/browser/editorExtensions.js';
import { ICommandService, CommandsRegistry } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { isNonEmptyArray } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { AbstractKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/abstractKeybindingService.js';
import { KeybindingsRegistry } from 'monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js';
import { addDisposableListener, EventType } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { BrowserFeatures } from 'monaco-editor/esm/vs/base/browser/canIUse.js';
import { UserSettingsLabelProvider } from 'monaco-editor/esm/vs/base/common/keybindingLabels.js';
import { OS, isMacintosh } from 'monaco-editor/esm/vs/base/common/platform.js';
import { KeybindingResolver } from 'monaco-editor/esm/vs/platform/keybinding/common/keybindingResolver.js';
import { ResolvedKeybindingItem } from 'monaco-editor/esm/vs/platform/keybinding/common/resolvedKeybindingItem.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { timeout, RunOnceScheduler } from 'monaco-editor/esm/vs/base/common/async.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { isArray } from 'monaco-editor/esm/vs/base/common/types.js';
import { equals } from 'monaco-editor/esm/vs/base/common/objects.js';
import { StandardKeyboardEvent } from 'monaco-editor/esm/vs/base/browser/keyboardEvent.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { Extensions } from 'monaco-editor/esm/vs/platform/jsonschemas/common/jsonContributionRegistry.js';
import { Extensions as Extensions$1 } from 'monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js';
import { AbstractEditorCommandsQuickAccessProvider } from 'monaco-editor/esm/vs/editor/contrib/quickAccess/browser/commandsQuickAccess.js';
import { DefaultQuickAccessFilterValue, Extensions as Extensions$2 } from 'monaco-editor/esm/vs/platform/quickinput/common/quickAccess.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { TriggerAction } from 'monaco-editor/esm/vs/platform/quickinput/browser/pickerQuickAccess.js';
import { stripIcons } from 'monaco-editor/esm/vs/base/common/iconLabels.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { IDialogService } from 'monaco-editor/esm/vs/platform/dialogs/common/dialogs.js';
import { g as getServiceOverride$1 } from './files.js';
import { g as getExtensionPoint, c as consoleExtensionMessageHandler } from './tools.js';
import { bd as DEFAULT_EXTENSION } from './extHost.js';
import { c as createInjectedClass } from './injection.js';
import { StandaloneCommandsQuickAccessProvider } from 'monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneCommandsQuickAccess.js';
import { SyncDescriptor } from 'monaco-editor/esm/vs/platform/instantiation/common/descriptors.js';
import { StandaloneServices, StandaloneKeybindingService } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js';
import { VSBuffer } from 'monaco-editor/esm/vs/base/common/buffer.js';
class WindowManager {
    constructor() {
        this._zoomLevel = 0;
        this._zoomFactor = 1;
        this._fullscreen = false;
        this._onDidChangeFullscreen = ( (new Emitter()));
        this.onDidChangeFullscreen = this._onDidChangeFullscreen.event;
    }
    getZoomLevel() {
        return this._zoomLevel;
    }
    setZoomLevel(zoomLevel, isTrusted) {
        if (this._zoomLevel === zoomLevel) {
            return;
        }
        this._zoomLevel = zoomLevel;
    }
    getZoomFactor() {
        return this._zoomFactor;
    }
    setZoomFactor(zoomFactor) {
        this._zoomFactor = zoomFactor;
    }
    setFullscreen(fullscreen) {
        if (this._fullscreen === fullscreen) {
            return;
        }
        this._fullscreen = fullscreen;
        this._onDidChangeFullscreen.fire();
    }
    isFullscreen() {
        return this._fullscreen;
    }
}
WindowManager.INSTANCE = ( (new WindowManager()));
function addMatchMediaChangeListener(query, callback) {
    if (typeof query === 'string') {
        query = window.matchMedia(query);
    }
    query.addEventListener('change', callback);
}
function isFullscreen() {
    return WindowManager.INSTANCE.isFullscreen();
}
const onDidChangeFullscreen = WindowManager.INSTANCE.onDidChangeFullscreen;
const userAgent$1 = navigator.userAgent;
(userAgent$1.indexOf('Firefox') >= 0);
(userAgent$1.indexOf('AppleWebKit') >= 0);
const isChrome$1 = (userAgent$1.indexOf('Chrome') >= 0);
(!isChrome$1 && (userAgent$1.indexOf('Safari') >= 0));
(userAgent$1.indexOf('Electron/') >= 0);
(userAgent$1.indexOf('Android') >= 0);
if (window.matchMedia) {
    const matchMedia = window.matchMedia('(display-mode: standalone)');
    addMatchMediaChangeListener(matchMedia, ({ matches }) => {
    });
}
const LANGUAGE_DEFAULT = 'en';
let _locale = undefined;
let _language = LANGUAGE_DEFAULT;
let _userAgent = undefined;
const globals = (typeof self === 'object' ? self : typeof global === 'object' ? global : {});
let nodeProcess = undefined;
if (typeof globals.vscode !== 'undefined' && typeof globals.vscode.process !== 'undefined') {
    nodeProcess = globals.vscode.process;
}
else if (typeof process !== 'undefined') {
    nodeProcess = process;
}
const isElectronProcess = typeof nodeProcess?.versions?.electron === 'string';
const isElectronRenderer = isElectronProcess && nodeProcess?.type === 'renderer';
if (typeof navigator === 'object' && !isElectronRenderer) {
    _userAgent = navigator.userAgent;
    _userAgent.indexOf('Windows') >= 0;
    _userAgent.indexOf('Macintosh') >= 0;
    (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
    _userAgent.indexOf('Linux') >= 0;
    const configuredLocale = getConfiguredDefaultLocale(
    ( (localize({ key: 'ensureLoaderPluginIsLoaded', comment: ['{Locked}'] }, '_'))));
    _locale = configuredLocale || LANGUAGE_DEFAULT;
    _language = _locale;
}
else if (typeof nodeProcess === 'object') {
    _locale = LANGUAGE_DEFAULT;
    _language = LANGUAGE_DEFAULT;
    const rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];
    if (rawNlsConfig) {
        try {
            const nlsConfig = JSON.parse(rawNlsConfig);
            const resolved = nlsConfig.availableLanguages['*'];
            _locale = nlsConfig.locale;
            _language = resolved ? resolved : LANGUAGE_DEFAULT;
        }
        catch (e) {
        }
    }
}
else {
    console.error('Unable to resolve platform.');
}
const userAgent = _userAgent;
const language = _language;
var Language;
( ((function(Language) {
    function value() {
        return language;
    }
    Language.value = value;
    function isDefaultVariant() {
        if (language.length === 2) {
            return language === 'en';
        }
        else if (language.length >= 3) {
            return language[0] === 'e' && language[1] === 'n' && language[2] === '-';
        }
        else {
            return false;
        }
    }
    Language.isDefaultVariant = isDefaultVariant;
    function isDefault() {
        return language === 'en';
    }
    Language.isDefault = isDefault;
})(Language || (Language = {}))));
const setTimeout0IsFaster = (typeof globals.postMessage === 'function' && !globals.importScripts);
(() => {
    if (setTimeout0IsFaster) {
        const pending = [];
        globals.addEventListener('message', (e) => {
            if (e.data && e.data.vscodeScheduleAsyncWork) {
                for (let i = 0, len = pending.length; i < len; i++) {
                    const candidate = pending[i];
                    if (candidate.id === e.data.vscodeScheduleAsyncWork) {
                        pending.splice(i, 1);
                        candidate.callback();
                        return;
                    }
                }
            }
        });
        let lastId = 0;
        return (callback) => {
            const myId = ++lastId;
            pending.push({
                id: myId,
                callback: callback
            });
            globals.postMessage({ vscodeScheduleAsyncWork: myId }, '*');
        };
    }
    return (callback) => setTimeout(callback);
})();
const isChrome = !!(userAgent && userAgent.indexOf('Chrome') >= 0);
!!(userAgent && userAgent.indexOf('Firefox') >= 0);
!!(!isChrome && (userAgent && userAgent.indexOf('Safari') >= 0));
!!(userAgent && userAgent.indexOf('Edg/') >= 0);
!!(userAgent && userAgent.indexOf('Android') >= 0);
const scanCodeIntToStr = [];
const scanCodeStrToInt = Object.create(null);
const scanCodeLowerCaseStrToInt = Object.create(null);
const ScanCodeUtils = {
    lowerCaseToEnum: (scanCode) => scanCodeLowerCaseStrToInt[scanCode] || 0 ,
    toEnum: (scanCode) => scanCodeStrToInt[scanCode] || 0 ,
    toString: (scanCode) => scanCodeIntToStr[scanCode] || 'None'
};
function printKeyboardEvent(e) {
    const modifiers = [];
    if (e.ctrlKey) {
        modifiers.push(`ctrl`);
    }
    if (e.shiftKey) {
        modifiers.push(`shift`);
    }
    if (e.altKey) {
        modifiers.push(`alt`);
    }
    if (e.metaKey) {
        modifiers.push(`meta`);
    }
    return `modifiers: [${modifiers.join(',')}], code: ${e.code}, keyCode: ${e.keyCode}, key: ${e.key}`;
}
function printStandardKeyboardEvent(e) {
    const modifiers = [];
    if (e.ctrlKey) {
        modifiers.push(`ctrl`);
    }
    if (e.shiftKey) {
        modifiers.push(`shift`);
    }
    if (e.altKey) {
        modifiers.push(`alt`);
    }
    if (e.metaKey) {
        modifiers.push(`meta`);
    }
    return `modifiers: [${modifiers.join(',')}], code: ${e.code}, keyCode: ${e.keyCode} ('${( ( KeyCodeUtils.toString(e.keyCode)))}')`;
}
const apiMenus = [
    {
        key: 'commandPalette',
        id: MenuId.CommandPalette,
        description: ( (localize('menus.commandPalette', "The Command Palette"))),
        supportsSubmenus: false
    },
    {
        key: 'touchBar',
        id: MenuId.TouchBarContext,
        description: ( (localize('menus.touchBar', "The touch bar (macOS only)"))),
        supportsSubmenus: false
    },
    {
        key: 'editor/title',
        id: MenuId.EditorTitle,
        description: ( (localize('menus.editorTitle', "The editor title menu")))
    },
    {
        key: 'editor/title/run',
        id: MenuId.EditorTitleRun,
        description: ( (localize('menus.editorTitleRun', "Run submenu inside the editor title menu")))
    },
    {
        key: 'editor/context',
        id: MenuId.EditorContext,
        description: ( (localize('menus.editorContext', "The editor context menu")))
    },
    {
        key: 'editor/context/copy',
        id: MenuId.EditorContextCopy,
        description: ( (localize(
            'menus.editorContextCopyAs',
            "'Copy as' submenu in the editor context menu"
        )))
    },
    {
        key: 'editor/context/share',
        id: MenuId.EditorContextShare,
        description: ( (localize('menus.editorContextShare', "'Share' submenu in the editor context menu"))),
        proposed: 'contribShareMenu'
    },
    {
        key: 'explorer/context',
        id: MenuId.ExplorerContext,
        description: ( (localize('menus.explorerContext', "The file explorer context menu")))
    },
    {
        key: 'editor/title/context',
        id: MenuId.EditorTitleContext,
        description: ( (localize('menus.editorTabContext', "The editor tabs context menu")))
    },
    {
        key: 'debug/callstack/context',
        id: MenuId.DebugCallStackContext,
        description: ( (localize('menus.debugCallstackContext', "The debug callstack view context menu")))
    },
    {
        key: 'debug/variables/context',
        id: MenuId.DebugVariablesContext,
        description: ( (localize('menus.debugVariablesContext', "The debug variables view context menu")))
    },
    {
        key: 'debug/toolBar',
        id: MenuId.DebugToolBar,
        description: ( (localize('menus.debugToolBar', "The debug toolbar menu")))
    },
    {
        key: 'menuBar/home',
        id: MenuId.MenubarHomeMenu,
        description: ( (localize('menus.home', "The home indicator context menu (web only)"))),
        proposed: 'contribMenuBarHome',
        supportsSubmenus: false
    },
    {
        key: 'menuBar/edit/copy',
        id: MenuId.MenubarCopy,
        description: ( (localize('menus.opy', "'Copy as' submenu in the top level Edit menu")))
    },
    {
        key: 'scm/title',
        id: MenuId.SCMTitle,
        description: ( (localize('menus.scmTitle', "The Source Control title menu")))
    },
    {
        key: 'scm/sourceControl',
        id: MenuId.SCMSourceControl,
        description: ( (localize('menus.scmSourceControl', "The Source Control menu")))
    },
    {
        key: 'scm/resourceState/context',
        id: MenuId.SCMResourceContext,
        description: ( (localize(
            'menus.resourceStateContext',
            "The Source Control resource state context menu"
        )))
    },
    {
        key: 'scm/resourceFolder/context',
        id: MenuId.SCMResourceFolderContext,
        description: ( (localize(
            'menus.resourceFolderContext',
            "The Source Control resource folder context menu"
        )))
    },
    {
        key: 'scm/resourceGroup/context',
        id: MenuId.SCMResourceGroupContext,
        description: ( (localize(
            'menus.resourceGroupContext',
            "The Source Control resource group context menu"
        )))
    },
    {
        key: 'scm/change/title',
        id: MenuId.SCMChangeContext,
        description: ( (localize('menus.changeTitle', "The Source Control inline change menu")))
    },
    {
        key: 'statusBar/remoteIndicator',
        id: MenuId.StatusBarRemoteIndicatorMenu,
        description: ( (localize(
            'menus.statusBarRemoteIndicator',
            "The remote indicator menu in the status bar"
        ))),
        supportsSubmenus: false
    },
    {
        key: 'view/title',
        id: MenuId.ViewTitle,
        description: ( (localize('view.viewTitle', "The contributed view title menu")))
    },
    {
        key: 'view/item/context',
        id: MenuId.ViewItemContext,
        description: ( (localize('view.itemContext', "The contributed view item context menu")))
    },
    {
        key: 'comments/commentThread/title',
        id: MenuId.CommentThreadTitle,
        description: ( (localize('commentThread.title', "The contributed comment thread title menu")))
    },
    {
        key: 'comments/commentThread/context',
        id: MenuId.CommentThreadActions,
        description: ( (localize(
            'commentThread.actions',
            "The contributed comment thread context menu, rendered as buttons below the comment editor"
        ))),
        supportsSubmenus: false
    },
    {
        key: 'comments/comment/title',
        id: MenuId.CommentTitle,
        description: ( (localize('comment.title', "The contributed comment title menu")))
    },
    {
        key: 'comments/comment/context',
        id: MenuId.CommentActions,
        description: ( (localize(
            'comment.actions',
            "The contributed comment context menu, rendered as buttons below the comment editor"
        ))),
        supportsSubmenus: false
    },
    {
        key: 'notebook/toolbar',
        id: MenuId.NotebookToolbar,
        description: ( (localize('notebook.toolbar', "The contributed notebook toolbar menu")))
    },
    {
        key: 'notebook/kernelSource',
        id: MenuId.NotebookKernelSource,
        description: ( (localize('notebook.kernelSource', "The contributed notebook kernel sources menu"))),
        proposed: 'notebookKernelSource'
    },
    {
        key: 'notebook/cell/title',
        id: MenuId.NotebookCellTitle,
        description: ( (localize('notebook.cell.title', "The contributed notebook cell title menu")))
    },
    {
        key: 'notebook/cell/execute',
        id: MenuId.NotebookCellExecute,
        description: ( (localize('notebook.cell.execute', "The contributed notebook cell execution menu")))
    },
    {
        key: 'notebook/cell/executePrimary',
        id: MenuId.NotebookCellExecutePrimary,
        description: ( (localize(
            'notebook.cell.executePrimary',
            "The contributed primary notebook cell execution button"
        ))),
        proposed: 'notebookEditor'
    },
    {
        key: 'interactive/toolbar',
        id: MenuId.InteractiveToolbar,
        description: ( (localize('interactive.toolbar', "The contributed interactive toolbar menu"))),
    },
    {
        key: 'interactive/cell/title',
        id: MenuId.InteractiveCellTitle,
        description: ( (localize('interactive.cell.title', "The contributed interactive cell title menu"))),
    },
    {
        key: 'testing/item/context',
        id: MenuId.TestItem,
        description: ( (localize('testing.item.context', "The contributed test item menu"))),
    },
    {
        key: 'testing/item/gutter',
        id: MenuId.TestItemGutter,
        description: ( (localize(
            'testing.item.gutter.title',
            "The menu for a gutter decoration for a test item"
        ))),
    },
    {
        key: 'extension/context',
        id: MenuId.ExtensionContext,
        description: ( (localize('menus.extensionContext', "The extension context menu")))
    },
    {
        key: 'timeline/title',
        id: MenuId.TimelineTitle,
        description: ( (localize('view.timelineTitle', "The Timeline view title menu")))
    },
    {
        key: 'timeline/item/context',
        id: MenuId.TimelineItemContext,
        description: ( (localize('view.timelineContext', "The Timeline view item context menu")))
    },
    {
        key: 'ports/item/context',
        id: MenuId.TunnelContext,
        description: ( (localize('view.tunnelContext', "The Ports view item context menu")))
    },
    {
        key: 'ports/item/origin/inline',
        id: MenuId.TunnelOriginInline,
        description: ( (localize('view.tunnelOriginInline', "The Ports view item origin inline menu")))
    },
    {
        key: 'ports/item/port/inline',
        id: MenuId.TunnelPortInline,
        description: ( (localize('view.tunnelPortInline', "The Ports view item port inline menu")))
    },
    {
        key: 'file/newFile',
        id: MenuId.NewFile,
        description: ( (localize(
            'file.newFile',
            "The 'New File...' quick pick, shown on welcome page and File menu."
        ))),
        supportsSubmenus: false,
    },
    {
        key: 'file/share',
        id: MenuId.MenubarShare,
        description: ( (localize('menus.share', "Share submenu shown in the top level File menu."))),
        proposed: 'contribShareMenu'
    },
    {
        key: 'editor/inlineCompletions/actions',
        id: MenuId.InlineCompletionsActions,
        description: ( (localize(
            'inlineCompletions.actions',
            "The actions shown when hovering on an inline completion"
        ))),
        supportsSubmenus: false,
        proposed: 'inlineCompletionsAdditions'
    },
    {
        key: 'merge/toolbar',
        id: MenuId.MergeToolbar,
        description: ( (localize('merge.toolbar', "The prominent botton in the merge editor"))),
        proposed: 'contribMergeEditorToolbar'
    },
    {
        key: 'webview/context',
        id: MenuId.WebviewContext,
        description: ( (localize('webview.context', "The webview context menu"))),
        proposed: 'contribWebviewContext'
    },
];
var schema$1;
( ((function(schema) {
    function isMenuItem(item) {
        return typeof item.command === 'string';
    }
    schema.isMenuItem = isMenuItem;
    function isValidMenuItem(item, collector) {
        if (typeof item.command !== 'string') {
            collector.error(( (localize(
                'requirestring',
                "property `{0}` is mandatory and must be of type `string`",
                'command'
            ))));
            return false;
        }
        if (item.alt && typeof item.alt !== 'string') {
            collector.error(( (localize(
                'optstring',
                "property `{0}` can be omitted or must be of type `string`",
                'alt'
            ))));
            return false;
        }
        if (item.when && typeof item.when !== 'string') {
            collector.error(( (localize(
                'optstring',
                "property `{0}` can be omitted or must be of type `string`",
                'when'
            ))));
            return false;
        }
        if (item.group && typeof item.group !== 'string') {
            collector.error(( (localize(
                'optstring',
                "property `{0}` can be omitted or must be of type `string`",
                'group'
            ))));
            return false;
        }
        return true;
    }
    schema.isValidMenuItem = isValidMenuItem;
    function isValidSubmenuItem(item, collector) {
        if (typeof item.submenu !== 'string') {
            collector.error(( (localize(
                'requirestring',
                "property `{0}` is mandatory and must be of type `string`",
                'submenu'
            ))));
            return false;
        }
        if (item.when && typeof item.when !== 'string') {
            collector.error(( (localize(
                'optstring',
                "property `{0}` can be omitted or must be of type `string`",
                'when'
            ))));
            return false;
        }
        if (item.group && typeof item.group !== 'string') {
            collector.error(( (localize(
                'optstring',
                "property `{0}` can be omitted or must be of type `string`",
                'group'
            ))));
            return false;
        }
        return true;
    }
    schema.isValidSubmenuItem = isValidSubmenuItem;
    function isValidItems(items, collector) {
        if (!Array.isArray(items)) {
            collector.error(( (localize('requirearray', "submenu items must be an array"))));
            return false;
        }
        for (const item of items) {
            if (isMenuItem(item)) {
                if (!isValidMenuItem(item, collector)) {
                    return false;
                }
            }
            else {
                if (!isValidSubmenuItem(item, collector)) {
                    return false;
                }
            }
        }
        return true;
    }
    schema.isValidItems = isValidItems;
    function isValidSubmenu(submenu, collector) {
        if (typeof submenu !== 'object') {
            collector.error(( (localize('require', "submenu items must be an object"))));
            return false;
        }
        if (typeof submenu.id !== 'string') {
            collector.error(( (localize(
                'requirestring',
                "property `{0}` is mandatory and must be of type `string`",
                'id'
            ))));
            return false;
        }
        if (typeof submenu.label !== 'string') {
            collector.error(( (localize(
                'requirestring',
                "property `{0}` is mandatory and must be of type `string`",
                'label'
            ))));
            return false;
        }
        return true;
    }
    schema.isValidSubmenu = isValidSubmenu;
    const menuItem = {
        type: 'object',
        required: ['command'],
        properties: {
            command: {
                description: ( (localize(
                    'vscode.extension.contributes.menuItem.command',
                    'Identifier of the command to execute. The command must be declared in the \'commands\'-section'
                ))),
                type: 'string'
            },
            alt: {
                description: ( (localize(
                    'vscode.extension.contributes.menuItem.alt',
                    'Identifier of an alternative command to execute. The command must be declared in the \'commands\'-section'
                ))),
                type: 'string'
            },
            when: {
                description: ( (localize(
                    'vscode.extension.contributes.menuItem.when',
                    'Condition which must be true to show this item'
                ))),
                type: 'string'
            },
            group: {
                description: ( (localize(
                    'vscode.extension.contributes.menuItem.group',
                    'Group into which this item belongs'
                ))),
                type: 'string'
            }
        }
    };
    const submenuItem = {
        type: 'object',
        required: ['submenu'],
        properties: {
            submenu: {
                description: ( (localize(
                    'vscode.extension.contributes.menuItem.submenu',
                    'Identifier of the submenu to display in this item.'
                ))),
                type: 'string'
            },
            when: {
                description: ( (localize(
                    'vscode.extension.contributes.menuItem.when',
                    'Condition which must be true to show this item'
                ))),
                type: 'string'
            },
            group: {
                description: ( (localize(
                    'vscode.extension.contributes.menuItem.group',
                    'Group into which this item belongs'
                ))),
                type: 'string'
            }
        }
    };
    const submenu = {
        type: 'object',
        required: ['id', 'label'],
        properties: {
            id: {
                description: ( (localize(
                    'vscode.extension.contributes.submenu.id',
                    'Identifier of the menu to display as a submenu.'
                ))),
                type: 'string'
            },
            label: {
                description: ( (localize(
                    'vscode.extension.contributes.submenu.label',
                    'The label of the menu item which leads to this submenu.'
                ))),
                type: 'string'
            },
            icon: {
                description: ( (localize(
                    { key: 'vscode.extension.contributes.submenu.icon', comment: ['do not translate or change `\\$(zap)`, \\ in front of $ is important.'] },
                    '(Optional) Icon which is used to represent the submenu in the UI. Either a file path, an object with file paths for dark and light themes, or a theme icon references, like `\\$(zap)`'
                ))),
                anyOf: [{
                        type: 'string'
                    },
                    {
                        type: 'object',
                        properties: {
                            light: {
                                description: ( (localize(
                                    'vscode.extension.contributes.submenu.icon.light',
                                    'Icon path when a light theme is used'
                                ))),
                                type: 'string'
                            },
                            dark: {
                                description: ( (localize(
                                    'vscode.extension.contributes.submenu.icon.dark',
                                    'Icon path when a dark theme is used'
                                ))),
                                type: 'string'
                            }
                        }
                    }]
            }
        }
    };
    schema.menusContribution = {
        description: ( (localize(
            'vscode.extension.contributes.menus',
            "Contributes menu items to the editor"
        ))),
        type: 'object',
        properties: index(apiMenus, menu => menu.key, menu => ({
            markdownDescription: menu.proposed ? ( (localize(
                'proposed',
                "Proposed API, requires `enabledApiProposal: [\"{0}\"]` - {1}",
                menu.proposed,
                menu.description
            ))) : menu.description,
            type: 'array',
            items: menu.supportsSubmenus === false ? menuItem : { oneOf: [menuItem, submenuItem] }
        })),
        additionalProperties: {
            description: 'Submenu',
            type: 'array',
            items: { oneOf: [menuItem, submenuItem] }
        }
    };
    schema.submenusContribution = {
        description: ( (localize(
            'vscode.extension.contributes.submenus',
            "Contributes submenu items to the editor"
        ))),
        type: 'array',
        items: submenu
    };
    function isValidCommand(command, collector) {
        if (!command) {
            collector.error(( (localize('nonempty', "expected non-empty value."))));
            return false;
        }
        if (isFalsyOrWhitespace(command.command)) {
            collector.error(( (localize(
                'requirestring',
                "property `{0}` is mandatory and must be of type `string`",
                'command'
            ))));
            return false;
        }
        if (!isValidLocalizedString(command.title, collector, 'title')) {
            return false;
        }
        if (command.shortTitle && !isValidLocalizedString(command.shortTitle, collector, 'shortTitle')) {
            return false;
        }
        if (command.enablement && typeof command.enablement !== 'string') {
            collector.error(( (localize(
                'optstring',
                "property `{0}` can be omitted or must be of type `string`",
                'precondition'
            ))));
            return false;
        }
        if (command.category && !isValidLocalizedString(command.category, collector, 'category')) {
            return false;
        }
        if (!isValidIcon(command.icon, collector)) {
            return false;
        }
        return true;
    }
    schema.isValidCommand = isValidCommand;
    function isValidIcon(icon, collector) {
        if (typeof icon === 'undefined') {
            return true;
        }
        if (typeof icon === 'string') {
            return true;
        }
        else if (typeof icon.dark === 'string' && typeof icon.light === 'string') {
            return true;
        }
        collector.error(( (localize(
            'opticon',
            "property `icon` can be omitted or must be either a string or a literal like `{dark, light}`"
        ))));
        return false;
    }
    function isValidLocalizedString(localized, collector, propertyName) {
        if (typeof localized === 'undefined') {
            collector.error(( (localize(
                'requireStringOrObject',
                "property `{0}` is mandatory and must be of type `string` or `object`",
                propertyName
            ))));
            return false;
        }
        else if (typeof localized === 'string' && isFalsyOrWhitespace(localized)) {
            collector.error(( (localize(
                'requirestring',
                "property `{0}` is mandatory and must be of type `string`",
                propertyName
            ))));
            return false;
        }
        else if (typeof localized !== 'string' && (isFalsyOrWhitespace(localized.original) || isFalsyOrWhitespace(localized.value))) {
            collector.error(( (localize(
                'requirestrings',
                "properties `{0}` and `{1}` are mandatory and must be of type `string`",
                `${propertyName}.value`,
                `${propertyName}.original`
            ))));
            return false;
        }
        return true;
    }
    const commandType = {
        type: 'object',
        required: ['command', 'title'],
        properties: {
            command: {
                description: ( (localize(
                    'vscode.extension.contributes.commandType.command',
                    'Identifier of the command to execute'
                ))),
                type: 'string'
            },
            title: {
                description: ( (localize(
                    'vscode.extension.contributes.commandType.title',
                    'Title by which the command is represented in the UI'
                ))),
                type: 'string'
            },
            shortTitle: {
                markdownDescription: ( (localize(
                    'vscode.extension.contributes.commandType.shortTitle',
                    '(Optional) Short title by which the command is represented in the UI. Menus pick either `title` or `shortTitle` depending on the context in which they show commands.'
                ))),
                type: 'string'
            },
            category: {
                description: ( (localize(
                    'vscode.extension.contributes.commandType.category',
                    '(Optional) Category string by which the command is grouped in the UI'
                ))),
                type: 'string'
            },
            enablement: {
                description: ( (localize(
                    'vscode.extension.contributes.commandType.precondition',
                    '(Optional) Condition which must be true to enable the command in the UI (menu and keybindings). Does not prevent executing the command by other means, like the `executeCommand`-api.'
                ))),
                type: 'string'
            },
            icon: {
                description: ( (localize(
                    { key: 'vscode.extension.contributes.commandType.icon', comment: ['do not translate or change `\\$(zap)`, \\ in front of $ is important.'] },
                    '(Optional) Icon which is used to represent the command in the UI. Either a file path, an object with file paths for dark and light themes, or a theme icon references, like `\\$(zap)`'
                ))),
                anyOf: [{
                        type: 'string'
                    },
                    {
                        type: 'object',
                        properties: {
                            light: {
                                description: ( (localize(
                                    'vscode.extension.contributes.commandType.icon.light',
                                    'Icon path when a light theme is used'
                                ))),
                                type: 'string'
                            },
                            dark: {
                                description: ( (localize(
                                    'vscode.extension.contributes.commandType.icon.dark',
                                    'Icon path when a dark theme is used'
                                ))),
                                type: 'string'
                            }
                        }
                    }]
            }
        }
    };
    schema.commandsContribution = {
        description: ( (localize(
            'vscode.extension.contributes.commands',
            "Contributes commands to the command palette."
        ))),
        oneOf: [
            commandType,
            {
                type: 'array',
                items: commandType
            }
        ]
    };
})(schema$1 || (schema$1 = {}))));
const _commandRegistrations = ( (new DisposableStore()));
const commandsExtensionPoint$1 = ( (ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'commands',
    jsonSchema: schema$1.commandsContribution
})));
commandsExtensionPoint$1.setHandler(extensions => {
    function handleCommand(userFriendlyCommand, extension, bucket) {
        if (!schema$1.isValidCommand(userFriendlyCommand, extension.collector)) {
            return;
        }
        const { icon, enablement, category, title, shortTitle, command } = userFriendlyCommand;
        let absoluteIcon;
        if (icon) {
            if (typeof icon === 'string') {
                absoluteIcon = ThemeIcon.fromString(icon) ?? { dark: joinPath(extension.description.extensionLocation, icon), light: joinPath(extension.description.extensionLocation, icon) };
            }
            else {
                absoluteIcon = {
                    dark: joinPath(extension.description.extensionLocation, icon.dark),
                    light: joinPath(extension.description.extensionLocation, icon.light)
                };
            }
        }
        if (MenuRegistry.getCommand(command)) {
            extension.collector.info(( (localize(
                'dup',
                "Command `{0}` appears multiple times in the `commands` section.",
                userFriendlyCommand.command
            ))));
        }
        bucket.push({
            id: command,
            title,
            source: extension.description.displayName ?? extension.description.name,
            shortTitle,
            tooltip: title,
            category,
            precondition: ContextKeyExpr.deserialize(enablement),
            icon: absoluteIcon
        });
    }
    _commandRegistrations.clear();
    const newCommands = [];
    for (const extension of extensions) {
        const { value } = extension;
        if (Array.isArray(value)) {
            for (const command of value) {
                handleCommand(command, extension, newCommands);
            }
        }
        else {
            handleCommand(value, extension, newCommands);
        }
    }
    _commandRegistrations.add(MenuRegistry.addCommands(newCommands));
});
const _submenus = ( (new Map()));
const submenusExtensionPoint = ( (ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'submenus',
    jsonSchema: schema$1.submenusContribution
})));
submenusExtensionPoint.setHandler(extensions => {
    _submenus.clear();
    for (const extension of extensions) {
        const { value, collector } = extension;
        for (const [, submenuInfo] of Object.entries(value)) {
            if (!schema$1.isValidSubmenu(submenuInfo, collector)) {
                return;
            }
            if (!submenuInfo.id) {
                collector.warn(( (localize(
                    'submenuId.invalid.id',
                    "`{0}` is not a valid submenu identifier",
                    submenuInfo.id
                ))));
                return;
            }
            if (_submenus.has(submenuInfo.id)) {
                collector.info(( (localize(
                    'submenuId.duplicate.id',
                    "The `{0}` submenu was already previously registered.",
                    submenuInfo.id
                ))));
                return;
            }
            if (!submenuInfo.label) {
                collector.warn(( (localize(
                    'submenuId.invalid.label',
                    "`{0}` is not a valid submenu label",
                    submenuInfo.label
                ))));
                return;
            }
            let absoluteIcon;
            if (submenuInfo.icon) {
                if (typeof submenuInfo.icon === 'string') {
                    absoluteIcon = ThemeIcon.fromString(submenuInfo.icon) || { dark: joinPath(extension.description.extensionLocation, submenuInfo.icon) };
                }
                else {
                    absoluteIcon = {
                        dark: joinPath(extension.description.extensionLocation, submenuInfo.icon.dark),
                        light: joinPath(extension.description.extensionLocation, submenuInfo.icon.light)
                    };
                }
            }
            const item = {
                id: MenuId.for(`api:${submenuInfo.id}`),
                label: submenuInfo.label,
                icon: absoluteIcon
            };
            _submenus.set(submenuInfo.id, item);
        }
    }
});
const _apiMenusByKey = ( (new Map(Iterable.map(Iterable.from(apiMenus), menu => ([menu.key, menu])))));
const _menuRegistrations = ( (new DisposableStore()));
const _submenuMenuItems = ( (new Map()));
const menusExtensionPoint = ( (ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'menus',
    jsonSchema: schema$1.menusContribution,
    deps: [submenusExtensionPoint]
})));
menusExtensionPoint.setHandler(extensions => {
    _menuRegistrations.clear();
    _submenuMenuItems.clear();
    const items = [];
    for (const extension of extensions) {
        const { value, collector } = extension;
        for (const entry of Object.entries(value)) {
            if (!schema$1.isValidItems(entry[1], collector)) {
                continue;
            }
            let menu = _apiMenusByKey.get(entry[0]);
            if (!menu) {
                const submenu = _submenus.get(entry[0]);
                if (submenu) {
                    menu = {
                        key: entry[0],
                        id: submenu.id,
                        description: ''
                    };
                }
            }
            if (!menu) {
                continue;
            }
            if (menu.proposed && !isProposedApiEnabled(extension.description, menu.proposed)) {
                collector.error(( (localize(
                    'proposedAPI.invalid',
                    "{0} is a proposed menu identifier. It requires 'package.json#enabledApiProposals: [\"{1}\"]' and is only available when running out of dev or with the following command line switch: --enable-proposed-api {2}",
                    entry[0],
                    menu.proposed,
                    extension.description.identifier.value
                ))));
                continue;
            }
            for (const menuItem of entry[1]) {
                let item;
                if (schema$1.isMenuItem(menuItem)) {
                    const command = MenuRegistry.getCommand(menuItem.command);
                    const alt = menuItem.alt && MenuRegistry.getCommand(menuItem.alt) || undefined;
                    if (!command) {
                        collector.error(( (localize(
                            'missing.command',
                            "Menu item references a command `{0}` which is not defined in the 'commands' section.",
                            menuItem.command
                        ))));
                        continue;
                    }
                    if (menuItem.alt && !alt) {
                        collector.warn(( (localize(
                            'missing.altCommand',
                            "Menu item references an alt-command `{0}` which is not defined in the 'commands' section.",
                            menuItem.alt
                        ))));
                    }
                    if (menuItem.command === menuItem.alt) {
                        collector.info(( (localize(
                            'dupe.command',
                            "Menu item references the same command as default and alt-command"
                        ))));
                    }
                    item = { command, alt, group: undefined, order: undefined, when: undefined };
                }
                else {
                    if (menu.supportsSubmenus === false) {
                        collector.error(( (localize(
                            'unsupported.submenureference',
                            "Menu item references a submenu for a menu which doesn't have submenu support."
                        ))));
                        continue;
                    }
                    const submenu = _submenus.get(menuItem.submenu);
                    if (!submenu) {
                        collector.error(( (localize(
                            'missing.submenu',
                            "Menu item references a submenu `{0}` which is not defined in the 'submenus' section.",
                            menuItem.submenu
                        ))));
                        continue;
                    }
                    let submenuRegistrations = _submenuMenuItems.get(menu.id.id);
                    if (!submenuRegistrations) {
                        submenuRegistrations = ( (new Set()));
                        _submenuMenuItems.set(menu.id.id, submenuRegistrations);
                    }
                    if (submenuRegistrations.has(submenu.id.id)) {
                        collector.warn(( (localize(
                            'submenuItem.duplicate',
                            "The `{0}` submenu was already contributed to the `{1}` menu.",
                            menuItem.submenu,
                            entry[0]
                        ))));
                        continue;
                    }
                    submenuRegistrations.add(submenu.id.id);
                    item = { submenu: submenu.id, icon: submenu.icon, title: submenu.label, group: undefined, order: undefined, when: undefined };
                }
                if (menuItem.group) {
                    const idx = menuItem.group.lastIndexOf('@');
                    if (idx > 0) {
                        item.group = menuItem.group.substr(0, idx);
                        item.order = Number(menuItem.group.substr(idx + 1)) || undefined;
                    }
                    else {
                        item.group = menuItem.group;
                    }
                }
                item.when = ContextKeyExpr.deserialize(menuItem.when);
                items.push({ id: menu.id, item });
            }
        }
    }
    _menuRegistrations.add(MenuRegistry.appendMenuItems(items));
});
function getAllUnboundCommands(boundCommands) {
    const unboundCommands = [];
    const seenMap = ( (new Map()));
    const addCommand = (id, includeCommandWithArgs) => {
        if (seenMap.has(id)) {
            return;
        }
        seenMap.set(id, true);
        if (id[0] === '_' || id.indexOf('vscode.') === 0) {
            return;
        }
        if (boundCommands.get(id) === true) {
            return;
        }
        if (!includeCommandWithArgs) {
            const command = CommandsRegistry.getCommand(id);
            if (command && typeof command.description === 'object'
                && isNonEmptyArray(command.description.args)) {
                return;
            }
        }
        unboundCommands.push(id);
    };
    for (const menuItem of MenuRegistry.getMenuItems(MenuId.CommandPalette)) {
        if (isIMenuItem(menuItem)) {
            addCommand(menuItem.command.id, true);
        }
    }
    for (const editorAction of EditorExtensionsRegistry.getEditorActions()) {
        addCommand(editorAction.id, true);
    }
    for (const id of ( (CommandsRegistry.getCommands().keys()))) {
        addCommand(id, false);
    }
    return unboundCommands;
}
class KeybindingParser {
    static _readModifiers(input) {
        input = input.toLowerCase().trim();
        let ctrl = false;
        let shift = false;
        let alt = false;
        let meta = false;
        let matchedModifier;
        do {
            matchedModifier = false;
            if (/^ctrl(\+|\-)/.test(input)) {
                ctrl = true;
                input = input.substr('ctrl-'.length);
                matchedModifier = true;
            }
            if (/^shift(\+|\-)/.test(input)) {
                shift = true;
                input = input.substr('shift-'.length);
                matchedModifier = true;
            }
            if (/^alt(\+|\-)/.test(input)) {
                alt = true;
                input = input.substr('alt-'.length);
                matchedModifier = true;
            }
            if (/^meta(\+|\-)/.test(input)) {
                meta = true;
                input = input.substr('meta-'.length);
                matchedModifier = true;
            }
            if (/^win(\+|\-)/.test(input)) {
                meta = true;
                input = input.substr('win-'.length);
                matchedModifier = true;
            }
            if (/^cmd(\+|\-)/.test(input)) {
                meta = true;
                input = input.substr('cmd-'.length);
                matchedModifier = true;
            }
        } while (matchedModifier);
        let key;
        const firstSpaceIdx = input.indexOf(' ');
        if (firstSpaceIdx > 0) {
            key = input.substring(0, firstSpaceIdx);
            input = input.substring(firstSpaceIdx);
        }
        else {
            key = input;
            input = '';
        }
        return {
            remains: input,
            ctrl,
            shift,
            alt,
            meta,
            key
        };
    }
    static parseSimpleKeybinding(input) {
        const mods = this._readModifiers(input);
        const keyCode = KeyCodeUtils.fromUserSettings(mods.key);
        return [( (new SimpleKeybinding(mods.ctrl, mods.shift, mods.alt, mods.meta, keyCode))), mods.remains];
    }
    static parseKeybinding(input, OS) {
        if (!input) {
            return null;
        }
        const parts = [];
        let part;
        do {
            [part, input] = this.parseSimpleKeybinding(input);
            parts.push(part);
        } while (input.length > 0);
        return (
             (new ChordKeybinding(parts))
        );
    }
    static parseSimpleUserBinding(input) {
        const mods = this._readModifiers(input);
        const scanCodeMatch = mods.key.match(/^\[([^\]]+)\]$/);
        if (scanCodeMatch) {
            const strScanCode = scanCodeMatch[1];
            const scanCode = ScanCodeUtils.lowerCaseToEnum(strScanCode);
            return [( (new ScanCodeBinding(mods.ctrl, mods.shift, mods.alt, mods.meta, scanCode))), mods.remains];
        }
        const keyCode = KeyCodeUtils.fromUserSettings(mods.key);
        return [( (new SimpleKeybinding(mods.ctrl, mods.shift, mods.alt, mods.meta, keyCode))), mods.remains];
    }
    static parseUserBinding(input) {
        if (!input) {
            return [];
        }
        const parts = [];
        let part;
        while (input.length > 0) {
            [part, input] = this.parseSimpleUserBinding(input);
            parts.push(part);
        }
        return parts;
    }
}
class KeybindingIO {
    static writeKeybindingItem(out, item) {
        if (!item.resolvedKeybinding) {
            return;
        }
        const quotedSerializedKeybinding = JSON.stringify(item.resolvedKeybinding.getUserSettingsLabel());
        out.write(`{ "key": ${rightPaddedString(quotedSerializedKeybinding + ',', 25)} "command": `);
        const quotedSerializedWhen = item.when ? JSON.stringify(item.when.serialize()) : '';
        const quotedSerializeCommand = JSON.stringify(item.command);
        if (quotedSerializedWhen.length > 0) {
            out.write(`${quotedSerializeCommand},`);
            out.writeLine();
            out.write(`                                     "when": ${quotedSerializedWhen}`);
        }
        else {
            out.write(`${quotedSerializeCommand}`);
        }
        if (item.commandArgs) {
            out.write(',');
            out.writeLine();
            out.write(`                                     "args": ${JSON.stringify(item.commandArgs)}`);
        }
        out.write(' }');
    }
    static readUserKeybindingItem(input) {
        const parts = (typeof input.key === 'string' ? KeybindingParser.parseUserBinding(input.key) : []);
        const when = (typeof input.when === 'string' ? ContextKeyExpr.deserialize(input.when) : undefined);
        const command = (typeof input.command === 'string' ? input.command : null);
        const commandArgs = (typeof input.args !== 'undefined' ? input.args : undefined);
        return {
            parts: parts,
            command: command,
            commandArgs: commandArgs,
            when: when
        };
    }
}
function rightPaddedString(str, minChars) {
    if (str.length < minChars) {
        return str + (( (new Array(minChars - str.length))).join(' '));
    }
    return str;
}
class OutputBuilder {
    constructor() {
        this._lines = [];
        this._currentLine = '';
    }
    write(str) {
        this._currentLine += str;
    }
    writeLine(str = '') {
        this._lines.push(this._currentLine + str);
        this._currentLine = '';
    }
    toString() {
        this.writeLine();
        return this._lines.join('\n');
    }
}
function getDispatchConfig(configurationService) {
    const keyboard = configurationService.getValue('keyboard');
    const r = (keyboard ? keyboard.dispatch : null);
    return (r === 'keyCode' ? 1  : 0) ;
}
function isContributedKeyBindingsArray(thing) {
    return Array.isArray(thing);
}
function isValidContributedKeyBinding(keyBinding, rejects) {
    if (!keyBinding) {
        rejects.push(( (localize('nonempty', "expected non-empty value."))));
        return false;
    }
    if (typeof keyBinding.command !== 'string') {
        rejects.push(( (localize(
            'requirestring',
            "property `{0}` is mandatory and must be of type `string`",
            'command'
        ))));
        return false;
    }
    if (keyBinding.key && typeof keyBinding.key !== 'string') {
        rejects.push(( (localize(
            'optstring',
            "property `{0}` can be omitted or must be of type `string`",
            'key'
        ))));
        return false;
    }
    if (keyBinding.when && typeof keyBinding.when !== 'string') {
        rejects.push(( (localize(
            'optstring',
            "property `{0}` can be omitted or must be of type `string`",
            'when'
        ))));
        return false;
    }
    if (keyBinding.mac && typeof keyBinding.mac !== 'string') {
        rejects.push(( (localize(
            'optstring',
            "property `{0}` can be omitted or must be of type `string`",
            'mac'
        ))));
        return false;
    }
    if (keyBinding.linux && typeof keyBinding.linux !== 'string') {
        rejects.push(( (localize(
            'optstring',
            "property `{0}` can be omitted or must be of type `string`",
            'linux'
        ))));
        return false;
    }
    if (keyBinding.win && typeof keyBinding.win !== 'string') {
        rejects.push(( (localize(
            'optstring',
            "property `{0}` can be omitted or must be of type `string`",
            'win'
        ))));
        return false;
    }
    return true;
}
const keybindingType = {
    type: 'object',
    default: { command: '', key: '' },
    properties: {
        command: {
            description: ( (localize(
                'vscode.extension.contributes.keybindings.command',
                'Identifier of the command to run when keybinding is triggered.'
            ))),
            type: 'string'
        },
        args: {
            description: ( (localize(
                'vscode.extension.contributes.keybindings.args',
                "Arguments to pass to the command to execute."
            )))
        },
        key: {
            description: ( (localize(
                'vscode.extension.contributes.keybindings.key',
                'Key or key sequence (separate keys with plus-sign and sequences with space, e.g. Ctrl+O and Ctrl+L L for a chord).'
            ))),
            type: 'string'
        },
        mac: {
            description: ( (localize(
                'vscode.extension.contributes.keybindings.mac',
                'Mac specific key or key sequence.'
            ))),
            type: 'string'
        },
        linux: {
            description: ( (localize(
                'vscode.extension.contributes.keybindings.linux',
                'Linux specific key or key sequence.'
            ))),
            type: 'string'
        },
        win: {
            description: ( (localize(
                'vscode.extension.contributes.keybindings.win',
                'Windows specific key or key sequence.'
            ))),
            type: 'string'
        },
        when: {
            description: ( (localize(
                'vscode.extension.contributes.keybindings.when',
                'Condition when the key is active.'
            ))),
            type: 'string'
        },
    }
};
const keybindingsExtPoint = ( (ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'keybindings',
    deps: [commandsExtensionPoint$1],
    jsonSchema: {
        description: ( (localize('vscode.extension.contributes.keybindings', "Contributes keybindings."))),
        oneOf: [
            keybindingType,
            {
                type: 'array',
                items: keybindingType
            }
        ]
    }
})));
const NUMPAD_PRINTABLE_SCANCODES = [
    90 ,
    91 ,
    92 ,
    93 ,
    95 ,
    96 ,
    97 ,
    98 ,
    99 ,
    100 ,
    101 ,
    102 ,
    103 ,
    104 ,
    105
];
const otherMacNumpadMapping = ( (new Map()));
otherMacNumpadMapping.set(95 , 22 );
otherMacNumpadMapping.set(96 , 23 );
otherMacNumpadMapping.set(97 , 24 );
otherMacNumpadMapping.set(98 , 25 );
otherMacNumpadMapping.set(99 , 26 );
otherMacNumpadMapping.set(100 , 27 );
otherMacNumpadMapping.set(101 , 28 );
otherMacNumpadMapping.set(102 , 29 );
otherMacNumpadMapping.set(103 , 30 );
otherMacNumpadMapping.set(104 , 21 );
let WorkbenchKeybindingService = class WorkbenchKeybindingService extends AbstractKeybindingService {
    constructor(contextKeyService, commandService, telemetryService, notificationService, userDataProfileService, configurationService, hostService, extensionService, fileService, logService, keyboardLayoutService) {
        super(contextKeyService, commandService, telemetryService, notificationService, logService);
        this.hostService = hostService;
        this.keyboardLayoutService = keyboardLayoutService;
        this._contributions = [];
        this.isComposingGlobalContextKey = contextKeyService.createKey('isComposing', false);
        this.updateSchema();
        let dispatchConfig = getDispatchConfig(configurationService);
        configurationService.onDidChangeConfiguration((e) => {
            const newDispatchConfig = getDispatchConfig(configurationService);
            if (dispatchConfig === newDispatchConfig) {
                return;
            }
            dispatchConfig = newDispatchConfig;
            this._keyboardMapper = this.keyboardLayoutService.getKeyboardMapper(dispatchConfig);
            this.updateResolver();
        });
        this._keyboardMapper = this.keyboardLayoutService.getKeyboardMapper(dispatchConfig);
        this.keyboardLayoutService.onDidChangeKeyboardLayout(() => {
            this._keyboardMapper = this.keyboardLayoutService.getKeyboardMapper(dispatchConfig);
            this.updateResolver();
        });
        this._cachedResolver = null;
        this.userKeybindings = this._register(( (new UserKeybindings(userDataProfileService, fileService, logService))));
        this.userKeybindings.initialize().then(() => {
            if (this.userKeybindings.keybindings.length) {
                this.updateResolver();
            }
        });
        this._register(this.userKeybindings.onDidChange(() => {
            logService.debug('User keybindings changed');
            this.updateResolver();
        }));
        keybindingsExtPoint.setHandler((extensions) => {
            const keybindings = [];
            for (const extension of extensions) {
                this._handleKeybindingsExtensionPointUser(extension.description.identifier, extension.description.isBuiltin, extension.value, extension.collector, keybindings);
            }
            KeybindingsRegistry.setExtensionKeybindings(keybindings);
            this.updateResolver();
        });
        this.updateSchema();
        this._register(extensionService.onDidRegisterExtensions(() => this.updateSchema()));
        this._register(addDisposableListener(window, EventType.KEY_DOWN, (e) => {
            this.isComposingGlobalContextKey.set(e.isComposing);
            const keyEvent = ( (new StandardKeyboardEvent(e)));
            this._log(`/ Received  keydown event - ${printKeyboardEvent(e)}`);
            this._log(`| Converted keydown event - ${printStandardKeyboardEvent(keyEvent)}`);
            const shouldPreventDefault = this._dispatch(keyEvent, keyEvent.target);
            if (shouldPreventDefault) {
                keyEvent.preventDefault();
            }
            this.isComposingGlobalContextKey.set(false);
        }));
        this._register(addDisposableListener(window, EventType.KEY_UP, (e) => {
            this.isComposingGlobalContextKey.set(e.isComposing);
            const keyEvent = ( (new StandardKeyboardEvent(e)));
            const shouldPreventDefault = this._singleModifierDispatch(keyEvent, keyEvent.target);
            if (shouldPreventDefault) {
                keyEvent.preventDefault();
            }
            this.isComposingGlobalContextKey.set(false);
        }));
        this._register(onDidChangeFullscreen(() => {
            const keyboard = navigator.keyboard;
            if (BrowserFeatures.keyboard === 2 ) {
                return;
            }
            if (isFullscreen()) {
                keyboard?.lock(['Escape']);
            }
            else {
                keyboard?.unlock();
            }
            this._cachedResolver = null;
            this._onDidUpdateKeybindings.fire();
        }));
    }
    registerSchemaContribution(contribution) {
        this._contributions.push(contribution);
        if (contribution.onDidChange) {
            this._register(contribution.onDidChange(() => this.updateSchema()));
        }
        this.updateSchema();
    }
    updateSchema() {
        updateSchema(flatten(this._contributions.map(x => x.getSchemaAdditions())));
    }
    _printUserBinding(parts) {
        return UserSettingsLabelProvider.toLabel(OS, parts, (part) => {
            if (part instanceof SimpleKeybinding) {
                return (
                     (KeyCodeUtils.toString(part.keyCode))
                );
            }
            return (
                 (ScanCodeUtils.toString(part.scanCode))
            );
        }) || '[null]';
    }
    _printResolvedKeybinding(resolvedKeybinding) {
        return resolvedKeybinding.getDispatchParts().map(x => x || '[null]').join(' ');
    }
    _printResolvedKeybindings(output, input, resolvedKeybindings) {
        const padLength = 35;
        const firstRow = `${input.padStart(padLength, ' ')} => `;
        if (resolvedKeybindings.length === 0) {
            output.push(`${firstRow}${'[NO BINDING]'.padStart(padLength, ' ')}`);
            return;
        }
        for (const resolvedKeybinding of resolvedKeybindings) {
            {
                output.push(`${firstRow}${this._printResolvedKeybinding(resolvedKeybinding).padStart(padLength, ' ')}`);
            }
        }
    }
    _dumpResolveKeybindingDebugInfo() {
        const seenBindings = ( (new Set()));
        const result = [];
        result.push(`Default Resolved Keybindings (unique only):`);
        for (const item of KeybindingsRegistry.getDefaultKeybindings()) {
            if (!item.keybinding || item.keybinding.length === 0) {
                continue;
            }
            const input = this._printUserBinding(item.keybinding);
            if (seenBindings.has(input)) {
                continue;
            }
            seenBindings.add(input);
            const resolvedKeybindings = this._keyboardMapper.resolveUserBinding(item.keybinding);
            this._printResolvedKeybindings(result, input, resolvedKeybindings);
        }
        result.push(`User Resolved Keybindings (unique only):`);
        for (const _item of this.userKeybindings.keybindings) {
            const item = KeybindingIO.readUserKeybindingItem(_item);
            if (!item.parts || item.parts.length === 0) {
                continue;
            }
            const input = _item.key;
            if (seenBindings.has(input)) {
                continue;
            }
            seenBindings.add(input);
            const resolvedKeybindings = this._keyboardMapper.resolveUserBinding(item.parts);
            this._printResolvedKeybindings(result, input, resolvedKeybindings);
        }
        return result.join('\n');
    }
    _dumpDebugInfo() {
        const layoutInfo = JSON.stringify(this.keyboardLayoutService.getCurrentKeyboardLayout(), null, '\t');
        const mapperInfo = this._keyboardMapper.dumpDebugInfo();
        const resolvedKeybindings = this._dumpResolveKeybindingDebugInfo();
        const rawMapping = JSON.stringify(this.keyboardLayoutService.getRawKeyboardMapping(), null, '\t');
        return `Layout info:\n${layoutInfo}\n\n${resolvedKeybindings}\n\n${mapperInfo}\n\nRaw mapping:\n${rawMapping}`;
    }
    _dumpDebugInfoJSON() {
        const info = {
            layout: this.keyboardLayoutService.getCurrentKeyboardLayout(),
            rawMapping: this.keyboardLayoutService.getRawKeyboardMapping()
        };
        return JSON.stringify(info, null, '\t');
    }
    customKeybindingsCount() {
        return this.userKeybindings.keybindings.length;
    }
    updateResolver() {
        this._cachedResolver = null;
        this._onDidUpdateKeybindings.fire();
    }
    _getResolver() {
        if (!this._cachedResolver) {
            const defaults = this._resolveKeybindingItems(KeybindingsRegistry.getDefaultKeybindings(), true);
            const overrides = this._resolveUserKeybindingItems(this.userKeybindings.keybindings.map((k) => KeybindingIO.readUserKeybindingItem(k)), false);
            this._cachedResolver = ( (new KeybindingResolver(defaults, overrides, (str) => this._log(str))));
        }
        return this._cachedResolver;
    }
    _documentHasFocus() {
        return this.hostService.hasFocus;
    }
    _resolveKeybindingItems(items, isDefault) {
        const result = [];
        let resultLen = 0;
        for (const item of items) {
            const when = item.when || undefined;
            const keybinding = item.keybinding;
            if (!keybinding) {
                result[resultLen++] = ( (new ResolvedKeybindingItem(
                    undefined,
                    item.command,
                    item.commandArgs,
                    when,
                    isDefault,
                    item.extensionId,
                    item.isBuiltinExtension
                )));
            }
            else {
                if (this._assertBrowserConflicts(keybinding, item.command)) {
                    continue;
                }
                const resolvedKeybindings = this._keyboardMapper.resolveUserBinding(keybinding);
                for (let i = resolvedKeybindings.length - 1; i >= 0; i--) {
                    const resolvedKeybinding = resolvedKeybindings[i];
                    result[resultLen++] = ( (new ResolvedKeybindingItem(
                        resolvedKeybinding,
                        item.command,
                        item.commandArgs,
                        when,
                        isDefault,
                        item.extensionId,
                        item.isBuiltinExtension
                    )));
                }
            }
        }
        return result;
    }
    _resolveUserKeybindingItems(items, isDefault) {
        const result = [];
        let resultLen = 0;
        for (const item of items) {
            const when = item.when || undefined;
            const parts = item.parts;
            if (parts.length === 0) {
                result[resultLen++] = ( (new ResolvedKeybindingItem(undefined, item.command, item.commandArgs, when, isDefault, null, false)));
            }
            else {
                const resolvedKeybindings = this._keyboardMapper.resolveUserBinding(parts);
                for (const resolvedKeybinding of resolvedKeybindings) {
                    result[resultLen++] = ( (new ResolvedKeybindingItem(
                        resolvedKeybinding,
                        item.command,
                        item.commandArgs,
                        when,
                        isDefault,
                        null,
                        false
                    )));
                }
            }
        }
        return result;
    }
    _assertBrowserConflicts(kb, commandId) {
        if (BrowserFeatures.keyboard === 0 ) {
            return false;
        }
        if (BrowserFeatures.keyboard === 1  && isFullscreen()) {
            return false;
        }
        for (const part of kb) {
            if (!part.metaKey && !part.altKey && !part.ctrlKey && !part.shiftKey) {
                continue;
            }
            const modifiersMask = 2048  | 512  | 1024 ;
            let partModifiersMask = 0;
            if (part.metaKey) {
                partModifiersMask |= 2048 ;
            }
            if (part.shiftKey) {
                partModifiersMask |= 1024 ;
            }
            if (part.altKey) {
                partModifiersMask |= 512 ;
            }
            if (part.ctrlKey && OS === 2 ) {
                partModifiersMask |= 256 ;
            }
            if ((partModifiersMask & modifiersMask) === ((2048  | 512) )) {
                if (part instanceof ScanCodeBinding && ((part.scanCode === 86  || part.scanCode === 85) )) {
                    return true;
                }
                if (part instanceof SimpleKeybinding && ((part.keyCode === 15  || part.keyCode === 17) )) {
                    return true;
                }
            }
            if ((partModifiersMask & modifiersMask) === 2048 ) {
                if (part instanceof ScanCodeBinding && ((part.scanCode >= 36  && part.scanCode <= 45) )) {
                    return true;
                }
                if (part instanceof SimpleKeybinding && ((part.keyCode >= 21  && part.keyCode <= 30) )) {
                    return true;
                }
            }
        }
        return false;
    }
    resolveKeybinding(kb) {
        return this._keyboardMapper.resolveKeybinding(kb);
    }
    resolveKeyboardEvent(keyboardEvent) {
        this.keyboardLayoutService.validateCurrentKeyboardMapping(keyboardEvent);
        return this._keyboardMapper.resolveKeyboardEvent(keyboardEvent);
    }
    resolveUserBinding(userBinding) {
        const parts = KeybindingParser.parseUserBinding(userBinding);
        return this._keyboardMapper.resolveUserBinding(parts);
    }
    _handleKeybindingsExtensionPointUser(extensionId, isBuiltin, keybindings, collector, result) {
        if (isContributedKeyBindingsArray(keybindings)) {
            for (let i = 0, len = keybindings.length; i < len; i++) {
                this._handleKeybinding(extensionId, isBuiltin, i + 1, keybindings[i], collector, result);
            }
        }
        else {
            this._handleKeybinding(extensionId, isBuiltin, 1, keybindings, collector, result);
        }
    }
    _handleKeybinding(extensionId, isBuiltin, idx, keybindings, collector, result) {
        const rejects = [];
        if (isValidContributedKeyBinding(keybindings, rejects)) {
            const rule = this._asCommandRule(extensionId, isBuiltin, idx++, keybindings);
            if (rule) {
                result.push(rule);
            }
        }
        if (rejects.length > 0) {
            collector.error(( (localize(
                'invalid.keybindings',
                "Invalid `contributes.{0}`: {1}",
                keybindingsExtPoint.name,
                rejects.join('\n')
            ))));
        }
    }
    static bindToCurrentPlatform(key, mac, linux, win) {
        if (OS === 1  && win) {
            if (win) {
                return win;
            }
        }
        else if (OS === 2 ) {
            if (mac) {
                return mac;
            }
        }
        else {
            if (linux) {
                return linux;
            }
        }
        return key;
    }
    _asCommandRule(extensionId, isBuiltin, idx, binding) {
        const { command, args, when, key, mac, linux, win } = binding;
        const keybinding = WorkbenchKeybindingService.bindToCurrentPlatform(key, mac, linux, win);
        if (!keybinding) {
            return undefined;
        }
        let weight;
        if (isBuiltin) {
            weight = 300  + idx;
        }
        else {
            weight = 400  + idx;
        }
        const commandAction = MenuRegistry.getCommand(command);
        const precondition = commandAction && commandAction.precondition;
        let fullWhen;
        if (when && precondition) {
            fullWhen = ContextKeyExpr.and(precondition, ContextKeyExpr.deserialize(when));
        }
        else if (when) {
            fullWhen = ContextKeyExpr.deserialize(when);
        }
        else if (precondition) {
            fullWhen = precondition;
        }
        const desc = {
            id: command,
            args,
            when: fullWhen,
            weight: weight,
            keybinding: KeybindingParser.parseUserBinding(keybinding),
            extensionId: extensionId.value,
            isBuiltinExtension: isBuiltin
        };
        return desc;
    }
    getDefaultKeybindingsContent() {
        const resolver = this._getResolver();
        const defaultKeybindings = resolver.getDefaultKeybindings();
        const boundCommands = resolver.getDefaultBoundCommands();
        return (WorkbenchKeybindingService._getDefaultKeybindings(defaultKeybindings)
            + '\n\n'
            + WorkbenchKeybindingService._getAllCommandsAsComment(boundCommands));
    }
    static _getDefaultKeybindings(defaultKeybindings) {
        const out = ( (new OutputBuilder()));
        out.writeLine('[');
        const lastIndex = defaultKeybindings.length - 1;
        defaultKeybindings.forEach((k, index) => {
            KeybindingIO.writeKeybindingItem(out, k);
            if (index !== lastIndex) {
                out.writeLine(',');
            }
            else {
                out.writeLine();
            }
        });
        out.writeLine(']');
        return (
             (out.toString())
        );
    }
    static _getAllCommandsAsComment(boundCommands) {
        const unboundCommands = getAllUnboundCommands(boundCommands);
        const pretty = unboundCommands.sort().join('\n// - ');
        return '// ' + ( (localize('unboundCommands', "Here are other available commands: "))) + '\n// - ' + pretty;
    }
    mightProducePrintableCharacter(event) {
        if (event.ctrlKey || event.metaKey || event.altKey) {
            return false;
        }
        const code = ScanCodeUtils.toEnum(event.code);
        if (NUMPAD_PRINTABLE_SCANCODES.indexOf(code) !== -1) {
            if (event.keyCode === IMMUTABLE_CODE_TO_KEY_CODE[code]) {
                return true;
            }
            if (isMacintosh && event.keyCode === otherMacNumpadMapping.get(code)) {
                return true;
            }
            return false;
        }
        const keycode = IMMUTABLE_CODE_TO_KEY_CODE[code];
        if (keycode !== -1) {
            return false;
        }
        const mapping = this.keyboardLayoutService.getRawKeyboardMapping();
        if (!mapping) {
            return false;
        }
        const keyInfo = mapping[event.code];
        if (!keyInfo) {
            return false;
        }
        if (!keyInfo.value || /\s/.test(keyInfo.value)) {
            return false;
        }
        return true;
    }
};
WorkbenchKeybindingService = ( (__decorate([
    ( (__param(0, IContextKeyService))),
    ( (__param(1, ICommandService))),
    ( (__param(2, ITelemetryService))),
    ( (__param(3, INotificationService))),
    ( (__param(4, IUserDataProfileService))),
    ( (__param(5, IConfigurationService))),
    ( (__param(6, IHostService))),
    ( (__param(7, IExtensionService))),
    ( (__param(8, IFileService))),
    ( (__param(9, ILogService))),
    ( (__param(10, IKeyboardLayoutService)))
], WorkbenchKeybindingService)));
class UserKeybindings extends Disposable {
    constructor(userDataProfileService, fileService, logService) {
        super();
        this.userDataProfileService = userDataProfileService;
        this.fileService = fileService;
        this._keybindings = [];
        this.watchDisposables = this._register(( (new DisposableStore())));
        this._onDidChange = this._register(( (new Emitter())));
        this.onDidChange = this._onDidChange.event;
        this.watch();
        this.reloadConfigurationScheduler = this._register(( (new RunOnceScheduler(() => this.reload().then(changed => {
            if (changed) {
                this._onDidChange.fire();
            }
        }), 50))));
        this._register(Event.filter(this.fileService.onDidFilesChange, e => e.contains(this.userDataProfileService.currentProfile.keybindingsResource))(() => {
            logService.debug('Keybindings file changed');
            this.reloadConfigurationScheduler.schedule();
        }));
        this._register(this.fileService.onDidRunOperation((e) => {
            if (e.operation === 4  && ( (e.resource.toString())) === ( (this.userDataProfileService.currentProfile.keybindingsResource.toString()))) {
                logService.debug('Keybindings file written');
                this.reloadConfigurationScheduler.schedule();
            }
        }));
        this._register(userDataProfileService.onDidChangeCurrentProfile(e => e.join(this.whenCurrentProfieChanged(e))));
    }
    get keybindings() { return this._keybindings; }
    async whenCurrentProfieChanged(e) {
        if (e.preserveData) {
            if (await this.fileService.exists(e.previous.keybindingsResource)) {
                await this.fileService.copy(e.previous.keybindingsResource, e.profile.keybindingsResource);
            }
        }
        this.watch();
        this.reloadConfigurationScheduler.schedule();
    }
    watch() {
        this.watchDisposables.clear();
        this.watchDisposables.add(this.fileService.watch(dirname(this.userDataProfileService.currentProfile.keybindingsResource)));
        this.watchDisposables.add(this.fileService.watch(this.userDataProfileService.currentProfile.keybindingsResource));
    }
    async initialize() {
        await this.reload();
    }
    async reload() {
        const existing = this._keybindings;
        try {
            const content = await this.fileService.readFile(this.userDataProfileService.currentProfile.keybindingsResource);
            const value = parse(( (content.value.toString())));
            this._keybindings = isArray(value) ? value : [];
        }
        catch (e) {
            this._keybindings = [];
        }
        return existing ? !equals(existing, this._keybindings) : true;
    }
}
const schemaId = 'vscode://schemas/keybindings';
const commandsSchemas = [];
const commandsEnum = [];
const commandsEnumDescriptions = [];
const schema = {
    id: schemaId,
    type: 'array',
    title: ( (localize('keybindings.json.title', "Keybindings configuration"))),
    allowTrailingCommas: true,
    allowComments: true,
    definitions: {
        'editorGroupsSchema': {
            'type': 'array',
            'items': {
                'type': 'object',
                'properties': {
                    'groups': {
                        '$ref': '#/definitions/editorGroupsSchema',
                        'default': [{}, {}]
                    },
                    'size': {
                        'type': 'number',
                        'default': 0.5
                    }
                }
            }
        }
    },
    items: {
        'required': ['key'],
        'type': 'object',
        'defaultSnippets': [{ 'body': { 'key': '$1', 'command': '$2', 'when': '$3' } }],
        'properties': {
            'key': {
                'type': 'string',
                'description': ( (localize('keybindings.json.key', "Key or key sequence (separated by space)"))),
            },
            'command': {
                'anyOf': [
                    {
                        'type': 'string',
                        'enum': commandsEnum,
                        'enumDescriptions': commandsEnumDescriptions,
                        'description': ( (localize('keybindings.json.command', "Name of the command to execute"))),
                    },
                    {
                        'type': 'string'
                    }
                ]
            },
            'when': {
                'type': 'string',
                'description': ( (localize('keybindings.json.when', "Condition when the key is active.")))
            },
            'args': {
                'description': ( (localize('keybindings.json.args', "Arguments to pass to the command to execute.")))
            }
        },
        'allOf': commandsSchemas
    }
};
const schemaRegistry = ( (Registry.as(Extensions.JSONContribution)));
schemaRegistry.registerSchema(schemaId, schema);
function updateSchema(additionalContributions) {
    commandsSchemas.length = 0;
    commandsEnum.length = 0;
    commandsEnumDescriptions.length = 0;
    const knownCommands = ( (new Set()));
    const addKnownCommand = (commandId, description) => {
        if (!/^_/.test(commandId)) {
            if (!knownCommands.has(commandId)) {
                knownCommands.add(commandId);
                commandsEnum.push(commandId);
                commandsEnumDescriptions.push(description);
                commandsEnum.push(`-${commandId}`);
                commandsEnumDescriptions.push(description);
            }
        }
    };
    const allCommands = CommandsRegistry.getCommands();
    for (const [commandId, command] of allCommands) {
        const commandDescription = command.description;
        addKnownCommand(commandId, commandDescription ? commandDescription.description : undefined);
        if (!commandDescription || !commandDescription.args || commandDescription.args.length !== 1 || !commandDescription.args[0].schema) {
            continue;
        }
        const argsSchema = commandDescription.args[0].schema;
        const argsRequired = ((typeof commandDescription.args[0].isOptional !== 'undefined')
            ? (!commandDescription.args[0].isOptional)
            : (Array.isArray(argsSchema.required) && argsSchema.required.length > 0));
        const addition = {
            'if': {
                'properties': {
                    'command': { 'const': commandId }
                }
            },
            'then': {
                'required': [].concat(argsRequired ? ['args'] : []),
                'properties': {
                    'args': argsSchema
                }
            }
        };
        commandsSchemas.push(addition);
    }
    const menuCommands = MenuRegistry.getCommands();
    for (const commandId of ( (menuCommands.keys()))) {
        addKnownCommand(commandId);
    }
    commandsSchemas.push(...additionalContributions);
    schemaRegistry.notifySchemaChanged(schemaId);
}
const configurationRegistry = ( (Registry.as(Extensions$1.Configuration)));
const keyboardConfiguration = {
    'id': 'keyboard',
    'order': 15,
    'type': 'object',
    'title': ( (localize('keyboardConfigurationTitle', "Keyboard"))),
    'properties': {
        'keyboard.dispatch': {
            scope: 1 ,
            type: 'string',
            enum: ['code', 'keyCode'],
            default: 'code',
            markdownDescription: ( (localize(
                'dispatch',
                "Controls the dispatching logic for key presses to use either `code` (recommended) or `keyCode`."
            ))),
            included: OS === 2  || OS === 3
        }
    }
};
configurationRegistry.registerConfiguration(keyboardConfiguration);
let CommandsQuickAccessProvider = class CommandsQuickAccessProvider extends AbstractEditorCommandsQuickAccessProvider {
    constructor(editorService, menuService, extensionService, instantiationService, keybindingService, commandService, telemetryService, dialogService, configurationService, editorGroupService, preferencesService) {
        super({
            showAlias: !Language.isDefaultVariant(),
            noResultsPick: {
                label: ( (localize('noCommandResults', "No matching commands"))),
                commandId: ''
            }
        }, instantiationService, keybindingService, commandService, telemetryService, dialogService);
        this.editorService = editorService;
        this.menuService = menuService;
        this.extensionService = extensionService;
        this.configurationService = configurationService;
        this.editorGroupService = editorGroupService;
        this.preferencesService = preferencesService;
        this.extensionRegistrationRace = Promise.race([
            timeout(800),
            this.extensionService.whenInstalledExtensionsRegistered()
        ]);
    }
    get activeTextEditorControl() { return this.editorService.activeTextEditorControl; }
    get defaultFilterValue() {
        if (this.configuration.preserveInput) {
            return DefaultQuickAccessFilterValue.LAST;
        }
        return undefined;
    }
    get configuration() {
        const commandPaletteConfig = this.configurationService.getValue().workbench.commandPalette;
        return {
            preserveInput: commandPaletteConfig.preserveInput
        };
    }
    async getCommandPicks(disposables, token) {
        await this.extensionRegistrationRace;
        if (token.isCancellationRequested) {
            return [];
        }
        return [
            ...this.getCodeEditorCommandPicks(),
            ...this.getGlobalCommandPicks(disposables)
        ].map(c => ({
            ...c,
            buttons: [{
                    iconClass: Codicon.gear.classNames,
                    tooltip: ( (localize('configure keybinding', "Configure Keybinding"))),
                }],
            trigger: () => {
                this.preferencesService.openGlobalKeybindingSettings(false, { query: `@command:${c.commandId}` });
                return TriggerAction.CLOSE_PICKER;
            },
        }));
    }
    getGlobalCommandPicks(disposables) {
        const globalCommandPicks = [];
        const scopedContextKeyService = this.editorService.activeEditorPane?.scopedContextKeyService || this.editorGroupService.activeGroup.scopedContextKeyService;
        const globalCommandsMenu = this.menuService.createMenu(MenuId.CommandPalette, scopedContextKeyService);
        const globalCommandsMenuActions = globalCommandsMenu.getActions()
            .reduce((r, [, actions]) => [...r, ...actions], [])
            .filter(action => action instanceof MenuItemAction && action.enabled);
        for (const action of globalCommandsMenuActions) {
            let label = (typeof action.item.title === 'string' ? action.item.title : action.item.title.value) || action.item.id;
            const category = typeof action.item.category === 'string' ? action.item.category : action.item.category?.value;
            if (category) {
                label = ( (localize('commandWithCategory', "{0}: {1}", category, label)));
            }
            const aliasLabel = typeof action.item.title !== 'string' ? action.item.title.original : undefined;
            const aliasCategory = (category && action.item.category && typeof action.item.category !== 'string') ? action.item.category.original : undefined;
            const commandAlias = (aliasLabel && category) ?
                aliasCategory ? `${aliasCategory}: ${aliasLabel}` : `${category}: ${aliasLabel}` :
                aliasLabel;
            globalCommandPicks.push({
                commandId: action.item.id,
                commandAlias,
                label: stripIcons(label)
            });
        }
        globalCommandsMenu.dispose();
        disposables.add(toDisposable(() => dispose(globalCommandsMenuActions)));
        return globalCommandPicks;
    }
};
CommandsQuickAccessProvider = ( (__decorate([
    ( (__param(0, IEditorService))),
    ( (__param(1, IMenuService))),
    ( (__param(2, IExtensionService))),
    ( (__param(3, IInstantiationService))),
    ( (__param(4, IKeybindingService))),
    ( (__param(5, ICommandService))),
    ( (__param(6, ITelemetryService))),
    ( (__param(7, IDialogService))),
    ( (__param(8, IConfigurationService))),
    ( (__param(9, IEditorGroupsService))),
    ( (__param(10, IPreferencesService)))
], CommandsQuickAccessProvider)));
let DelegateStandaloneKeybindingService = class DelegateStandaloneKeybindingService extends createInjectedClass(StandaloneKeybindingService) {
    constructor(instantiationService) {
        super(instantiationService);
        this.delegate = instantiationService.createInstance(WorkbenchKeybindingService);
        this._cachedOverridenResolver = null;
        this.onDidUpdateKeybindings(() => {
            this._cachedOverridenResolver = null;
        });
        this.delegate.onDidUpdateKeybindings(() => {
            this._cachedOverridenResolver = null;
        });
    }
    _getResolver() {
        if (this._cachedOverridenResolver == null) {
            const overrides = this['_toNormalizedKeybindingItems'](this['_dynamicKeybindings'], false);
            this._cachedOverridenResolver = new KeybindingResolver(
            [...this.delegate['_getResolver']().getKeybindings()], overrides, (str) => this._log(str));
        }
        return this._cachedOverridenResolver;
    }
};
DelegateStandaloneKeybindingService = ( __decorate([
    ( __param(0, IInstantiationService))
], DelegateStandaloneKeybindingService));
const quickAccessRegistry = ( Registry.as(Extensions$2.Quickaccess));
const provider = quickAccessRegistry.getQuickAccessProviders().find(provider => provider.ctor === StandaloneCommandsQuickAccessProvider);
if (provider != null) {
    provider.ctor = class extends CommandsQuickAccessProvider {
        get defaultFilterValue() { return undefined; }
        async getCommandPicks(disposables, token) {
            return (await super.getCommandPicks(disposables, token)).map(pick => {
                pick.buttons = [];
                return pick;
            });
        }
    };
}
const keybindingsExtensionPoint = getExtensionPoint('keybindings');
const commandsExtensionPoint = getExtensionPoint('commands');
function setKeybindings(grammars, extension = Services.get().extension ?? DEFAULT_EXTENSION) {
    keybindingsExtensionPoint.acceptUsers([{
            description: extension,
            value: grammars,
            collector: new ExtensionMessageCollector(consoleExtensionMessageHandler, extension, keybindingsExtensionPoint.name)
        }]);
}
function setCommands(keybindings, extension = Services.get().extension ?? DEFAULT_EXTENSION) {
    commandsExtensionPoint.acceptUsers([{
            description: extension,
            value: keybindings,
            collector: new ExtensionMessageCollector(consoleExtensionMessageHandler, extension, keybindingsExtensionPoint.name)
        }]);
}
function updateUserKeybindings(keybindingsJson) {
    const userDataProfilesService = StandaloneServices.get(IUserDataProfilesService);
    void StandaloneServices.get(IFileService).writeFile(userDataProfilesService.defaultProfile.keybindingsResource, VSBuffer.fromString(keybindingsJson));
}
function getServiceOverride() {
    return {
        ...getServiceOverride$1(),
        [( IKeybindingService.toString())]: new SyncDescriptor(DelegateStandaloneKeybindingService)
    };
}
export { getServiceOverride as default, setCommands, setKeybindings, updateUserKeybindings };

import { _ as __decorate, a as __param } from './contextkey.js';
export { C as ContextKeyExprType } from './contextkey.js';
import './polyfill.js';
import * as monaco from 'monaco-editor/esm/vs/editor/editor.api.js';
export { registerColor } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { c as createInjectedClass } from './injection.js';
import { editorOptionsRegistry } from 'monaco-editor/esm/vs/editor/common/config/editorOptions.js';
import { equals as equals$1 } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
export { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { ITextResourceConfigurationService } from 'monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js';
import { StandaloneServices } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js';
import { Extensions as Extensions$1 } from 'monaco-editor/esm/vs/platform/jsonschemas/common/jsonContributionRegistry.js';
import { Extensions as Extensions$2 } from 'monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js';
import { StandaloneDiffEditor, StandaloneEditor } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneCodeEditor.js';
import { isObject } from 'monaco-editor/esm/vs/base/common/types.js';
import { deepClone } from 'monaco-editor/esm/vs/base/common/objects.js';
export { errorHandler } from 'monaco-editor/esm/vs/base/common/errors.js';
export { DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
export { FoldingController } from 'monaco-editor/esm/vs/editor/contrib/folding/browser/folding.js';
export { FoldingModel, setCollapseStateForMatchingLines } from 'monaco-editor/esm/vs/editor/contrib/folding/browser/foldingModel.js';
export { CommandsRegistry } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
function equals(one, other) {
    if (one === other) {
        return true;
    }
    if (one === null || one === undefined || other === null || other === undefined) {
        return false;
    }
    if (typeof one !== typeof other) {
        return false;
    }
    if (typeof one !== 'object') {
        return false;
    }
    if ((Array.isArray(one)) !== (Array.isArray(other))) {
        return false;
    }
    let i;
    let key;
    if (Array.isArray(one)) {
        if (one.length !== other.length) {
            return false;
        }
        for (i = 0; i < one.length; i++) {
            if (!equals(one[i], other[i])) {
                return false;
            }
        }
    }
    else {
        const oneKeys = [];
        for (key in one) {
            oneKeys.push(key);
        }
        oneKeys.sort();
        const otherKeys = [];
        for (key in other) {
            otherKeys.push(key);
        }
        otherKeys.sort();
        if (!equals(oneKeys, otherKeys)) {
            return false;
        }
        for (i = 0; i < oneKeys.length; i++) {
            if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
                return false;
            }
        }
    }
    return true;
}
function distinct(base, target) {
    const result = Object.create(null);
    if (!base || !target) {
        return result;
    }
    const targetKeys = ( (Object.keys(target)));
    targetKeys.forEach(k => {
        const baseValue = base[k];
        const targetValue = target[k];
        if (!equals(baseValue, targetValue)) {
            result[k] = targetValue;
        }
    });
    return result;
}
const ConfigurationChangedEvent = monaco.editor.ConfigurationChangedEvent;
class ValidatedEditorOptions {
    constructor() {
        this._values = [];
    }
    _read(option) {
        return this._values[option];
    }
    get(id) {
        return this._values[id];
    }
    _write(option, value) {
        this._values[option] = value;
    }
}
class ComputedEditorOptions {
    constructor() {
        this._values = [];
    }
    _read(id) {
        if (id >= this._values.length) {
            throw new Error('Cannot read uninitialized value');
        }
        return this._values[id];
    }
    get(id) {
        return this._read(id);
    }
    _write(id, value) {
        this._values[id] = value;
    }
}
class EditorOptionsUtil {
    static validateOptions(options) {
        const result = ( (new ValidatedEditorOptions()));
        for (const editorOption of editorOptionsRegistry) {
            const value = (editorOption.name === '_never_' ? undefined : options[editorOption.name]);
            result._write(editorOption.id, editorOption.validate(value));
        }
        return result;
    }
    static computeOptions(options, env) {
        const result = ( (new ComputedEditorOptions()));
        for (const editorOption of editorOptionsRegistry) {
            result._write(editorOption.id, editorOption.compute(env, result, options._read(editorOption.id)));
        }
        return result;
    }
    static _deepEquals(a, b) {
        if (typeof a !== 'object' || typeof b !== 'object' || !a || !b) {
            return a === b;
        }
        if (Array.isArray(a) || Array.isArray(b)) {
            return (Array.isArray(a) && Array.isArray(b) ? equals$1(a, b) : false);
        }
        if (( (Object.keys(a))).length !== ( (Object.keys(b))).length) {
            return false;
        }
        for (const key in a) {
            if (!EditorOptionsUtil._deepEquals(a[key], b[key])) {
                return false;
            }
        }
        return true;
    }
    static checkEquals(a, b) {
        const result = [];
        let somethingChanged = false;
        for (const editorOption of editorOptionsRegistry) {
            const changed = !EditorOptionsUtil._deepEquals(a._read(editorOption.id), b._read(editorOption.id));
            result[editorOption.id] = changed;
            if (changed) {
                somethingChanged = true;
            }
        }
        return (somethingChanged ?  (new ConfigurationChangedEvent(result)) : null);
    }
    static applyUpdate(options, update) {
        let changed = false;
        for (const editorOption of editorOptionsRegistry) {
            if (update.hasOwnProperty(editorOption.name)) {
                const result = editorOption.applyUpdate(options[editorOption.name], update[editorOption.name]);
                options[editorOption.name] = result.newValue;
                changed = changed || result.didChange;
            }
        }
        return changed;
    }
}
function computeConfiguration(configuration, isDiffEditor, overrides) {
    const editorConfiguration = isObject(configuration.editor) ? deepClone(configuration.editor) : Object.create(null);
    if (isDiffEditor && isObject(configuration.diffEditor)) {
        Object.assign(editorConfiguration, deepClone(configuration.diffEditor));
    }
    Object.assign(editorConfiguration, deepClone(overrides));
    return editorConfiguration;
}
let ConfiguredStandaloneEditor = class ConfiguredStandaloneEditor extends createInjectedClass(StandaloneEditor) {
    constructor(domElement, isDiffEditor, _options = {}, instantiationService, textResourceConfigurationService) {
        const { theme, autoDetectHighContrast, model, value, language, accessibilityHelpUrl, ariaContainerElement, ...options } = _options;
        const computedOptions = computeConfiguration(textResourceConfigurationService.getValue(_options.model?.uri), isDiffEditor, options);
        super(instantiationService, domElement, { ...computedOptions, theme, autoDetectHighContrast, model, value, language, accessibilityHelpUrl, ariaContainerElement });
        this.isDiffEditor = isDiffEditor;
        this.textResourceConfigurationService = textResourceConfigurationService;
        this.optionsOverrides = {};
        this.lastAppliedEditorOptions = computedOptions;
        this.optionsOverrides = options;
        this._register(textResourceConfigurationService.onDidChangeConfiguration(() => this.updateEditorConfiguration()));
        this._register(this.onDidChangeModelLanguage(() => this.updateEditorConfiguration()));
        this._register(this.onDidChangeModel(() => this.updateEditorConfiguration()));
    }
    updateEditorConfiguration() {
        const resource = this.getModel()?.uri;
        if (resource == null) {
            return;
        }
        const configuration = this.textResourceConfigurationService.getValue(resource);
        if (configuration == null) {
            return;
        }
        const editorConfiguration = computeConfiguration(configuration, this.isDiffEditor, this.optionsOverrides);
        let editorSettingsToApply = editorConfiguration;
        if (this.lastAppliedEditorOptions != null) {
            editorSettingsToApply = distinct(this.lastAppliedEditorOptions, editorSettingsToApply);
        }
        if (( Object.keys(editorSettingsToApply)).length > 0) {
            this.lastAppliedEditorOptions = editorConfiguration;
            super.updateOptions(editorSettingsToApply);
        }
    }
    updateOptions(newOptions) {
        const didChange = EditorOptionsUtil.applyUpdate(this.optionsOverrides, newOptions);
        if (!didChange) {
            return;
        }
        this.updateEditorConfiguration();
    }
};
ConfiguredStandaloneEditor = ( __decorate([
    ( __param(3, IInstantiationService)),
    ( __param(4, ITextResourceConfigurationService))
], ConfiguredStandaloneEditor));
class ConfiguredStandaloneDiffEditor extends StandaloneDiffEditor {
    _createInnerEditor(instantiationService, container, options) {
        return instantiationService.createInstance(ConfiguredStandaloneEditor, container, true, options);
    }
}
const createConfiguredEditor = (domElement, options, override) => {
    const instantiationService = StandaloneServices.initialize(override ?? {});
    return instantiationService.createInstance(ConfiguredStandaloneEditor, domElement, false, options);
};
const createConfiguredDiffEditor = (domElement, options, override) => {
    const instantiationService = StandaloneServices.initialize(override ?? {});
    return instantiationService.createInstance(ConfiguredStandaloneDiffEditor, domElement, options);
};
const Extensions = {
    ...Extensions$1,
    ...Extensions$2
};
const registry = ( Registry.as(Extensions.JSONContribution));
function getJsonSchemas(fileMatchs = {}) {
    return Object.entries(registry.getSchemaContributions().schemas)
        .filter(([uri]) => uri !== 'vscode://schemas/vscode-extensions')
        .map(([uri, schema]) => {
        const path = monaco.Uri.parse(uri).path;
        const schemaName = path.slice(1);
        return {
            uri,
            schema,
            fileMatch: schemaName != null ? fileMatchs[schemaName] : undefined
        };
    });
}
const onDidChangeJsonSchema = registry.onDidChangeSchema;
export { Extensions, createConfiguredDiffEditor, createConfiguredEditor, getJsonSchemas, onDidChangeJsonSchema };
